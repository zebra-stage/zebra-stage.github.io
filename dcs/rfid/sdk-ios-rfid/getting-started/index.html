<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Programmers can use these scanner Software Development Kits to build applications.">
        <meta name="author" content="Zebra Technologies">
        <meta name="google-site-verification" content="i4B78BrWnNy8ShJwe5feRW3jO3HE6gfYlYqYbxfl8yY">
        <meta name="msvalidate.01" content="6B651B00161BCE79B8950AC09D5C4C75">
        <meta title="Getting Started RFID SDK for iOS">
        <title>RFID SDK for iOS - Getting Started - Zebra Technologies</title>
        <!-- core CSS -->
        <link href="/css/bootstrap.min.css" rel="stylesheet">
        <link href="/css/font-awesome.min.css" rel="stylesheet">
        <link href="/css/animate.min.css" rel="stylesheet">
        <link href="/css/owl.carousel.css" rel="stylesheet">
        <link href="/css/owl.transitions.css" rel="stylesheet">
        <link href="/css/prettyPhoto.css" rel="stylesheet">
        <link href="/css/main.css" rel="stylesheet">
        <link href="/css/responsive.css" rel="stylesheet">
        <link href="/css/prettify.css" rel="stylesheet">
        <link href="/css/bootstrap-treenav.min.css" rel="stylesheet">
        <!--[if lt IE 9]>
        <script src="js/html5shiv.js"></script>
        <script src="js/respond.min.js"></script>
        <![endif]--> 
        <script src="//load.sumome.com/" data-sumo-site-id="699cb66cf4dc59352efb45705526d15cbe314e1cd43f7761b94d96f3cf7338e8" async="async"></script>
        <link rel="shortcut icon" href="/favicon.ico">
        <script src="/js/jquery.js"></script>
    </head>
    <body id="home" class="homepage" data-spy="scroll" data-offset="100" data-target="#toc">
        <header id="header">
            <nav id="main-menu" class="navbar navbar-default navbar-fixed-top" role="banner">
                <div class="container-fluid">
                    <div class="navbar-header">
                        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                            <span class="sr-only">Toggle navigation</span>
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                        </button>
                        <a class="navbar-brand" href="/">
                            <img src="/images/logo.png" alt="logo" style="max-height:66px;float: inherit; padding-right: 3px;">
                        </a> 
                    </div>
                    <div class="collapse navbar-collapse navbar-left">
                        <ul class="nav navbar-nav">
                            <li class="navbar-text pull-left"><strong>TechDocs</strong></li>
                            <li>
                                <a href="/dcs/rfid">RFID</a>
                            </li>
                            <p class="navbar-text">RFID SDK for iOS</p>
                        </ul>
                    </div>
                    <div class="collapse navbar-collapse navbar-right">
                        <ul class="nav navbar-nav">
                            <li>
                                <a href="/dcs/rfid/sdk-ios-rfid/about/">About</a>
                            </li>
                            <li>
                                <a href="/dcs/rfid/sdk-ios-rfid/getting-started/">Getting Started</a>
                            </li>
                            <li>
                                <a href="/dcs/rfid/sdk-ios-rfid/download/">
                                    <i class="fa fa-download"></i>
                                </a>
                            </li>
                        </ul>
                    </div>
                </div><!--/.container-->
            </nav><!--/nav-->
        </header><!--/header-->
        <div class="container-fluid">
            <section id="blog">
                <div class="">
                    <section class="content-with-sidebar">
                        <div class="row">
                            <div class="col-sm-3 hidden-sm hidden-xs" id="sidebar">
                                <nav id="toc" data-toggle="toc" data-spy="affix" style="height: 75%; max-width: 225px; overflow-y: auto; ">
                                    <ul class="nav">
                                        <li><strong>Programmer's Guide for RFID SDK for iOS</strong></li>
                                    </ul>
                                </nav>                    
                                <script type="text/javascript">
                                    $(document).ready(function() {
                        	            $( "#btn_SaveSmartDocOptions" ).click(function() {
                      			            console.log('Saving Options');
                      			            $("#modal-smartdocs").modal({show: false});
                    		            });
                        	            $( "#btn_SaveSmartDocOptions" ).click(function() {
                      			            console.log('Clearing Options');
                      			            $("#modal-smartdocs").modal({show: false});
                    		            });
                                    });
                                </script>
                                <link rel="stylesheet" href="https://cdn.rawgit.com/afeld/bootstrap-toc/v0.3.0/dist/bootstrap-toc.min.css">
                                <script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v0.3.0/dist/bootstrap-toc.min.js"></script>
                                <script type="text/javascript">
                                    $(document).ready(function() {                    
                                    });
                                </script>
                            </div>                
                            <div class="col-sm-9 ">
                                <div class="row">
                                    <div class="col-sm-12">
                                        <section id="cta" class="wow fadeIn">
                                            <div class="">
                                                <h1 id="getting-started-rfid-sdk-ios" class="anchor">
                                                    <a class="heading-anchor" href="#getting-started-rfid-sdk-ios"><span></span></a>Programmer's Guide for RFID SDK for iOS
                                                </h1>
                                            </div>
                                        </section>                    
                                    </div>
                                </div>
                                <div id="mainContent" class="row">
                                    <div class="col-sm-12">
                                        <div class="blog-post blog-large wow fadeInLeft" data-wow-duration="300ms" data-wow-delay="0ms">
                                            <!-- Start of guide -->
                                            <div class="service-box wow fadeInRight">
                                                <div class="">
                                                    <h2 id="overview" class="anchor"><a class="heading-anchor" href="#overview"><span></span></a>Overview</h2>

                                                    <p>This section describes step-by-step instructions for setting up new XCode project to work with Zebra Bluetooth RFID iOS SDK.</p>
                                                    
                                                    <hr>

                                                    <h2 id="development-setup" class="anchor"><a class="heading-anchor" href="#development-setup"><span></span></a>Creating Xcode Project</h2>

                                                    <p>Create new &ldquo;iOS Application&rdquo; project in XCode IDE</p>

                                                    <div style="display: block; margin: 0 auto; text-align: center;">
                                                        <img width="805" height="576" src="../../images/ios/index_clip_image002.gif" alt="Graphical user interface, application  Description automatically generated"><strong>Figure 1</strong> Select Project Template
                                                    </div>

                                                    <br />

                                                    <div style="display: block; margin: 0 auto; text-align: center;"><img width="807" height="576" src="../../images/ios/index_clip_image002_0000.gif" alt="Graphical user interface  Description automatically generated"><strong>Figure 2</strong> Project Options
                                                    </div>

                                                    <p>Copy symbolrfid-sdk folder with static  library and headers from Zebra Bluetooth RFID iOS SDK installation directory to  the root folder of your XCode project (note: symbolic link could also be used  instead of copying)</p>

                                                    <div style="display: block; margin: 0 auto; text-align: center;">
                                                      <p><img width="807" height="471" src="../../images/ios/index_clip_image002_0001.gif" alt="Graphical user interface, application  Description automatically generated"></p>
                                                      <p><strong>Figure 3</strong> SDK Symbolic Link
                                                      </p>
                                                    </div>

                                                    <p>Configure your XCode project to support the &ldquo;com.zebra.rfd8X00_easytext  and com.zebra.scanner.SSI&rdquo; external accessory communication protocol  through including the Supported external accessory protocols key  in your app&rsquo;s Info.plist  file or via [Info]  tab of your project settings</p>

                                                    <p>If your application is supposed to be able to communicate with BT RFID readers in a background mode configure your XCode project to declare the background modes your app supports through including the UIBackgroundModes key in your app’s Info.plist file or via [Info] tab of your project settings</p>

                                                    <div style="display: block; margin: 0 auto; text-align: center;"><img width="808" height="360" src="../../images/ios/index_clip_image002_0002.gif" alt="Graphical user interface, text, application, email  Description automatically generated"><strong>Figure 4</strong> Project Info on plist
                                                    </div>

                                                    <p>Configure your application to be linked with following default iOS frameworks that are required for utilization of Zebra Bluetooth RFID iOS SDK via [Link Binary With Libraries] section of [Build Phases] tab of your project settings:</p>

                                                    <ul>
                                                        <li>ExternalAccessory.framework</li>
                                                        <li>CoreBluetooth.framework</li>
                                                    </ul>

                                                    <div style="display: block; margin: 0 auto; text-align: center;"><img width="810" height="441" src="../../images/ios/index_clip_image002_0003.gif" alt="Graphical user interface, text, application, email  Description automatically generated"><strong>Figure 5</strong> Project Build Settings
                                                    </div>

                                                    <p>Configure your XCode project to make Zebra Bluetooth RFID  iOS SDK headers available through &ldquo;$(SRCROOT)/symbolrfid-sdk/include/&rdquo;  value of [User  Header Search Paths] option  in [Search  Paths] section of [Build Settings] tab of your project  settings</p>

                                                    <div style="display: block; margin: 0 auto; text-align: center;"><img width="806" height="614" src="../../images/ios/index_clip_image002_0005.gif" alt="Graphical user interface, application  Description automatically generated"><strong>Figure 6</strong> Project Build Settings - SDK Headers
                                                    </div>

                                                    <p><strong>.</strong> Configure your application to be linked with Zebra Bluetooth RFID iOS SDK  static library through [Link Binary With Libraries]  section of [Build  Phases] tab of your project settings</p>

                                                    <div style="display: block; margin: 0 auto; text-align: center;"><img width="807" height="723" src="../../images/ios/index_clip_image002_0006.gif" alt="Graphical user interface, application  Description automatically generated"><strong>Figure 7</strong> Project Build Settings - Static Library
                                                    </div>

                                                    <br />

                                                    <div style="display: block; margin: 0 auto; text-align: center;"><img width="807" height="771" src="../../images/ios/index_clip_image002_0007.gif" alt="Graphical user interface, application  Description automatically generated"><strong><br>
                                                    Figure 8</strong> Project Build Settings - Static Library
                                                    </div>

                                                    <br />

                                                    <div style="display: block; margin: 0 auto; text-align: center;">
                                                      <p><img width="806" height="716" src="../../images/ios/index_clip_image002_0008.gif" alt="Graphical user interface, text, application  Description automatically generated"><strong><br>
                                                      Figure 9</strong> Project Build Settings - Static Library
                                                      </p>
                                                      <p><img width="806" height="716" src="../../images/ios/index_clip_image002_0009.gif" alt="Graphical user interface, text, application  Description automatically generated"><br>
                                                        <br>
                                                      <img width="807" height="537" src="../../images/ios/index_clip_image002_0010.gif" alt="Graphical user interface, text, application, email  Description automatically generated">                                                      </p>
                                                      <p>Add libz.tbd library. </p>
                                                      <p><img src="../../images/ios/Add_libz.tbd.png" width="1204" height="1092" alt=""/></p>
                                                    </div>

                                                    <hr>
													
													<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#pair-by-scan"><span></span></a>RFID SDK API Calls</h2	>										
                                                   
												

													<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#ImplementsrfidISdkApiDelegateProtocol"><span></span></a>Implement <em>srfidISdkApiDelegateProtocol</h2>
													<p>The SDK supports a set of asynchronous notifications to  inform the application about RFID reader related events (e.g. reception of tag  data, starting of radio operation etc) and connectivity related events (e.g.  appearance of RFID reader). All supported callbacks are defined by <em>srfidISdkApiDelegate</em> Objective C  protocol. In order to receive asynchronous notifications from the SDK the  application shall perform following steps.</p>
													<p>Step 1: create an object that  implements <em>srfidISdkApiDelegateProtocol</em></p>
													
													<p>The ViewController.h  class</p>
														
														
<pre class="prettyprint"><code>
#import <UIKit/UIKit.h> 
#import "RfidSdkApiDelegate.h"

@interface ViewController : UIViewController<srfidISdkApiDelegate> {
}
@end
</code></pre>

													<p align="center" >The Event ViewController.m  class</p>

<pre class="prettyprint"><code>
#import "ViewController.h"
@implementation ViewController

- (void)srfidEventBatteryNotity:(int)readerID aBatteryEvent:(srfidBatteryEvent *)batteryEvent {
    // &lt;#code#>
}

- (void)srfidEventCommunicationSessionEstablished:(srfidReaderInfo *)activeReader {
    NSLog(@"Reader Connected ");
}


- (void)srfidEventCommunicationSessionTerminated:(int)readerID {
    NSLog(@"Reader Disconnected ");
}

- (void)srfidEventMultiProximityNotify:(int)readerID aTagData:(srfidTagData *)tagData {
    // &lt;#code#>
}

- (void)srfidEventProximityNotify:(int)readerID aProximityPercent:(int)proximityPercent {
    // &lt;#code#>
}

- (void)srfidEventReadNotify:(int)readerID aTagData:(srfidTagData *)tagData {
    // &lt;#code#>
}

- (void)srfidEventReaderAppeared:(srfidReaderInfo *)availableReader {
    // &lt;#code#>
}

- (void)srfidEventReaderDisappeared:(int)readerID {
    // &lt;#code#>
}

- (void)srfidEventStatusNotify:(int)readerID aEvent:(SRFID_EVENT_STATUS)event aNotification:(id)notificationData {
    // &lt;#code#>
}

- (void)srfidEventTriggerNotify:(int)readerID aTriggerEvent:(SRFID_TRIGGEREVENT)triggerEvent {
    // &lt;#code#>
}

@end
</code></pre>
													
                                                    <p>Step 2: register the created object as notification receiver via <em>srfidSetDelegate</em> API function.</p>

<pre class="prettyprint"><code>
-(void)registerOfcallbackInterfaceWithSDK {
    /* registration of callback interface with SDK */
    [apiInstance srfidSetDelegate:self];
}
</code></pre>

													 <p>Step 3: subscribe for asynchronous event of particular types  via <em>srfidSubscribeForEvents</em> API  function.</p>
													 <p>If a particular object is registered as a notification  receiver the SDK will call the corresponding method of the registered object  when a particular event occurs if the application is subscribed for events of  this type. The SDK may deliver asynchronous events on a main thread or on one  of SDK helper threads so the object that implements <em>srfidISdkApiDelegate</em> protocol shall be thread-safe.</p>
													 
<pre class="prettyprint"><code>
-(void)subcribeForEvent {
    int notifications_mask_reader_connection = SRFID_EVENT_READER_APPEARANCE | SRFID_EVENT_READER_DISAPPEARANCE | SRFID_EVENT_SESSION_ESTABLISHMENT |
SRFID_EVENT_SESSION_TERMINATION;
    [apiInstance srfidSubsribeForEvents:notifications_mask_reader_connection];

    /* subscribe for battery and handheld trigger related events */
    [apiInstance srfidSubsribeForEvents:(SRFID_EVENT_MASK_BATTERY | SRFID_EVENT_MASK_TRIGGER)];
    [apiInstance srfidSubsribeForEvents:(SRFID_EVENT_MASK_READ | SRFID_EVENT_MASK_STATUS | SRFID_EVENT_MASK_STATUS_OPERENDSUMMARY)];
    [apiInstance srfidSubsribeForEvents:(SRFID_EVENT_MASK_TEMPERATURE | SRFID_EVENT_MASK_POWER | SRFID_EVENT_MASK_DATABASE)];
    [apiInstance srfidSubsribeForEvents:(SRFID_EVENT_MASK_PROXIMITY)];
    [apiInstance srfidSubsribeForEvents:(SRFID_EVENT_MASK_TRIGGER)];
    [apiInstance srfidSubsribeForEvents:(SRFID_EVENT_MASK_BATTERY)];
    [apiInstance srfidSubsribeForEvents:(SRFID_EVENT_MASK_MULTI_PROXIMITY)];
}
</code></pre>
													
													<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#pair-by-scan"><span></span></a>Connectivity Management</h2		
																											
													
													<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#pair-by-scan"><span></span></a>Set Operation Mode</h2>

													<p align="justify">Zebra Bluetooth RFID iOS SDK is designed to support interaction with RFID readers operating in either BT MFi or BT LE mode. The SDK shall be intentionally configured to enable communication with a particular type of RFID readers via srfidSetOperationalMode API function. If operating mode of the SDK is not configured the SDK will remain disabled and will not be able to communicate with RFID readers in neither BT MFi nor BT LE modes. 
													Following example demonstrates enabling interaction with RFID readers in BT MFi mode.
													</p		
																											
													

													
													<p align="justify">Following example demonstrates enabling interaction  with RFID readers in BT MFi mode</p		
																											
<pre class="prettyprint"><code>
[apiInstance srfidSetOperationalMode:SRFID_OPMODE_MFI];
</code></pre>

													
													<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#Get available readers"><span></span></a>Get available readers</h2>
													
													<p>Following terms are introduced to distinguish RFID readers  that are seen by the SDK via OS API and RFID readers with that the SDK has  established a logical communication session and thus is able to interact. A  RFID reader is called available if it is already connected to the iOS device  via Bluetooth. Such RFID reader is seen by the SDK and the SDK can establish a  logical communication session to interact with the RFID reader. If a logical  communication session is established with already connected via Bluetooth RFID  reader the RFID reader is called active.</p>
                                                  <p>The SDK supports simultaneous interaction with multiple  active RFID readers. To distinguish various RFID readers the SDK assigns the  unique integer identifier for each RFID reader when it becomes available first  time. </p>
                                                  <p>The SDK maintains internal lists of active and available  RFID readers. Following example demonstrates reception of lists of active and  available RFID readers from the SDK. </p>
<pre class="prettyprint"><code>
-(void)getAvialableReaderList{
    /* allocate an array for storage of list of available RFID readers */
    NSMutableArray *available_readers = [[NSMutableArray alloc] init];

    /* allocate an array for storage of list of active RFID readers */
    NSMutableArray *active_readers = [[NSMutableArray alloc] init];

    /* retrieve a list of available readers */
    [apiInstance srfidGetAvailableReadersList:&available_readers];

    /* retrieve a list of active readers */
    [apiInstance srfidGetActiveReadersList:&active_readers];

    /* merge active and available readers to a single list */
    NSMutableArray *readers = [[NSMutableArray alloc] init];

    [readers addObjectsFromArray:active_readers];
    [readers addObjectsFromArray:available_readers];
    for (srfidReaderInfo *info in readers) {
        /* print the information about RFID reader represented by srfidReaderInfo object */
        NSLog(@"RFID reader is %@: ID = %d name = %@\n", (([info isActive] == YES) ? @"active" : @"available"), [info getReaderID], [info getReaderName]);
        lable_reader_list.text = [info getReaderName];
        readerId = [info getReaderID];
    }
}
</code></pre>
												  
												  <h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#Enable available readers detection"><span></span></a>Enable available readers detection</h2>
												  <p>The SDK supports automatic detection of appearance and  disappearance of available RFID readers. When &ldquo;Available readers detection&rdquo;  option is enabled the SDK will update its internal list of available RFID  readers and deliver a corresponding asynchronous notification once it detects  connection or disconnection of a particular RFID reader to the iOS device via  Bluetooth. If the option is disabled the SDK updates its internal list of  available RFID readers only when it is requested by an application via <em>srfidGetAvailableReadersList</em> API function.  Following example demonstrates enabling of automatic detection and processing  of corresponding asynchronous notifications</p>
												  
<pre class="prettyprint"><code>[apiInstance srfidEnableAvailableReadersDetection:YES];</code></pre>
												  
                                                  <h2 id="pair-by-scan" class="Enable automatic  communication session reestablishment">Enable automatic  communication session reestablishment</h2>
                                                  <p>The SDK supports “Automatic communication session reestablishment” option. When the option is enabled the SDK will automatically establish a logical communication session with the last active RFID reader that had unexpectedly disappeared once the RFID reader will be recognized as available. If “Available readers detection” option is enabled the RFID reader will be recognized as available automatically when it becomes connected via Bluetooth. Otherwise the SDK will add the RFID reader to the list of available RFID readers only during discovery procedure requested by the application via srfidGetAvailableReadersList API. The option has no effect if the application has intentionally terminate a communication session with the active RFID reader via srfidTerminateCommunicationSession API function. The “Automatic communication session reestablishment” option is configured via srfidEnableAutomaticSessionReestablishment API function</p>
                                                  
                                                 
<pre class="prettyprint">
<code>
[-(void)getReaderInformation {
    /* identifier of one of active RFID readers is supposed to be stored in m_ReaderId variable */

    /* allocate object for storage of version related information */
    srfidReaderVersionInfo *version_info = [[srfidReaderVersionInfo alloc] init];

	/* retrieve version related information */
	SRFID_RESULT result = [_apiInstance srfidGetReaderVersionInfo:_connectedRederID aReaderVersionInfo:&version_info aStatusMessage:&error_response];

 	if ((result != SRFID_RESULT_RESPONSE_TIMEOUT) && (result != SRFID_RESULT_FAILURE))
	 	{
		  NSLog(@"Time out or Failure");
			}
		 if (SRFID_RESULT_SUCCESS == result) {
			 /* print the received version related information */
		 	NSLog(@"Device version: %@\n", [version_info getDeviceVersion]);
			NSLog(@"NGE version: %@\n", [version_info getNGEVersion]);
			NSLog(@"Bluetooth version: %@\n", [version_info getBluetoothVersion]);
			textView_reader_information.text = [NSString stringWithFormat:@"Firmware version: %@\n NGE version: %@\n Bluetooth version: %@\n", [version_info getDeviceVersion], [version_info getNGEVersion], [version_info getBluetoothVersion]];
	   	}
		if (SRFID_RESULT_READER_NOT_AVAILABLE == result) {

			NSLog(@"RFID reader is not available\n");
			textView_reader_information.text = @"RFID readernot available";
		 }
		}

 </code></pre>
		
		
<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#Knowing the Reader related Information"><span></span></a>Knowing the Reader related Information					</h2>	
<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#Knowing the Software Version"><span></span></a>Knowing the Software Version </h2>
										 
  <p align="justify">The SDK provides an ability to retrieve information about software versions of various components of a particular active RFID reader. Software version related information could be retrieved via srfidGetReaderVersionInfo API function as demonstrated in the following example.  </p	
														
<pre class="prettyprint">
<code>
 [apiInstance srfidEnableAutomaticSessionReestablishment:YES];
  -(void)getReaderInformation {
	/* identifier of one of active RFID readers is supposed to be stored in m_ReaderId variable */
	/* allocate object for storage of version related information */
   srfidReaderVersionInfo *version_info = [[srfidReaderVersionInfo alloc] init];
   /* an object for storage of error response received from RFID reader */
	NSString *error_response = nil;
	/* retrieve version related information */
	SRFID_RESULT result = [_apiInstance srfidGetReaderVersionInfo:_connectedRederID aReaderVersionInfo:&version_info aStatusMessage:&error_response];

    if ((result != SRFID_RESULT_RESPONSE_TIMEOUT) && (result != SRFID_RESULT_FAILURE)) {
        NSLog(@"Time out or Failure");
    }
    if (SRFID_RESULT_SUCCESS == result) {
        /* print the received version related information */
        NSLog(@"Device version: %@\n", [version_info getDeviceVersion]);
        NSLog(@"NGE version: %@\n", [version_info getNGEVersion]);
        NSLog(@"Bluetooth version: %@\n", [version_info getBluetoothVersion]);
        textView_reader_information.text = [NSString stringWithFormat:@"Firmware version: %@\n NGE version: %@\n Bluetooth version: %@\n", [version_info getDeviceVersion], [version_info getNGEVersion], [version_info getBluetoothVersion]];
    }
    if (SRFID_RESULT_READER_NOT_AVAILABLE == result) {
        NSLog(@"RFID reader is not available\n");
        textView_reader_information.text = @"RFID readernot available";
    }
}
</code>
</pre>
														
														
														
		
		
													<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#Knowing the Reader related Information"><span></span></a>
													Knowing the Reader Capabilities</h2>
													<p>The SDK provides an ability to retrieve the capabilities (or read-only properties) of a particular active RFID reader. The reader capabilities include the following:</p>
													<ul>
													  <li>Serial number</li>
													  <li>Model name</li>
													  <li>Manufacturer</li>
													  <li>Manufacturing date													  </li>
													  <li>Device name</li>
													  <li>ASCII protocol version</li>
													  <li>Number of select records (pre-filters)</li>
													  <li>Minimal and maximal antenna power levels (in 0.1 dbm  units)</li>
													  <li>Step for configuration of antenna power level (in 0.1 dbm  units)													  </li>
													  <li>Version of air protocol													  </li>
													  <li>Bluetooth address</li>
													  <li>Maximal number of operations to be combined in a  sequence</li>
												  </ul>
												  <p>The reader capabilities could be retrieved via srfidGetReaderCapabilitiesInfo API function as demonstrated in the following example</p>
													
<pre class="prettyprint"><code>
-(void)getReaderCapabilities {
    /* allocate object for storage of capabilities information */
    srfidReaderCapabilitiesInfo *capabilities = [[srfidReaderCapabilitiesInfo alloc] init];

    /* an object for storage of error response received from RFID reader */
    NSString *error_response = nil;

    /* retrieve capabilities information */
    SRFID_RESULT srfid_result = SRFID_RESULT_FAILURE;
    srfid_result = [_apiInstance srfidGetReaderCapabilitiesInfo:_connectedRederID aReaderCapabilitiesInfo:&capabilities aStatusMessage:&error_response];

    if ((srfid_result != SRFID_RESULT_RESPONSE_TIMEOUT) && (srfid_result != SRFID_RESULT_FAILURE))
    {
        NSLog(@"Time out or Failure");
    }

    if (srfid_result == SRFID_RESULT_SUCCESS)
    {
        NSLog(@"Serial number: %@\n", [capabilities getSerialNumber]);
        NSLog(@"Model: %@\n", [capabilities getModel]);
        NSLog(@"Manufacturer: %@\n", [capabilities getManufacturer]);
        NSLog(@"Manufacturing date: %@\n", [capabilities getManufacturingDate]);
        NSLog(@"Scanner name: %@\n", [capabilities getScannerName]);
        NSLog(@"Ascii version: %@\n", [capabilities getAsciiVersion]);
        NSLog(@"Air version: %@\n", [capabilities getAirProtocolVersion]);
        NSLog(@"Bluetooth address: %@\n", [capabilities getBDAddress]);
        NSLog(@"Select filters number: %d\n", [capabilities getSelectFilterNum]);
        NSLog(@"Max access sequence: %d\n", [capabilities getMaxAccessSequence]);
        NSLog(@"Power level: min = %d; max = %d; step = %d\n", [capabilities getMinPower], [capabilities getMaxPower], [capabilities getPowerStep]);

        textView_reader_capabilities.text = [NSString stringWithFormat:@"Serial number: %@\n Model: %@\n Bluetooth address: %@\n",[capabilities getSerialNumber],[capabilities getModel],[capabilities getBDAddress]];
    }
}
</code></pre>
													
<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#Knowing Supported Regions"><span></span></a>Knowing Supported Regions</h2>
<p align="justify">The RFID reader could be configured to operate in a various countries. The SDK provides an ability to retrieve the list of regions supported by a particular active RFID reader. The list of supported regions could be retrieved via <em>srfidGetSupportedRegions</em> API function as demonstrated in the following example.</p>
	
<pre class="prettyprint"><code>
-(void)getSupportRegion {
/* allocate object for storage of region information */
NSMutableArray *regions = [[NSMutableArray alloc] init];
/* an object for storage of error response received from RFID reader */
NSString *error_response = nil;

/* retrieve supported regions */
SRFID_RESULT result = [_apiInstance srfidGetSupportedRegions:_connectedRederID aSupportedRegions:&regions aStatusMessage:&error_response];
if (SRFID_RESULT_SUCCESS == result) {
/* print supported regions information */
 NSLog(@"Number of supported regions: %lu\n", (unsigned long)[regions count]);
  for (srfidRegionInfo *info in regions)
       {
  			NSLog(@"Regions [%@] is supported: %@\n", [info getRegionName],  [info getRegionCode]);
       }
			NSString * result = [[regionsDetatilsArray valueForKey:@"description"] componentsJoinedByString:@"\n"];
    }
	    	else if (SRFID_RESULT_RESPONSE_ERROR == result) {
			  NSLog(@"Error response from RFID reader: %@\n", error_response);
     }
		   else if (SRFID_RESULT_RESPONSE_TIMEOUT == result) {
					NSLog(@"Timeout occurs during communication with RFID reader\n");
     }
		   else if (SRFID_RESULT_READER_NOT_AVAILABLE == result) {
					NSLog(@"RFID reader with id = %d is not available\n", _connectedRederID);
     }
      else {
					NSLog(@"Request failed\n");
   }
 
 }
</code></pre>
					
					<p align="justify">As the RFID reader could be configured to operate on a particular radio channels in some of countries the SDK provides an ability to retrieve the detailed information regarding one of regions supported by a particular active RFID reader. The detailed information includes a set of channel supported in the region and allowance of hopping configuration. This information could be retrieved via srfidGetRegionInfo API function as demonstrated in the following example</p>
													
<pre class="prettyprint"><code>
-(void)getSupportChannelListForGivenRegion {

/* allocate object for storage of supported channels information */
NSMutableArray *channels = [[NSMutableArray alloc] init];
BOOL hopping = NO;
/* an object for storage of error response received from RFID reader */
NSString *error_response = nil;
/* retrieve detailed information about region specified by "USA" region code */
SRFID_RESULT result = [_apiInstance srfidGetRegionInfo:_connectedRederID aRegionCode:@"AUS" aSupportedChannels:&channels aHoppingConfigurable:&hopping aStatusMessage:&error_response];

if (SRFID_RESULT_SUCCESS == result) {
/* print retrieved detailed information */
NSLog(@"Hopping configuration is: %@\n", ((YES == hopping) ? @"supported" : @"NOT supported"));
for (NSString *str_channel in channels)
	{
			NSLog(@"Supported channel: %@\n", str_channel);
	}
  	  NSString * result = [[channels valueForKey:@"description"] componentsJoinedByString:@"\n"];
	  textView_reader_support_channel.text = result;
	}
	  else if (SRFID_RESULT_RESPONSE_ERROR == result) {
	  NSLog(@"Error response from RFID reader: %@\n", error_response);
   }
	  else if (SRFID_RESULT_RESPONSE_TIMEOUT == result) {
	  NSLog(@"Timeout occurs during communication with RFID reader\n");
   }
	  else if (SRFID_RESULT_READER_NOT_AVAILABLE == result) {
	 NSLog(@"RFID reader with id = %d is not available\n", _connectedRederID);
   }
	  else {
	  NSLog(@"Request failed\n");
    }
 }
				
 </code></pre>
				<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="Knowing  Supported Link Profiles"><span></span></a>Knowing  Supported Link Profiles</a></h2>
				<p align="justify">An antenna of the RFID reader could be configured to operate in various RF modes (link profiles). The SDK provides an ability to retrieved the list of link profiles (RF modes) supported by a particular active RFID reader. The list of supported link profiles could be retrieved via <em>srfidGetSupportedLinkProfiles</em> API function as demonstrated in the following example.</p>
                <pre class="prettyprint"><code>	-(void)getSupportLinkProfile {
  
    /* allocate object for storage of link profiles information */
    NSMutableArray *profiles = [[NSMutableArray alloc] init];
    /* an object for storage of error response received from RFID reader */
    NSString *error_response = nil;
    /* retrieve supported link profiles */
    SRFID_RESULT result = [_apiInstance srfidGetSupportedLinkProfiles:_connectedRederID aLinkProfilesList:&profiles aStatusMessage:&error_response];

    if (SRFID_RESULT_SUCCESS == result) {
        /* print retrieved information about supported link profiles */
        NSLog(@"Number of supported link profiles: %lu\n", (unsigned long)[profiles count]);
        for (srfidLinkProfile *profile_info in profiles) {
            NSLog(@"RF mode index: %d\n", [profile_info getRFModeIndex]);
            NSLog(@"BDR: %d\n", [profile_info getBDR]);
            NSLog(@"PIE: %d\n", [profile_info getPIE]);
            NSLog(@"Tari: min = %d; max = %d; step = %d\n", [profile_info getMinTari], [profile_info getMaxTari], [profile_info getStepTari]);
            NSLog(@"EPCHAGT&CConformance: %@\n", ((NO == [profile_info getEPCHAGTCConformance]) ? @"NO" : @"YES"));
            NSLog(@"Divide Ratio: %@\n", [profile_info getDivideRatioString]);
            NSLog(@"FLM: %@\n", [profile_info getForwardLinkModulationString]);
            NSLog(@"M: %@\n", [profile_info getModulationString]);
            NSLog(@"Spectral Mask indicator: %@\n", [profile_info getSpectralMaskIndicatorString]);   
        }
    }
    else if (SRFID_RESULT_RESPONSE_ERROR == result) {
        NSLog(@"Error response from RFID reader: %@\n", error_response);
    }
    else if (SRFID_RESULT_RESPONSE_TIMEOUT == result) {
        NSLog(@"Timeout occurs during communication with RFID reader\n");
    }
    else if (SRFID_RESULT_READER_NOT_AVAILABLE == result) {
        NSLog(@"RFID reader with id = %d is not available\n", _connectedRederID);
    }
    else {
        NSLog(@"Request failed\n");
    }

}

    </code></pre>
                <h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#Knowing Battery Status"><span></span></a>Knowing  Battery Status</a></h2>
				<p align="justify">A particular active RFID reader could send an asynchronous notification regarding battery status. The SDK will inform the application about received asynchronous battery status event if the application has subscribed for events of this type. The SDK also provides an ability to cause a particular active RFID reader to immediately send information about current battery status. The following example demonstrates both requesting and processing of asynchronous battery status related notifications</p>
                <pre class="prettyprint"><code><br>
-(void)getBatteryStatus {
	    
/* subscribe for battery related events */
	[apiInstance srfidSubsribeForEvents:SRFID_EVENT_MASK_BATTERY];
	/* cause RFID reader to generate asynchronous battery status notification */
	SRFID_RESULT result = [apiInstance srfidRequestBatteryStatus:connectedReaderId];

	if (SRFID_RESULT_SUCCESS == result) {
 		NSLog(@"Request succeed\n");
    }
   	else {
  	   NSLog(@"Request failed\n");
     }
    
	 } 

- (void)srfidEventBatteryNotity:(int)readerID aBatteryEvent:(srfidBatteryEvent *)batteryEvent {
    
/* print the received information regarding battery status */
NSLog(@"Battery status event received from RFID reader with ID = %d\n", readerID);
NSLog(@"Battery level: %d\n", [batteryEvent getPowerLevel]);
NSLog(@"Charging: %@\n", ((NO == [batteryEvent getIsCharging]) ? @"NO" : @"YES"));
NSLog(@"Event cause: %@\n", [batteryEvent getEventCause]);
dispatch_async(dispatch_get_main_queue(),^{
self->textView_reader_battery_status.text = [NSString stringWithFormat:@"Battery level: %d ", [batteryEvent getPowerLevel]];
});
}</code></pre>
			
			<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#Configuring the Reader"><span></span></a>Configuring the Reader</a></h2>
			    
				<p align="justify">Zebra Bluetooth RFID iOS SDK API supports managing of various RFID reader parameters including:</p>
				<ul>
				  <li>Antenna parameters</li>
				  <li>Singulation parameters</li>
				  <li>Start and stop triggers parameters</li>
				  <li>Tag report parameter</li>
				  <li>Regulatory parameters</li>
				  <li>Pre-filters</li>
				  <li>Beeper </li>
				  
				  </ul>
				  
				<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#Antenna Configuration"><span></span></a>Antenna Configuration</a></h2>
				<p>Following antenna related settings could be configured via the SDK:</p>
				<ul>
				  <li>Output power level (in 0.1 dbm units)</li>
				  <li>Index of selected link profile (RF mode)</li>
				  <li>Application of pre-filters (select records)</li>
				  <li>Tari (Type-A reference interval)</li>
				 </ul>
				 <p align="justify">
				 Tari value shall be set in accordance with the selected link profile, i.e. tari value shall be in the interval between minimal and maximal tari values specified by the selected link profile. If step size is supported by the selected link profile, the tari value must be a multiple of step size. Antenna settings could be retrieved and set via srfidGetAntennaConfiguration and srfidSetAntennaConfiguration API function accordingly.
				 Following example demonstrates retrieving current antenna settings and setting of antenna configuration with minimal output power and one of supported link profiles.
				 
				 <br>
				 Following example demonstrates retrieving current antenna settings and setting of antenna configuration with minimal output power and one of supported link profiles.
				 
				 </p>
				 <pre class="prettyprint"><code><br>
-(void)getAntennaConfig {
/* allocate object for storage of antenna settings */
srfidAntennaConfiguration *antenna_cfg = [[srfidAntennaConfiguration alloc] init];

/* an object for storage of error response received from RFID reader */
	NSString *error_response = nil;
/* retrieve antenna configuration */
	SRFID_RESULT result = [_apiInstance srfidGetAntennaConfiguration:_connectedRederID aAntennaConfiguration:&antenna_cfg aStatusMessage:&error_response];

	if (SRFID_RESULT_SUCCESS == result) {
	/* antenna configuration received */
	NSLog(@"Antenna power level: %1.1f\n", [antenna_cfg getPower]/10.0);
	NSLog(@"Antenna RF mode index: %d\n", [antenna_cfg getLinkProfileIdx]);
	NSLog(@"Antenna tari: %d\n", [antenna_cfg getTari]);
	NSLog(@"Antenna pre-filters application: %@", ((NO == [antenna_cfg getDoSelect]) ? @"NO" : @"YES"));
}
	else if (SRFID_RESULT_RESPONSE_ERROR == result) {
	NSLog(@"Error response from RFID reader: %@\n", error_response);
}
	else if (SRFID_RESULT_RESPONSE_TIMEOUT == result) {
	NSLog(@"Timeout occurs during communication with RFID reader\n");
}
	else if (SRFID_RESULT_READER_NOT_AVAILABLE == result) {
	NSLog(@"RFID reader with id = %d is not available\n", _connectedRederID);
}
	else {
   NSLog(@"Request failed\n");
  }
}

-(void)setAntennaConfig {
/* allocate object for storage of antenna settings */
   srfidAntennaConfiguration *antenna_cfg = [[srfidAntennaConfiguration alloc] init];
/* an object for storage of error response received from RFID reader */
   NSString *error_response = nil;
/* RF mode index to be set */
	int link_profile_idx = 0;
/* tari to be set */
	int tari = 0;
/* 20.0 dbm power level to be set */
	int power = 200;

/* allocate object for storage of link profiles information */
	NSMutableArray *profiles = [[NSMutableArray alloc] init];
/* retrieve supported link profiles */
	SRFID_RESULT result  = [_apiInstance srfidGetSupportedLinkProfiles:_connectedRederID aLinkProfilesList:&profiles aStatusMessage:&error_response];

  if (SRFID_RESULT_SUCCESS == result) {
if (0 < [profiles count]) {
	 srfidLinkProfile *profile = (srfidLinkProfile*)[profiles lastObject];
  	 link_profile_idx = [profile getRFModeIndex];
	 tari = [profile getMaxTari];
	}
 }

/* allocate object for storage of capabilities information */
	srfidReaderCapabilitiesInfo *capabilities = [[srfidReaderCapabilitiesInfo alloc] init];

/* retrieve capabilities information */
	result = [_apiInstance srfidGetReaderCapabilitiesInfo:_connectedRederID aReaderCapabilitiesInfo:&capabilities aStatusMessage:&error_response];
	if (SRFID_RESULT_SUCCESS == result) {
 	power = [capabilities getMinPower];
 }
/* prepare an object with desired antenna parameters */
	antenna_cfg = [[srfidAntennaConfiguration alloc] init];
	[antenna_cfg setLinkProfileIdx:link_profile_idx];
	[antenna_cfg setPower:power];
   [antenna_cfg setTari:tari];
	[antenna_cfg setDoSelect:NO];
 	error_response = nil;
	/* set antenna configuration */
	result = [_apiInstance srfidSetAntennaConfiguration:_connectedRederID aAntennaConfiguration:antenna_cfg aStatusMessage:&error_response];

	if (SRFID_RESULT_SUCCESS == result) {
 /* antenna configuration applied successfully */
     NSLog(@"Antenna configuration has been set\n");
	}
	  else if (SRFID_RESULT_RESPONSE_ERROR == result) {
	  NSLog(@"Error response from RFID reader: %@\n", error_response);
	}
	  else if (SRFID_RESULT_RESPONSE_TIMEOUT == result) {
	  NSLog(@"Timeout occurs during communication with RFID reader\n");
	}
	  else if (SRFID_RESULT_READER_NOT_AVAILABLE == result) {
	  NSLog(@"RFID reader with id = %d is not available\n", _connectedRederID);
	}
	 else {
 	 NSLog(@"Request failed\n");
	}
}

				 </code></pre>
				 
				<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#Singulation Configuration"><span></span></a>Singulation Configuration</a></h2>
				<p>Following singulation control settings could be configured via the SDK:</p>
				<ul>
					<li>Session: session number to use for inventory operation</li>
					<li>Tag population: an estimate of the tag population in view of the RF field of the antenna</li>
				 	<li>Select (SL Flag)</li>
				 	<li>Target (inventory state).</li>
				 </ul>
				
				<p>Singulation control settings could be retrieved and set via accordingly<em>srfidGetSingulationConfiguration</em> and <em>srfidSetSingulationConfiguration </em> API functions as demonstrated in the following example.</p>
				
				<pre class="prettyprint"><code>
				 
-(void)getSingulationConfig {
 /* allocate object for storage of singulation settings */
	srfidSingulationConfig *singulation_cfg = [[srfidSingulationConfig alloc] init];

/* an object for storage of error response received from RFID reader */
	NSString *error_response = nil;

/* retrieve singulation configuration */
	SRFID_RESULT result = [_apiInstance srfidGetSingulationConfiguration:_connectedRederID aSingulationConfig:&singulation_cfg aStatusMessage:&error_response];
	if (SRFID_RESULT_SUCCESS == result) {
/* singulation configuration received */
	NSLog(@"Tag population: %d\n", [singulation_cfg getTagPopulation]);

	SRFID_SLFLAG slflag = [singulation_cfg getSLFlag];
	switch (slflag) {
	case SRFID_SLFLAG_ASSERTED:
	NSLog(@"SL flag: ASSERTED\n");
	break;
	case SRFID_SLFLAG_DEASSERTED:
	NSLog(@"SL flag: DEASSERTED\n");
	break;
	case SRFID_SLFLAG_ALL:
	NSLog(@"SL flag: ALL\n");
		break;
	}

	SRFID_SESSION session = [singulation_cfg getSession];
	switch (session) {
		case SRFID_SESSION_S1:
		NSLog(@"Session: S1\n");
		break;
		case SRFID_SESSION_S2:
		NSLog(@"Session: S2\n");
		break;
		case SRFID_SESSION_S3:
		NSLog(@"Session: S3\n");
		break;
		case SRFID_SESSION_S0:
		NSLog(@"Session: S0\n");
		break;
 }

	SRFID_INVENTORYSTATE state = [singulation_cfg getInventoryState];
	switch (state) {
	case SRFID_INVENTORYSTATE_A:
	NSLog(@"Inventory State: State A\n");
	break;
	case SRFID_INVENTORYSTATE_B:
		NSLog(@"Inventory State: State B\n");
		break;
	case SRFID_INVENTORYSTATE_AB_FLIP:
		NSLog(@"Inventory State: AB flip\n");
		break;
		}
	   }
	}
	-(void)setSingulationConfig {
/* allocate object for storage of singulation settings */
	srfidSingulationConfig *singulation_cfg = [[srfidSingulationConfig alloc] init];
/* an object for storage of error response received from RFID reader */
	NSString *error_response = nil;
/* change the received singulation configuration */
	[singulation_cfg setTagPopulation:30];
	[singulation_cfg setSession:SRFID_SESSION_S0];
	[singulation_cfg setSlFlag:SRFID_SLFLAG_ASSERTED];
	[singulation_cfg setInventoryState:SRFID_INVENTORYSTATE_A];
	error_response = nil;
	/* set updated singulation configuration */
	SRFID_RESULT result = [_apiInstance srfidSetSingulationConfiguration:_connectedRederID aSingulationConfig:singulation_cfg aStatusMessage:&error_response];
	if (SRFID_RESULT_SUCCESS == result) {
	/* singulation configuration applied successfully */
	NSLog(@"Singulation configuration has been set\n");
	}
  	 else if (SRFID_RESULT_RESPONSE_ERROR == result) {
	  NSLog(@"Error response from RFID reader: %@\n", error_response);
	}
	  else if (SRFID_RESULT_RESPONSE_TIMEOUT == result) {
     NSLog(@"Timeout occurs during communication with RFID reader\n");
	}
	  else if (SRFID_RESULT_READER_NOT_AVAILABLE == result) {
	  NSLog(@"RFID reader with id = %d is not available\n", _connectedRederID);
	}
	  else {
	  NSLog(@"Request failed\n");
	 }
}
				</code></pre>
				
				<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#Trigger Configuration"><span></span></a>Trigger Configuration</a></h2>
				
				
				<p align="justify">The SDK provides an ability to configure start and stop trigger parameters. Start trigger parameters include the following:</p>
				
				<ul>
				  <li>Start of an operation based on a physical trigger</li>
				  <li>Trigger type (press/release) of a physical trigger</li>
				  <li>Delay (in milliseconds) of start of operation</li>
				  <li>Repeat monitoring for start trigger after stop of operation.</li>		  
				</ul>
				
				<p align="justify">Start trigger configuration could be retrieved and set via s<em>rfidGetStartTriggerConfiguration</em> and <em>srfidSetStartTriggerConfiguration</em> API functions accordingly.</p>
				<p align="justify">Stop trigger parameters include the following:</p>
				
				<ul>
				<li>Stop of an operation based on a physical trigger</li>
				<li>Trigger type (press/release) of a physical trigger</li>
				<li> Stop of an operation based on a specified number of tags inventoried</li>
				<li> Stop of an operation based on a specified timeout (in milliseconds)</li>
				<li> Stop of an operation based on a specified number of inventory rounds completed				  </li>
				<li> Stop of an operation based on a specified number of access rounds completed.</li>
				</ul>
				
				<p align="justify">Stop trigger settings could be retrieved and set via accordingly <em>srfidGetStopTriggerConfiguration</em> and <em>srfidSetStopTriggerConfiguration</em> API functions.</p>
				
				<p align="justify">The following example demonstrates retrieval of current start and stop trigger parameters as well as configuring new start and stop triggers parameters.</p>
								
				<pre class="prettyprint"><code>-(void)getStartTrigger{
/* allocate object for storage of start trigger settings */
	srfidStartTriggerConfig *start_trigger_cfg = [[srfidStartTriggerConfig alloc] init];
/* an object for storage of error response received from RFID reader */
	NSString *error_response = nil;
/* retrieve start trigger parameters */
	SRFID_RESULT result = [_apiInstance srfidGetStartTriggerConfiguration:_connectedRederID aStartTriggeConfig:&start_trigger_cfg aStatusMessage:&error_response];

	if (SRFID_RESULT_SUCCESS == result) {
/* start trigger configuration received */
  	NSLog(@"Start trigger: start on physical trigger = %@\n", ((YES == [start_trigger_cfg getStartOnHandheldTrigger]) ? @"YES" : @"NO"));
	NSLog(@"Start trigger: physical trigger type = %@\n", ((SRFID_TRIGGERTYPE_PRESS == [start_trigger_cfg getTriggerType]) ? @"PRESSED" : @"RELEASED"));
	NSLog(@"Start trigger: delay = %d ms\n", [start_trigger_cfg getStartDelay]);
	NSLog(@"Start trigger: repeat monitoring = %@\n", ((NO == [start_trigger_cfg getRepeatMonitoring]) ? @"NO" : @"YES"));
	}
    else {
	NSLog(@"Failed to receive start trigger parameters\n");
	 }
  }

	-(void)getStoptTrigger {
	//stop
	NSString *error_response = nil;
/* allocate object for storage of start trigger settings */
	srfidStopTriggerConfig *stop_trigger_cfg = [[srfidStopTriggerConfig alloc] init];
/* retrieve stop trigger parameters */
	SRFID_RESULT result = [_apiInstance srfidGetStopTriggerConfiguration:_connectedRederID aStopTriggeConfig:&stop_trigger_cfg aStatusMessage:&error_response];

if (SRFID_RESULT_SUCCESS == result) {
/* stop trigger configuration received */
	NSLog(@"Stop trigger: start on physical trigger = %@\n", ((YES == [stop_trigger_cfg getStopOnHandheldTrigger]) ? @"YES" : @"NO"));
	NSLog(@"Stop trigger: physical trigger type = %@\n", ((SRFID_TRIGGERTYPE_PRESS == [stop_trigger_cfg getTriggerType]) ? @"PRESSED" : @"RELEASED"));
   if (YES == [stop_trigger_cfg getStopOnTagCount]) {
		NSLog(@"Stop trigger: stop on %d number of tags received\n", [stop_trigger_cfg getStopTagCount]);
	 }
	if (YES == [stop_trigger_cfg getStopOnTimeout]) {
		NSLog(@"Stop trigger: stop on %d ms timeout\n", [stop_trigger_cfg getStopTimeout]);
	}
	if (YES == [stop_trigger_cfg getStopOnInventoryCount]) {
		NSLog(@"Stop trigger: stop on %d inventory rounds\n", [stop_trigger_cfg getStopInventoryCount]);
	}
	 if (YES == [stop_trigger_cfg getStopOnAccessCount]) {
		NSLog(@"Stop trigger: stop on %d access rounds\n", [stop_trigger_cfg getStopAccessCount]);
	}
	  }
		else {
		NSLog(@"Failed to receive stop trigger parameters\n");
	 }
  }

-(void)setStopTrigger {
/* allocate object for storage of start trigger settings */
	srfidStopTriggerConfig *stop_trigger_cfg = [[srfidStopTriggerConfig alloc] init];
/* an object for storage of error response received from RFID reader */
	NSString *error_response = nil;
/* start on physical trigger */
	[stop_trigger_cfg setStopOnHandheldTrigger:YES];
	[stop_trigger_cfg setTriggerType:SRFID_TRIGGERTYPE_RELEASE];
	[stop_trigger_cfg setStopOnTimeout:YES];
   [stop_trigger_cfg setStopTimout:(5*1000)];
	[stop_trigger_cfg setStopOnTagCount:YES];
	[stop_trigger_cfg setStopTagCount:10];
	[stop_trigger_cfg setStopOnInventoryCount:NO];
	[stop_trigger_cfg setStopOnAccessCount:NO];

/* set stop trigger parameters */
	SRFID_RESULT result = [_apiInstance srfidSetStopTriggerConfiguration:_connectedRederID aStopTriggeConfig:stop_trigger_cfg aStatusMessage:&error_response];
	if (SRFID_RESULT_SUCCESS == result) {
/* stop trigger configuration applied */
	NSLog(@"Stop trigger configuration has been set\n");
	}
  	  else {
	  NSLog(@"Failed to set stop trigger parameters\n");
	 }
	}

	-(void)setStartTrigger {

/* allocate object for storage of start trigger settings */
	srfidStartTriggerConfig *start_trigger_cfg = [[srfidStartTriggerConfig alloc] init];
/* an object for storage of error response received from RFID reader */
	NSString *error_response = nil;
/* configure start trigger parameters */
/* start on physical trigger */
	[start_trigger_cfg setStartOnHandheldTrigger:YES];
/* start on physical trigger press */
	[start_trigger_cfg setTriggerType:SRFID_TRIGGERTYPE_PRESS];
/* repeat monitoring for start trigger conditions after operation stop */
	[start_trigger_cfg setRepeatMonitoring:YES];
	[start_trigger_cfg setStartDelay:0];
/* set start trigger parameters */
	SRFID_RESULT result = [_apiInstance srfidSetStartTriggerConfiguration:_connectedRederID aStartTriggeConfig:start_trigger_cfg aStatusMessage:&error_response];
	if (SRFID_RESULT_SUCCESS == result) {
/* start trigger configuration applied */
 	NSLog(@"Start trigger configuration has been set\n");
  }
	else {
	NSLog(@"Failed to set start trigger parameters\n");
  }
}

				</code>
				</pre>
				
				<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#Tag Report Configuration"><span></span></a>Tag Report Configuration</a></h2>
				
				<p align="justify">The SDK provides an ability to configure a set of fields to be reported in a response to an operation by a particular active RFID reader. Supported fields that might be reported include the following:</p>
				
				<ul>
				 <li>First and last seen times</li>
				 <li>PC value</li>
				 <li>RSSI value</li>
				 <li>Phase value</li>
				 <li>Channel index</li>
				 <li>Tag seen count</li>
				 </ul>
				
				<p align="justify">Tag report parameters could be managed via <em>srfidSetReportConfiguration</em> and <em>srfidGetReportConfiguration</em> API functions as demonstrated in the following example.</p>
				
			
				    <pre class="prettyprint"><code>
-(void)getTagReportConfig {
/* allocate object for storage of tag report settings */
	srfidTagReportConfig *report_cfg = [[srfidTagReportConfig alloc] init];
/* an object for storage of error response received from RFID reader */
	NSString *error_response = nil;
/* retrieve tag report parameters */
	SRFID_RESULT result = [_apiInstance srfidGetTagReportConfiguration:_connectedRederID aTagReportConfig:&report_cfg aStatusMessage:&error_response];
	if (SRFID_RESULT_SUCCESS == result) {
/* tag report configuration received */
	NSLog(@"PC field: %@\n", ((NO == [report_cfg getIncPC]) ? @"off" : @"on"));
	NSLog(@"Phase field: %@\n", ((NO == [report_cfg getIncPhase]) ? @"off" : @"on"));
	NSLog(@"Channel index field: %@\n", ((NO == [report_cfg getIncChannelIdx]) ? @"off" : @"on"));
	NSLog(@"RSSI field: %@\n", ((NO == [report_cfg getIncRSSI]) ? @"off" : @"on"));
	NSLog(@"Tag seen count field: %@\n", ((NO == [report_cfg getIncTagSeenCount]) ? @"off" : @"on"));
	NSLog(@"First seen time field: %@\n", ((NO == [report_cfg getIncFirstSeenTime]) ? @"off" : @"on"));
	NSLog(@"Last seen time field: %@\n", ((NO == [report_cfg getIncLastSeenTime]) ? @"off" : @"on"));
}
	else {
	NSLog(@"Failed to receive tag report parameters\n");
}
	}
	-(void)setTagReportConfig {
/* allocate object for storage of tag report settings */
	srfidTagReportConfig *report_cfg = [[srfidTagReportConfig alloc] init];
/* an object for storage of error response received from RFID reader */
	NSString *error_response = nil;
/* configure tag report parameters to include only RSSI field */
	[report_cfg setIncRSSI:YES];
	[report_cfg setIncPC:NO];
	[report_cfg setIncPhase:NO];
	[report_cfg setIncChannelIdx:NO];
	[report_cfg setIncTagSeenCount:NO];
	[report_cfg setIncFirstSeenTime:NO];
	[report_cfg setIncLastSeenTime:NO];

/* set tag report parameters */
	SRFID_RESULT result = [_apiInstance srfidSetTagReportConfiguration:_connectedRederID aTagReportConfig:report_cfg aStatusMessage:&error_response];
	if (SRFID_RESULT_SUCCESS == result) {
/* tag report configuration applied */
	NSLog(@"Tag report configuration has been set\n");
}
	else {
	NSLog(@"Failed to set tag report parameters\n");
  }
}
	
			</code></pre>
				  
		
		<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#Regulatory Configuration"><span></span></a>Regulatory Configuration</a></h2>
		
		<p align="justify">The SDK supports managing of regulatory related parameters of a particular active RFID reader. Regulatory configuration includes the following:</p>
		<ul>
			<li>Code of selected region</li>
			<li>Hopping </li>
			<li>Set of enabled channels</li>
			
		</ul>
		
		<p align="justify">
		A set of enabled channels shall include only such channels that are supported in the selected region. If hopping configuration is not allowed for the selected regions a set of enabled channels shall not be specified. <br><br>
		Regulatory parameters could be retrieved and set via <em>srfidGetRegulatoryConfig</em> and <em>srfidSetRegulatoryConfig</em> API functions accordingly. The following example demonstrates retrieving of current regulatory settings and configuring the RFID reader to operate in one of supported regions. </p>
		
		<pre class="prettyprint"><code>
-(void)getSetRegulatoryConfig{

/* allocate object for storage of regulatory settings */
	srfidRegulatoryConfig *regulatory_cfg = [[srfidRegulatoryConfig alloc] init];

/* an object for storage of error response received from RFID reader */
	NSString *error_response = nil;

/* retrieve regulatory parameters */
	SRFID_RESULT result = [_apiInstance srfidGetRegulatoryConfig:_connectedRederID aRegulatoryConfig:&regulatory_cfg aStatusMessage:&error_response];
	if (SRFID_RESULT_SUCCESS == result) {
/* regulatory configuration received */
	if (NSOrderedSame == [[regulatory_cfg getRegionCode] caseInsensitiveCompare:@"NA"]) {
		NSLog(@"Regulatory: region is NOT set\n");
    }
		else {
  	    NSLog(@"Region code: %@\n", [regulatory_cfg getRegionCode]);
	    SRFID_HOPPINGCONFIG hopping_cfg = [regulatory_cfg getHoppingConfig];
	    NSLog(@"Hopping is %@\n", ((SRFID_HOPPINGCONFIG_DISABLED == hopping_cfg) ? @"off" : @"on"));
		NSArray *channels = [regulatory_cfg getEnabledChannelsList];
		for (NSString *str in channels) {
		NSLog(@"Enabled channel: %@\n", str);
	  }
	}
}
	else {
  		NSLog(@"Failed to receive regulatory parameters\n");
	 }
/* code of region to be set as current one */
	NSString *region_code = @"USA";
/* an array of enabled channels to be set */
	NSMutableArray *enabled_channels = [[NSMutableArray alloc] init];
/* a hopping to be set  */
	SRFID_HOPPINGCONFIG hopping_on = SRFID_HOPPINGCONFIG_DISABLED;

/* allocate object for storage of region information */
	NSMutableArray *regions = [[NSMutableArray alloc] init];

/* retrieve supported regions */
	result = [_apiInstance srfidGetSupportedRegions:_connectedRederID aSupportedRegions:&regions aStatusMessage:&error_response];

	if (SRFID_RESULT_SUCCESS == result) {
/* supported regions information received */
/* select the last supported regions to be set as current one */
	region_code = [NSString stringWithFormat:@"%@", [(srfidRegionInfo*)[regions lastObject] getRegionCode]];
}

	/* allocate object for storage of supported channels information */
	NSMutableArray *supported_channels = [[NSMutableArray alloc] init];
	BOOL hopping_configurable = NO;

/* retrieve detailed information about region specified by region code */
	result = [_apiInstance srfidGetRegionInfo:_connectedRederID aRegionCode:region_code aSupportedChannels:&supported_channels aHoppingConfigurable:&hopping_configurable aStatusMessage:&error_response];

	if (SRFID_RESULT_SUCCESS == result) {
/* region information received */
	if (YES == hopping_configurable) {
/* region supports hopping */
/* enable first and last channels from the set of supported channels */
	[enabled_channels addObject:[supported_channels firstObject]];
	[enabled_channels addObject:[supported_channels lastObject]];
/* enable hopping */
	hopping_on = SRFID_HOPPINGCONFIG_ENABLED;
}
	else {
/* region does not support hopping */
/* request to not configure hopping */
	hopping_on = SRFID_HOPPINGCONFIG_DEFAULT;
     }
	}
	error_response = nil;
	/* configure regulatory parameters to be set */
	regulatory_cfg = [[srfidRegulatoryConfig alloc] init];
	[regulatory_cfg setRegionCode:region_code];
	[regulatory_cfg setEnabledChannelsList:enabled_channels];
	[regulatory_cfg setHoppingConfig:hopping_on];

/* set regulatory parameters */
	result = [_apiInstance srfidSetRegulatoryConfig:_connectedRederID aRegulatoryConfig:regulatory_cfg aStatusMessage:&error_response];
	if (SRFID_RESULT_SUCCESS == result) {
/* regulatory configuration applied */
	NSLog(@"Tag report configuration has been set\n");
 }
	else if (SRFID_RESULT_RESPONSE_ERROR == result) {
 	NSLog(@"Error response from RFID reader: %@\n", error_response);
 }
	else {
		NSLog(@"Failed to set regulatory parameters\n");
 }
}

		</code></pre>
		
		<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#Pre-filters Configuration"><span></span></a>Pre-filters Configuration</a></h2>
		
		<p align="justify">Pre-filters are same as the select command of C1G2 specification. The SDK supports pre-filters configuration of a particular active RFID reader. When pre-filters are configured, they could be applied prior to inventory operations.</p>
														
		<p align="justify">Following parameters could be configured for each pre-filter:</p>											
														
		<ul>
			<li>Target (Session S0, Session S1, Session S2, Session S3, Select Flag)</li>
			<li>Action</li>
			<li>Memory bank (epc, tid, user)</li>
			<li>Mask start position (in words): indicates start  position from beginning of memory bank from were match pattern is checked</li>
			<li>Match pattern</li>
		</ul>														
														
   		<p align="justify">Configured pre-filters could be retrieved from a particular active RFID reader via srfidGetPreFilters API function. The srfidSetPreFilters API function is used to configure a new set of pre-filters. The following example demonstrates pre-filters management supported by the SDK.</p>														
														
														
		<blockquote>
		  <blockquote>
		    <blockquote>
		      <pre class="prettyprint"><code>
		
-(void)getSetPrefilterConfig{
    /* allocate object for storage of pre filters */
    NSMutableArray *prefilters = [[NSMutableArray alloc] init];
    /* an object for storage of error response received from RFID reader */
    NSString *error_response = nil;
    /* retrieve pre-filters */
    SRFID_RESULT result = [_apiInstance srfidGetPreFilters:_connectedRederID aPreFilters:&prefilters aStatusMessage:&error_response];
    if (SRFID_RESULT_SUCCESS == result) {
        /* pre-filters received */
        NSLog(@"Number of pre-filters: %lu\n", (unsigned long)[prefilters count]);
        
        for (srfidPreFilter *filter in prefilters) {
            NSLog(@"Match pattern: %@\n", [filter getMatchPattern]);
            NSLog(@"Mask start position: %d words\n", [filter getMaskStartPos]);
            
            SRFID_SELECTACTION action = [filter getAction];
            switch (action) {
                case SRFID_SELECTACTION_INV_A2BB2A_NOT_INV_A__OR__NEG_SL_NOT_ASRT_SL:
                    NSLog(@"Action: INV A2BB2A NOT INV A OR NEG SL NOT ASRT SL\n");
                    break;
                case SRFID_SELECTACTION_INV_A__OR__ASRT_SL:
                    NSLog(@"Action: INV A OR ASRT SL\n");
                    break;
                case SRFID_SELECTACTION_INV_A_NOT_INV_B__OR__ASRT_SL_NOT_DSRT_SL:
                    NSLog(@"Action: INV A NOT INV B OR ASRT SL NOT DSRT SL\n");
                    break;
                case SRFID_SELECTACTION_INV_B__OR__DSRT_SL:
                    NSLog(@"Action: INV B OR DSRT SL\n");
                    break;
                case SRFID_SELECTACTION_INV_B_NOT_INV_A__OR__DSRT_SL_NOT_ASRT_SL:
                    NSLog(@"Action: INV B NOT INV A OR DSRT SL NOT ASRT SL\n");
                    break;
                case SRFID_SELECTACTION_NOT_INV_A2BB2A__OR__NOT_NEG_SL:
                    NSLog(@"Action: NOT INV A2BB2A OR NOT NEG SL\n");
                    break;
                case SRFID_SELECTACTION_NOT_INV_A__OR__NOT_ASRT_SL:
                    NSLog(@"Action: NOT INV A OR NOT ASRT SL\n");
                    break;
                case SRFID_SELECTACTION_NOT_INV_B__OR__NOT_DSRT_SL:
                    NSLog(@"Action: NOT INV B OR NOT DSRT SL\n");
                    break;
            }
            
            SRFID_SELECTTARGET target = [filter getTarget];
            switch (target) {
                case SRFID_SELECTTARGET_S0:
                    NSLog(@"Target: Session SO\n");
                    break;
                case SRFID_SELECTTARGET_S1:
                    NSLog(@"Target: Session S1\n");
                    break;
                case SRFID_SELECTTARGET_S2:
                    NSLog(@"Target: Session S2\n");
                    break;
                case SRFID_SELECTTARGET_S3:
                    NSLog(@"Target: Session S3\n");
                    break;
                case SRFID_SELECTTARGET_SL:
                    NSLog(@"Target: Select Flag\n");
                    break;
            }
            
            SRFID_MEMORYBANK bank = [filter getMemoryBank];
            switch (bank) {
                case SRFID_MEMORYBANK_EPC:
                    NSLog(@"Memory Bank: EPC\n");
                    break;
                case SRFID_MEMORYBANK_RESV:
                    NSLog(@"Memory Bank: RESV\n");
                    break;
                case SRFID_MEMORYBANK_TID:
                    NSLog(@"Memory Bank: TID\n");
                    break;
                case SRFID_MEMORYBANK_USER:
                    NSLog(@"Memory Bank: USER\n");
                    break;
                case SRFID_MEMORYBANK_NONE:
                    NSLog(@"MEMORY BANK NONE\n");
                    break;
                case SRFID_MEMORYBANK_ACCESS:
                    NSLog(@"MEMORY BANK ACCESS\n");
                    break;
                case SRFID_MEMORYBANK_KILL:
                    NSLog(@"MEMORY BANK KILL\n");
                    break;
                case SRFID_MEMORYBANK_ALL:
                    NSLog(@"MEMORY BANK ALL\n");
                    break;
            }
        }
    }
    else {
        NSLog(@"Failed to receive pre-filters\n");
    }
    [prefilters removeAllObjects];

    /* create one pre-filter */
    srfidPreFilter *filter = [[srfidPreFilter alloc] init];
    [filter setMatchPattern:@"N20122014R1010364989126V"];
    [filter setMaskStartPos:2];
    [filter setMemoryBank:SRFID_MEMORYBANK_EPC];
    [filter setAction:SRFID_SELECTACTION_INV_A__OR__ASRT_SL];
    [filter setTarget:SRFID_SELECTTARGET_SL];

    [prefilters addObject:filter];
    error_response = nil;
    
    /* set pre-filters */
    result = [_apiInstance srfidSetPreFilters:_connectedRederID aPreFilters:prefilters aStatusMessage:&error_response];
    if (SRFID_RESULT_SUCCESS == result) {
        /* pre-filters have been set */
        NSLog(@"Pre-filters has been set\n");
    }
    else if (SRFID_RESULT_RESPONSE_ERROR == result) {
        NSLog(@"Error response from RFID reader: %@\n", error_response);
    }
    else {
        NSLog(@"Failed to set tag report parameters\n");
    }
}
		
		</code></pre>
				
	<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#pair-by-scan"><span></span></a>Beeper Configuration</a></h2>
	<p align="justify">The SDK provides an ability to configure a beeper of a particular active RFID reader. The beeper could be configured to one of predefined volumes (low, medium, high) or be disabled. Retrieving and setting of beeper configuration is performed via srfidSetBeeperConfig and srfidGetBeeperConfig API functions as demonstrated in the following example.</p>
			  
	<pre class="prettyprint"><code><br>
	-(void)getSetBeeperConfig{
    /* object for beeper configuration */
    SRFID_BEEPERCONFIG beeper_cfg;

    /* an object for storage of error response received from RFID reader */
    NSString *error_response = nil;

    /* retrieve beeper configuration */
    SRFID_RESULT result = [_apiInstance srfidGetBeeperConfig:_connectedRederID aBeeperConfig:&beeper_cfg aStatusMessage:&error_response];
    if (SRFID_RESULT_SUCCESS == result) {
        /* beeper configuration received */
        switch (beeper_cfg) {
            case SRFID_BEEPERCONFIG_HIGH:
                NSLog(@"Beeper: high volume\n");
                break;
            case SRFID_BEEPERCONFIG_LOW:
                NSLog(@"Beeper: low volume\n");
                break;
            case SRFID_BEEPERCONFIG_MEDIUM:
                NSLog(@"Beeper: medium volume\n");
                break;`	
            case SRFID_BEEPERCONFIG_QUIET:
                NSLog(@"Beeper: disabled\n");
                break;
        }
    }
    else {
        NSLog(@"Failed to receive beeper parameters\n");
    }
    error_response = nil;

    /* disable beeper */
    result = [_apiInstance srfidSetBeeperConfig:_connectedRederID aBeeperConfig:SRFID_BEEPERCONFIG_QUIET aStatusMessage:&error_response];
    if (SRFID_RESULT_SUCCESS == result) {
        /* beeper configuration applied */
        NSLog(@"Beeper configuration has been set\n");
    }
    else if (SRFID_RESULT_RESPONSE_ERROR == result) {
        NSLog(@"Error response from RFID reader: %@\n", error_response);
    }
    else {
        NSLog(@"Failed to set beeper configuration\n");
    }
}
</code></pre>	
			  <h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#pair-by-scan"><span></span></a>Managing Configuration</a></h2>
									
				
			
			  <p align="justify">
				  Various parameter of a particular RFID reader configured via SDK are lost after next power down. The SDK provides an ability to store and restore a persistent configuration of RFID reader. The srfidSaveReaderConfiguration API function could be used to either make current configuration persistent over power down and power up cycles or store current configuration to custom defaults area. The configuration stored to custom defaults area could be restored via srfidRestoreReaderConfiguration API function. The same API function is used to restore the factory defined configuration. The following example demonstrates utilization of mentioned API functions
			
			</p>
			
			  <blockquote>
			    <blockquote>
			      <pre class="prettyprint"><code>
	-(void)saveReaderCurrentConfigurationPersistent {
    /* an object for storage of error response received from RFID reader */
    NSString *error_response = nil;
        
    /* cause the RFID reader to make current configuration persistent */
    SRFID_RESULT result = [_apiInstance srfidSaveReaderConfiguration:_connectedRederID aSaveCustomDefaults:NO aStatusMessage:&error_response];
    if (SRFID_RESULT_SUCCESS == result) {
        NSLog(@"Current configuration became persistent\n");
    }
    else {
        NSLog(@"Request failed\n");
    }
}


-(void)saveReaderCurrentConfigurationWithCustomDefaults {
    /* an object for storage of error response received from RFID reader */
    NSString *error_response = nil;
    /* cause the RFID reader to save current configuration in custom defaults area */
    SRFID_RESULT result = [_apiInstance srfidSaveReaderConfiguration:_connectedRederID aSaveCustomDefaults:YES aStatusMessage:&error_response];
    if (SRFID_RESULT_SUCCESS == result) {
        NSLog(@"Current configuration stored in custom defaults\n");
    }
    else {
        NSLog(@"Request failed\n");
    }
}

-(void)restoreReaderConfigurationFromCustomDefaults {
    
    /* an object for storage of error response received from RFID reader */
    NSString *error_response = nil;
    /* cause the RFID reader to restore configuration from custom defaults */
    SRFID_RESULT result = [_apiInstance srfidRestoreReaderConfiguration:_connectedRederID aRestoreFactoryDefaults:NO aStatusMessage:&error_response];
    if (SRFID_RESULT_SUCCESS == result) {
        NSLog(@"Request Success\n");
    }   
}

-(void)restoreReaderConfigurationWithFactoryDefinedConfiguration {
    
    /* an object for storage of error response received from RFID reader */
    NSString *error_response = nil;
    /* cause the RFID reader to restore factory defined configuration*/
    SRFID_RESULT result = [_apiInstance srfidRestoreReaderConfiguration:_connectedRederID aRestoreFactoryDefaults:YES aStatusMessage:&error_response];
    if (SRFID_RESULT_SUCCESS == result) {
        NSLog(@"Request Success\n");
    }
    
}
</code></pre>
				
					
			    
  <h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#pair-by-scan"><span></span></a>Performing Operations </a></h2>		
  <p align="justify">Zebra Bluetooth RFID iOS SDK API enables performing various radio operations with a particular active RFID reader.</p>	
		
  <h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#pair-by-scan"><span></span></a>Rapid Read</a></h2>				  
			
  <p align="justify">Rapid read operation is a simple inventory operation without performing a read from a particular memory bank.</p>
  <p align="justify"> The srfidStartRapidRead API function is used to request performing of rapid read operation. Aborting of rapid read operation is requested via srfidStopRapidRead API function. When performing of rapid read operation is requested the actual operation will be started once conditions specified by start trigger parameters are met. The on-going operation will be stopped in accordance with configured stop trigger parameters. If repeat monitoring option is enabled in start trigger configuration the actual operation will be started again after it has stopped once conditions of start trigger configuration are met. On starting and stopping of the actual operation the SDK will deliver asynchronous notifications to the application if the application has subscribed for events of this type.</p>
		
  <p align="justify">The SDK will deliver asynchronous notifications to inform the application about tag data received from the RFID reader during the on-going operation if the application has subscribed for events of this type. Fields to be reported during asynchronous tag data related notification are configured via reportConfig parameter of srfidStartRapidRead API function.</p>
			
  <p align="justify">The following example demonstrates performing of rapid read operation that starts and stops immediately after requested operation performing and aborting`.</p>
		
 <pre class="prettyprint"><code>
 -(void)startStopRapidRead{
    
    /* subscribe for tag data related events */
    [apiInstance srfidSubsribeForEvents:SRFID_EVENT_MASK_READ];
    /* subscribe for operation start/stop related events */
    [apiInstance srfidSubsribeForEvents:SRFID_EVENT_MASK_STATUS];
    
    /* allocate object for start trigger settings */
    srfidStartTriggerConfig *start_trigger_cfg = [[srfidStartTriggerConfig alloc] init];
    /* allocate object for stop trigger settings */
    srfidStopTriggerConfig *stop_trigger_cfg = [[srfidStopTriggerConfig alloc] init];

    /* allocate object for report parameters of rapid read operation */
    srfidReportConfig *report_cfg = [[srfidReportConfig alloc] init];

    /* allocate object for access parameters of rapid read operation */
    srfidAccessConfig *access_cfg = [[srfidAccessConfig alloc] init];

    /* an object for storage of error response received from RFID reader */
    NSString *error_response = nil;
    do {
        /* configure start and stop triggers parameters to start and stop actual operation immediately on a corresponding response */
        [start_trigger_cfg setStartOnHandheldTrigger:NO];
            [start_trigger_cfg setStartDelay:0];
            [start_trigger_cfg setRepeatMonitoring:NO];
            
            [stop_trigger_cfg setStopOnHandheldTrigger:NO];
            [stop_trigger_cfg setStopOnTimeout:NO];
            [stop_trigger_cfg setStopOnTagCount:NO];
            [stop_trigger_cfg setStopOnInventoryCount:NO];
            [stop_trigger_cfg setStopOnAccessCount:NO];
        /* set start trigger parameters */
            SRFID_RESULT result = [apiInstance srfidSetStartTriggerConfiguration:connectedReaderId aStartTriggeConfig:start_trigger_cfg aStatusMessage:&error_response];
            if (SRFID_RESULT_SUCCESS == result) {
                /* start trigger configuration applied */
                NSLog(@"Start trigger configuration has been set\n");
            }
            else {
                NSLog(@"Failed to set start trigger parameters\n");
                break;
            }
        /* set stop trigger parameters */
            result = [apiInstance srfidSetStopTriggerConfiguration:connectedReaderId aStopTriggeConfig:stop_trigger_cfg aStatusMessage:&error_response];
            if (SRFID_RESULT_SUCCESS == result) {
                /* stop trigger configuration applied */
                NSLog(@"Stop trigger configuration has been set\n");
            }
            else {
                NSLog(@"Failed to set stop trigger parameters\n");
                break;
            }
            
        /* start and stop triggers have been configured */
            error_response = nil;
            
            /* configure report parameters to report RSSI, Channel Index, Phase and PC fields */
            [report_cfg setIncPC:YES];
            [report_cfg setIncPhase:YES];
            [report_cfg setIncChannelIndex:YES];
            [report_cfg setIncRSSI:YES];
            [report_cfg setIncTagSeenCount:NO];
            [report_cfg setIncFirstSeenTime:NO];
            [report_cfg setIncLastSeenTime:NO];
            
            /* configure access parameters to perform the operation with 27.0 dbm antenna power level without application of pre-filters */
            [access_cfg setPower:270];
            [access_cfg setDoSelect:NO];


        /* request performing of rapid read operation */
        result = [apiInstance srfidStartRapidRead:connectedReaderId aReportConfig:report_cfg aAccessConfig:access_cfg aStatusMessage:&error_response];
        if (SRFID_RESULT_SUCCESS == result) {
                NSLog(@"Request succeed\n");
                
                /* stop an operation after 1 minute */
                
                dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(60 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                    [self->apiInstance srfidStopRapidRead:self->connectedReaderId aStatusMessage:nil];
                });
            }
            else if (SRFID_RESULT_RESPONSE_ERROR == result) {
                NSLog(@"Error response from RFID reader: %@\n", error_response);
            }
            else {
                NSLog(@"Request failed\n");
            }
            
        } while (0);

}

Events
- (void)srfidEventStatusNotify:(int)readerID aEvent:(SRFID_EVENT_STATUS)event aNotification:(id)notificationData {
    NSLog(@"Radio operation has %@\n", ((SRFID_EVENT_STATUS_OPERATION_START == event) ? @"started" : @"stopped"));
}

- (void)srfidEventReadNotify:(int)readerID aTagData:(srfidTagData *)tagData {
    /* print the received tag data */
    NSLog(@"Tag data received from RFID reader with ID = %d\n", readerID);
    NSLog(@"Tag id: %@\n", [tagData getTagId]);

}
`
 </code></pre>

<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#pair-by-scan"><span></span></a>Inventory</a></h2>
<p align="justify">Inventory is an advanced inventory operation being performed  simultaneously with reading from a particular memory bank.<br>
Inventory operation is performed similarly to the rapid read  operation described above. Thus performing and aborting of the inventory  operation is requested through <em>srfidStartInventory</em> and <em>srfidStopInventory</em> API functions  accordingly. After request of operation performing the actual operation will be  started in accordance with the configured start trigger parameters and will be  stopped once conditions specified by stop trigger parameters are met. After the  operation has stopped it might be started again if it is not aborted and the repeat  monitoring option is enabled in start trigger configuration. The SDK informs  the application about starting and stopping of the actual notification through corresponding  asynchronous notifications.<br>
The SDK will deliver asynchronous notifications to inform the  application about tag data received from the RFID reader during the on-going operation  if the application has subscribed for events of this type. Fields to be  reported during asynchronous tag data related notification are configured via <em>reportConfig </em>parameter of <em>srfidStartInventory</em> API function.</p>
						
<p>The  following example demonstrates performing of a continuous inventory operation  with reading from EPC memory bank that starts on a press of a physical trigger  and stops on a release of a physical trigger or after a 25 second timeout</p>
						
<pre class="prettyprint"><code>
-(void)startStopInventory{
    
    /* subscribe for tag data related events */
    [apiInstance srfidSubsribeForEvents:SRFID_EVENT_MASK_READ];
    /* subscribe for operation start/stop related events */
    [apiInstance srfidSubsribeForEvents:SRFID_EVENT_MASK_STATUS];

    /* identifier of one of active RFID readers is supposed to be stored in m_ReaderId variable */

    /* allocate object for start trigger settings */
    srfidStartTriggerConfig *start_trigger_cfg = [[srfidStartTriggerConfig alloc] init];

    /* allocate object for stop trigger settings */
    srfidStopTriggerConfig *stop_trigger_cfg = [[srfidStopTriggerConfig alloc] init];

    /* allocate object for report parameters of inventory operation */
    srfidReportConfig *report_cfg = [[srfidReportConfig alloc] init];

    /* allocate object for access parameters of inventory operation */
    srfidAccessConfig *access_cfg = [[srfidAccessConfig alloc] init];

    /* an object for storage of error response received from RFID reader */
    NSString *error_response = nil;

    do {
        /* configure start triggers parameters to start on physical trigger press */
        [start_trigger_cfg setStartOnHandheldTrigger:YES];
        [start_trigger_cfg setTriggerType:SRFID_TRIGGERTYPE_PRESS];
        [start_trigger_cfg setStartDelay:0];
        [start_trigger_cfg setRepeatMonitoring:YES];
        
        /* configure stop triggers parameters to stop on physical trigger release or on 25 sec timeout  */
        [stop_trigger_cfg setStopOnHandheldTrigger:YES];
        [stop_trigger_cfg setTriggerType:SRFID_TRIGGERTYPE_RELEASE];
        [stop_trigger_cfg setStopOnTimeout:YES];
        [stop_trigger_cfg setStopTimout:(25*1000)];
        [stop_trigger_cfg setStopOnTagCount:NO];
        [stop_trigger_cfg setStopOnInventoryCount:NO];
        [stop_trigger_cfg setStopOnAccessCount:NO];
        
        /* set start trigger parameters */
        SRFID_RESULT result = [apiInstance srfidSetStartTriggerConfiguration:connectedReaderId aStartTriggeConfig:start_trigger_cfg aStatusMessage:&error_response];
        if (SRFID_RESULT_SUCCESS == result) {
            /* start trigger configuration applied */
            NSLog(@"Start trigger configuration has been set\n");
        }
        else {
            NSLog(@"Failed to set start trigger parameters\n");
            break;
        }
        /* set stop trigger parameters */
        result = [apiInstance srfidSetStopTriggerConfiguration:connectedReaderId aStopTriggeConfig:stop_trigger_cfg aStatusMessage:&error_response];
        if (SRFID_RESULT_SUCCESS == result) {
            /* stop trigger configuration applied */
            NSLog(@"Stop trigger configuration has been set\n");
        }
        else {
            NSLog(@"Failed to set stop trigger parameters\n");
            break;
        }
            
        /* start and stop triggers have been configured */
        error_response = nil;
            
        /* configure report parameters to report RSSI and Channel Index fields */
        [report_cfg setIncPC:NO];
        [report_cfg setIncPhase:NO];
        [report_cfg setIncChannelIndex:YES];
        [report_cfg setIncRSSI:YES];
        [report_cfg setIncTagSeenCount:NO];
        [report_cfg setIncFirstSeenTime:NO];
        [report_cfg setIncLastSeenTime:NO];
            
        /* configure access parameters to perform the operation with 27.0 dbm antenna power level without application of pre-filters */
        [access_cfg setPower:270];
        [access_cfg setDoSelect:NO];
        /* request performing of inventory operation with reading from EPC memory bank */
        result = [apiInstance srfidStartInventory:connectedReaderId aMemoryBank:SRFID_MEMORYBANK_EPC aReportConfig:report_cfg aAccessConfig:access_cfg aStatusMessage:&error_response];
            
        if (SRFID_RESULT_SUCCESS == result) {
            NSLog(@"Request succeed\n");
            /* request abort of an operation after 1 minute */
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(60 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                [self->apiInstance srfidStopInventory:self->connectedReaderId aStatusMessage:nil];
            });
        }
        else if (SRFID_RESULT_RESPONSE_ERROR == result) {
            NSLog(@"Error response from RFID reader: %@\n", error_response);
        }
        else {
            NSLog(@"Request failed\n");
        }
                
    } while (0);

}
Events
- (void)srfidEventStatusNotify:(int)readerID aEvent:(SRFID_EVENT_STATUS)event aNotification:(id)notificationData {
    NSLog(@"Radio operation has %@\n", ((SRFID_EVENT_STATUS_OPERATION_START == event) ? @"started" : @"stopped"));
}
- (void)srfidEventReadNotify:(int)readerID aTagData:(srfidTagData *)tagData {
    /* print the received tag data */
    NSLog(@"Tag data received from RFID reader with ID = %d\n", readerID);
    NSLog(@"Tag id: %@\n", [tagData getTagId]);
    SRFID_MEMORYBANK bank = [tagData getMemoryBank];
    if (SRFID_MEMORYBANK_NONE != bank) {
        NSString *str_bank = @"";
        switch (bank) {
            case SRFID_MEMORYBANK_EPC:
                str_bank = @"EPC";
                break;
            case SRFID_MEMORYBANK_TID:
                str_bank = @"TID";
                break;
            case SRFID_MEMORYBANK_USER:
                str_bank = @"USER";
                break;

            case SRFID_MEMORYBANK_RESV:
                str_bank = @"RESV";
                break;
            case SRFID_MEMORYBANK_NONE:
                str_bank = @"None";
                break;
            case SRFID_MEMORYBANK_ACCESS:
                str_bank = @"Acess";
                break;
            case SRFID_MEMORYBANK_KILL:
                str_bank = @"Kill";
                break;
            case SRFID_MEMORYBANK_ALL:
                str_bank = @"All";
                break;
        }
        NSLog(@"%@ memory bank data: %@\n", str_bank, [tagData getMemoryBankData]);
    }
}


</code></pre>						

<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#pair-by-scan"><span></span></a>Inventory with Pre-filters</a></h2>

<p align="justify">If pre-filters are configured they might be applied during  performing of inventory operation. Application of pre-filters is enabled via <em>accessConfig</em> parameter of <em>srfidStartInventory</em> and <em>srfidStartRapidRead</em> API functions. Excepting  enablement of pre-filters application in <em>accessConfig</em> parameter inventory with pre-filters is performed similarly to a typical inventory  operation described above. The following example demonstrates enabling  application of configured pre-filters during inventory operation.</p>
<p align="justify">&nbsp;</p>

					
<pre class="prettyprint"><code>-(void)startStopInventoryWithPrefilters {
    /* allocate object for report parameters of inventory operation */
    srfidReportConfig *report_cfg = [[srfidReportConfig alloc] init];

    /* allocate object for access parameters of inventory operation */
    srfidAccessConfig *access_cfg = [[srfidAccessConfig alloc] init];

    /* an object for storage of error response received from RFID reader */
    NSString *error_response = nil;

    /* configure report parameters to report RSSI field */
    [report_cfg setIncPC:NO];
    [report_cfg setIncPhase:NO];
    [report_cfg setIncChannelIndex:NO];
    [report_cfg setIncRSSI:YES];
    [report_cfg setIncTagSeenCount:NO];
    [report_cfg setIncFirstSeenTime:NO];
    [report_cfg setIncLastSeenTime:NO];

    /* configure access parameters to perform the operation with 27.0 dbm antenna power level */
    [access_cfg setPower:270];
    /* enable application of configured pre-filters */
    [access_cfg setDoSelect:YES];

    /* request performing of inventory operation with reading from EPC memory bank */
    SRFID_RESULT result = [apiInstance srfidStartInventory:connectedReaderId aMemoryBank:SRFID_MEMORYBANK_EPC aReportConfig:report_cfg aAccessConfig:access_cfg aStatusMessage:&error_response];

    if (SRFID_RESULT_SUCCESS == result) {
        NSLog(@"Request succeed\n");
        
        /* request abort of an operation after 1 minute */
        
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(60 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            [self->apiInstance srfidStopInventory:self->connectedReaderId aStatusMessage:nil];
        });
    }
    else if (SRFID_RESULT_RESPONSE_ERROR == result) {
        NSLog(@"Error response from RFID reader: %@\n", error_response);
    }
    else {
        NSLog(@"Request failed\n");
    }

}
</code></pre>					
					

<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#pair-by-scan"><span></span></a>Tag Locationing</a></h2>
				
<p>The SDK provides an ability to perform tag locationing operation.  The <em>srfidStartTagLocationing</em> API  function is used to request performing of tag locationing operation. Aborting  of tag locationing operation is requested via <em>srfidStopTagLocationing</em> API function. The actual operation is  started and stopped based on configured start and stop triggers parameters. The  SDK informs the application about starting and stopping of the actual operation  via delivery of asynchronous notifications if the application has subscriber  for events of this type. During an on-going operation the SDK will deliver  asynchronous notifications to inform the application about current tag  proximity value (in percents).<br>
  The following example demonstrates performing of tag  locationing operation.</p>
				
<pre class="prettyprint"><code>
-(void)tagLocationing{

    /* subscribe for tag locationing related events */
    [apiInstance srfidSubsribeForEvents:SRFID_EVENT_MASK_PROXIMITY];
    /* subscribe for operation start/stop related events */
    [apiInstance srfidSubsribeForEvents:SRFID_EVENT_MASK_STATUS];
    /* identifier of one of active RFID readers is supposed to be stored in m_ReaderId variable */
    /* id of tag to be located */
    NSString *tag_id = @"V6219894630101R41022102N";
    /* an object for storage of error response received from RFID reader */
    NSString *error_response = nil;
    SRFID_RESULT result = [apiInstance srfidStartTagLocationing:connectedReaderId aTagEpcId:tag_id aStatusMessage:&error_response];
    if (SRFID_RESULT_SUCCESS == result) {
        NSLog(@"Request succeed\n");
        /* request abort of an operation after 1 minute */
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(60 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            [self->apiInstance srfidStopTagLocationing:self->connectedReaderId aStatusMessage:nil];
        });
    }
    else if (SRFID_RESULT_RESPONSE_ERROR == result) {
        NSLog(@"Error response from RFID reader: %@\n", error_response);
    }
    else {
        NSLog(@"Request failed\n");
    }
}

</code></pre>					
					
				
<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#pair-by-scan"><span></span></a>Multi Tag Locationing</a></h2>
<p align="justify">By using this API, users  can do multi-tag locationing.</p>
			
<pre class="prettyprint"><code>
/// Start multi tag locationing
-(void)startMultiTagLocationing {
    
    NSString *error_response = nil;
    
    srfidReportConfig *multipleTagsReportConfig;
    
    NSString *tag_id_1 = @"36420124102N012610R98V91";
    NSString *tag_id_2 = @"211241451351513251351324";
    NSString *tag_id_3 = @"434563463462345623456346";
   
    [multipleTagsReportConfig addItem:tag_id_1 aRSSIValueLimit:-(40)];
    [multipleTagsReportConfig addItem:tag_id_2 aRSSIValueLimit:-(40)];
    [multipleTagsReportConfig addItem:tag_id_3 aRSSIValueLimit:-(40)];
    
    SRFID_RESULT result = [_apiInstance srfidStartMultiTagsLocationing:_connectedRederID aReportConfig:multipleTagsReportConfig aAccessConfig:nil aStatusMessage:&error_response];
    
    if (SRFID_RESULT_SUCCESS == result) {
        NSLog(@"Request succeed\n");
    }else{
        NSLog(@"Request failed\n");
    }
}





/// Stop multi tag locationing
-(void)stopMultiTagLocationing{
    
    NSString *error_response = nil;
    
    SRFID_RESULT result = [_apiInstance srfidStopMultiTagsLocationing:_connectedRederID aStatusMessage:&error_response];
    
    if (SRFID_RESULT_SUCCESS == result) {
        NSLog(@"Request succeed\n");
    }else{
        NSLog(@"Request failed\n");
    }
}

</code></pre>					

<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#pair-by-scan"><span></span></a>Access Operations</a></h2>

<p align="justify">The SDK supports performing of read, write, lock and kill  access operations on a specific tag. Access operations are performed via <em>srfidReadTag</em>, <em>srfidWriteTag</em>, <em>srfidLockTag</em> and <em>srfiKillTag</em> API functions  accordingly. The mentioned API functions are performed synchronously; the  corresponding operation is started immediately and is stopped once tag data is  reported by RFID reader or after a 5 seconds timeout. </p>
The  following example demonstrates performing of read and write access operations on  one of tags being inventoried
		
<pre class="prettyprint"><code>
-(void)accessOperationTagReadAndWrite {
    
    /* allocate object for storing results of access operation */
    srfidTagData *access_result = [[srfidTagData alloc] init];
    /* id of tag to be read */
    NSString *tag_id = @"36420124102N012610R98V91";
    /* an object for storage of error response received from RFID reader */
    NSString *error_response = nil;

    /* request to read 8 words from EPC memory bank of tag specified by tag _id */
    SRFID_RESULT result = [apiInstance srfidReadTag:connectedReaderId aTagID:tag_id aAccessTagData:&access_result aMemoryBank:SRFID_MEMORYBANK_EPC aOffset:0 aLength:8 aPassword:0x00 aStatusMessage:&error_response];

    if (SRFID_RESULT_SUCCESS == result) {
        NSLog(@"Request succeed\n");
        
        /* check result code of access operation */
        if (NO == [access_result getOperationSucceed]) {
            NSLog(@"Read operation has failed with error: %@\n", [access_result getOperationStatus]);
        }
        else {
            NSLog(@"Memory bank data: %@", [access_result getMemoryBankData]);
        }
    }
    else if (SRFID_RESULT_RESPONSE_ERROR == result) {
        NSLog(@"Error response from RFID reader: %@\n", error_response);
    }
    else if (SRFID_RESULT_RESPONSE_TIMEOUT == result) {
        NSLog(@"Timeout occurred\n");
    }
    else {
        NSLog(@"Request failed\n");
    }

    access_result = [[srfidTagData alloc] init];
    error_response = nil;

    /* data to be written */
    NSString *data = @"N20122014R1010364989126V";

    /* request to write a data to a EPC memory bank of tag specified by tag_id */
    result = [apiInstance srfidWriteTag:connectedReaderId aTagID:tag_id aAccessTagData:&access_result aMemoryBank:SRFID_MEMORYBANK_EPC aOffset:0 aData:data aPassword:0x00 aDoBlockWrite:NO aStatusMessage:&error_response];

    if (SRFID_RESULT_SUCCESS == result) {
        NSLog(@"Request succeed\n");
        
        /* check result code of access operation */
        if (NO == [access_result getOperationSucceed]) {
            NSLog(@"Write operation has failed with error: %@\n", [access_result getOperationStatus]);
        }
    }
    else if (SRFID_RESULT_RESPONSE_ERROR == result) {
        NSLog(@"Error response from RFID reader: %@\n", error_response);
    }
    else if (SRFID_RESULT_RESPONSE_TIMEOUT == result) {
        NSLog(@"Timeout occurred\n");
    }
    else {
        NSLog(@"Request failed\n");
    }

}


</code> </pre>			
	
  <h1 class="anchor">Barcode SDK API Calls</h1>	
  <h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#pair-by-scan"><span></span></a>Implement <em>ISbtSdkApiDelegate </em>protocol</a></h2>
	

  <p align="justify">Objective C protocol which defines SDK callbacks interface.  Registration of a particular object which conforms to <em>ISbtSdkApiDelegate</em> protocol is required to receive particular from the  SDK. SDK callback interface is defined by <em>ISbtSdkApiDelegate</em> Objective C protocol. Registration of a particular object which conforms to <em>ISbtSdkApiDelegate</em> protocol is required  to receive particular notifications from Zebra Bluetooth Scanner iOS SDK.<br><br><br>
	  

  BarcodeViewController.h file.</p>
	
<pre class="prettyprint"><code>
#import <UIKit/UIKit.h>
#import "SbtSdkFactory.h"

/// Responsible for barcode sdk events and action
@interface BarcodeViewController : UIViewController<ISbtSdkApiDelegate> {
    
    
}

@end
</code></pre>	

<p align="justify">BarcodeViewController.m file.</p>

<pre class="prettyprint"><code>

#import "BarcodeViewController.h"
/// Responsible for barcode sdk events and action
@interface BarcodeViewController ()

@end

@implementation BarcodeViewController

#pragma mark - Life Cycle Methods
- (void)viewDidLoad {

    [super viewDidLoad];
    [sdkApi sbtSetDelegate:self];
    
}
/// The barcode event
/// @param barcodeData The barcode data
/// @param barcodeType The barcode type
/// @param scannerID  The scanner id
- (void)sbtEventBarcode:(NSString *)barcodeData barcodeType:(int)barcodeType fromScanner:(int)scannerID {
    
    NSLog(@"Barcode Event: data event, %@",barcodeData);
    
}

/// The barcode event data
/// @param barcodeData The barcode data
/// @param barcodeType The barcode type
/// @param scannerID  The scanner id
- (void)sbtEventBarcodeData:(NSData *)barcodeData barcodeType:(int)barcodeType fromScanner:(int)scannerID {
   
    NSData *decodeData = [[NSData alloc] initWithData:barcodeData];
    NSString *decodeDataString = [[NSString alloc] initWithBytes:((unsigned char*)[decodeData bytes]) length:([decodeData length]) encoding:NSUTF8StringEncoding];
    
    NSLog(@"Barcode Event :  %@",decodeDataString);
    dispatch_async(dispatch_get_main_queue(),^{
        self->textView_barcode_data.text = decodeDataString;
    });
    
}

/// The device connected event
/// @param activeScanner The connected scanner object
- (void)sbtEventCommunicationSessionEstablished:(SbtScannerInfo *)activeScanner {
    
    NSLog(@"Device has connected, Device name  :%@",[activeScanner getScannerName]);
    
}

/// The device disconnected event
/// @param scannerID The scanner id
- (void)sbtEventCommunicationSessionTerminated:(int)scannerID {
   
    NSLog(@"Device has Diconnected, Device ID %d",scannerID);
    
}

/// The firmware update event
/// @param fwUpdateEventObj firmware update event object
- (void)sbtEventFirmwareUpdate:(FirmwareUpdateEvent *)fwUpdateEventObj {
    
    NSLog(@"Firmware updat event - Max record : %d",fwUpdateEventObj.maxRecords);
    NSLog(@"Firmware updat event - Current record : %d",fwUpdateEventObj.currentRecord);
    NSLog(@"Firmware updat event - Current Status : %d",fwUpdateEventObj.status);
}


/// The image event
/// @param imageData The image data
/// @param scannerID The scanner id
- (void)sbtEventImage:(NSData *)imageData fromScanner:(int)scannerID {
   
    NSLog(@"Image event");
    
}

/// The device appear event
/// @param availableScanner The scanner object
- (void)sbtEventScannerAppeared:(SbtScannerInfo *)availableScanner {
    
    NSLog(@"Device has appeared, Device name %@",[availableScanner getScannerName]);
    
}

/// The scanner disappear event
/// @param scannerID The scanner id
- (void)sbtEventScannerDisappeared:(int)scannerID {
  
    NSLog(@"Device disappeared");
}



/// The video event
/// @param videoFrame The video data
/// @param scannerID The scanner id
- (void)sbtEventVideo:(NSData *)videoFrame fromScanner:(int)scannerID {
  
    NSLog(@"The video event");

}

@end
</code></pre>

<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#pair-by-scan"><span></span></a>Initialize barcode sdk</a></h2>

<pre class="prettyprint"><code>/// Initilize barcode sdk
-(void)initilizeBarcodeSDK {
    
    sdkApi = [SbtSdkFactory createSbtSdkApiInstance];
    [sdkApi sbtSetDelegate:self];
    [sdkApi sbtSetOperationalMode:SBT_OPMODE_ALL];
    [sdkApi sbtSubsribeForEvents:SBT_EVENT_SCANNER_APPEARANCE |
    SBT_EVENT_SCANNER_DISAPPEARANCE | SBT_EVENT_SESSION_ESTABLISHMENT |
    SBT_EVENT_SESSION_TERMINATION | SBT_EVENT_BARCODE | SBT_EVENT_IMAGE |
    SBT_EVENT_VIDEO];
    [sdkApi sbtEnableAvailableScannersDetection:YES];
    
}
</code></pre>

<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#pair-by-scan"><span></span></a>Get barcode sdk version</a></h2>
	
<pre class="prettyprint"><code>
Returns version of the SDK.
/*
This method will provide the scanner SDK version
- Returns : SDK version
*/
- (NSString *)getSDKVersion
{
    NSString *version = [sdkApi sbtGetVersion];
    return version;
}

</code></pre>	

<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#pair-by-scan"><span></span></a>Connect</a></h2>	
<p align="justify">Requests to establish communication session with a particular available scanner in “SSI” mode</p>	

<pre class="prettyprint"><code>
/// This method will initiate the connection with particuler scanner
/// @param scanner_id Scanner id of the connecting scanner
-(void)connectScanner:(int)scanner_id{
    if (sdkApi != nil)
    {
      if(scanner_id != -1 )
      {
        SBT_RESULT conn_result = [sdkApi sbtEstablishCommunicationSession:scanner_id];

        if (SBT_RESULT_SUCCESS != conn_result)
        {
            dispatch_async(dispatch_get_main_queue(), ^{
                [self showMessageBox:@"SCANNER_CONNECTION_FAILED"];
            });
        }
      }
    }
}
</code></pre>

<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#pair-by-scan"><span></span></a>Disconnect</a></h2>
<p align="justify">Requests to terminate communication session with a particular active scanner</p>

<pre class="prettyprint"><code>
/// This method will initiate the disconnection with particuler scanner
/// @param scannerId Scanner id of the disconnecting the scanner
- (void)disconnect:(int)scannerId
{
  
    if (sdkApi != nil)
    {
        SBT_RESULT res = [sdkApi sbtTerminateCommunicationSession:scannerId];
        if (res == SBT_RESULT_FAILURE) {
            [self showMessageBox:@"DISCONNECT_FAILED_MESSAGE"];
        }
    }
}
</code></pre>

 <h1 class="anchor">Firmware Update</h1>	
<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#pair-by-scan"><span></span></a>Overview</a></h2>
<p align="justify">To do a firmware update in the 123RFID mobile app, you needed a firmware file in “.dat”/.SCNPLG” format</p>

<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#pair-by-scan"><span></span></a>Implement Firmware update</a></h2>

<pre class="prettyprint"><code>
- (IBAction)btnFirmwaareUpdate:(id)sender
{
    NSString *inputXML = [NSString stringWithFormat:@"<inArgs><scannerID>%d</scannerID><cmdArgs><arg-string>%@</arg-string></cmdArgs></inArgs>", _connectedRederID, @"FIRMWARE_FILE_PATH"];
    int firmwareFileTypeCommand = 0;

    //If firmware file is “.Dat” then command type is “SBT_UPDATE_FIRMWARE”.
    //If firmware file is plugin then command type is “SBT_UPDATE_FIRMWARE_FROM_PLUGIN”.
    firmwareFileTypeCommand = SBT_UPDATE_FIRMWARE;
    SBT_RESULT result = [self executeCommand:firmwareFileTypeCommand aInXML:inputXML];
    
    if (result) {
        
        NSString *in_xml = [NSString stringWithFormat:@"<inArgs><scannerID>%d</scannerID></inArgs>", _connectedRederID];
        [self performStartNewFirmware:in_xml];
    
    }else{
        NSLog(@"Firmare update failed !");
    }

}

/// Perform start new firmware
/// @param param The inXML value
- (void)performStartNewFirmware:(NSString*)param
{
  
    SBT_RESULT result = [self executeCommand:SBT_START_NEW_FIRMWARE aInXML:param aOutXML:nil forScanner:_connectedRederID];
    if (result != SBT_RESULT_SUCCESS)
    {
        NSLog(@"Firmware Update Failed.");
        
    }else{
        NSLog(@"Firmware Update Success.");
    }
    
}

// Firmware update event
/// @param fwUpdateEventObj SDK's firmware update event object
- (void)sbtEventFirmwareUpdate:(FirmwareUpdateEvent *)event{

     NSLog(@"Current Record : %f",(float)event.currentRecord);
     NSLog(@"Max Record : %f",(float)event.maxRecords);
    int currentProgressInPrecentage = (int)((float)event.currentRecord/event.maxRecords*100);
    NSLog(@"Precentage %d",currentProgressInPrecentage);

}

/// Execute command inXML only
/// @param opCode Command code
/// @param inXML Input XML
/// @Return SBT Result
- (SBT_RESULT)executeCommand:(int)opCode aInXML:(NSString*)inXML{
    if (sdkApi != nil){
        
        SBT_RESULT resultExecuteCommand = [sdkApi sbtExecuteCommand:opCode aInXML:inXML aOutXML:NULL forScanner:_connectedRederID];
        return resultExecuteCommand;
    }
    return SBT_RESULT_FAILURE;
}
</code></pre>

 <h1 class="anchor">Locate Reader</h1>	

<p align="justify">The SDK supports performing locate the reader by calling “srfidLocateReader”. After calling this API reader will beep.</p>
<p align="justify">The following example demonstrates perform locate reader.</p>

<pre class="prettyprint"><code>
- (void) locateTheReader:(BOOL)enabled
{
    SRFID_RESULT conn_result = SRFID_RESULT_FAILURE;
    if (self->_apiInstance != nil)
    {
        conn_result = [self->_apiInstance srfidLocateReader:_connectedRederID doEnabled:enabled aStatusMessage:nil];

        if (SRFID_RESULT_SUCCESS != conn_result)
        {
            NSLog(@"Couldn't locate reader");
        } else{
            NSLog(@"Locate the reader");
        }
    }
   
}

</code></pre>



<h1 class="anchor">Batch Mode</h1>	

<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#pair-by-scan"><span></span></a>Get Batch Mode</a></h2>


<p align="justify" >This “srfidGetBatchModeConfig” API will return the status (“BATCHMODECONFIG”) of the batch mode.</p>

<pre class="prettyprint"><code>
typedef enum
{

    SRFID_BATCHMODECONFIG_DISABLE  = 0x00,
    SRFID_BATCHMODECONFIG_AUTO     = 0x01,
    SRFID_BATCHMODECONFIG_ENABLE   = 0x02,

} SRFID_BATCHMODECONFIG;



-(SRFID_BATCHMODECONFIG)getBatchModeConfig:(NSString **)responsMessage
{
    //SRFID_BATCHMODECONFIG_AUTO ,SRFID_BATCHMODECONFIG_ENABLE and SRFID_BATCHMODECONFIG_DISABLE
    SRFID_BATCHMODECONFIG batchModeConfigiuration = SRFID_BATCHMODECONFIG_AUTO;
    SRFID_RESULT srfid_result = SRFID_RESULT_FAILURE;
    
    for(int i = 0; i < 2; i++)
    {
        srfid_result = [self->_apiInstance srfidGetBatchModeConfig:_connectedRederID aBatchModeConfig:&batchModeConfigiuration aStatusMessage:responsMessage ];
        if ((srfid_result != SRFID_RESULT_RESPONSE_TIMEOUT) && (srfid_result != SRFID_RESULT_FAILURE)) {
            break;
        }
    }

    if (srfid_result == SRFID_RESULT_SUCCESS)
    {
        
        NSLog(@"getBatchMod Response Success: %u", batchModeConfigiuration);
    }
    else if(srfid_result == SRFID_RESULT_RESPONSE_ERROR)
    {
        NSLog(@"Response Error");
    }
    else if(srfid_result == SRFID_RESULT_FAILURE || srfid_result == SRFID_RESULT_RESPONSE_TIMEOUT)
    {
        NSLog(@"Timeout or Failure");
    }
    
    return batchModeConfigiuration;
}





- (IBAction)btnGetBatchMode:(id)sender
{
    SRFID_BATCHMODECONFIG batchModeConfigiuration =  [self getBatchModeConfig:nil];
    
    switch (batchModeConfigiuration) {
        case SRFID_BATCHMODECONFIG_DISABLE:
            NSLog(@"Batchmode Disable");
            break;
        case SRFID_BATCHMODECONFIG_AUTO:
            NSLog(@"Batchmode Auto");
            break;
        case SRFID_BATCHMODECONFIG_ENABLE:
            NSLog(@"Batchmode Enable");
            break;
        default:
            break;
    }
   
   
}


</code></pre>

<h1 class="anchor">Auto Reconnect</h1>	
<p align="justify">Requests to enable/disable “Automatic communication session reestablishment” option.</p>
<pre class="prettyprint"><code>
[apiInstance srfidEnableAutomaticSessionReestablishment:YES];
- (SRFID_RESULT) srfidEnableAutomaticSessionReestablishment:(BOOL)enable;

Parameters
(BOOL)enable
[in] Whether the option should be enabled or disabled:
YES
Requests to enable “Automatic communication session reestablishment” option.
NO
Requests to disable “Automatic communication session reestablishment” option.
Return Values
SRFID_RESULT_SUCCESS
“Automatic communication session reestablishment” option has been enabled/disabled successfully. 

</code>
</pre>







<h2 id="pair-by-scan" class="anchor"><a class="heading-anchor" href="#pair-by-scan"><span></span></a>Set Batch Mode</a></h2>

<p align="justify">This “srfidSetBatchModeConfig” API will set the batch mode</p>

<pre class="prettyprint"><code>


- (void)setBatchModeConfig:(NSString **)statusMessage aBatchModeConfig:(SRFID_BATCHMODECONFIG)batchModeConfig
{
    //SRFID_BATCHMODECONFIG_AUTO ,SRFID_BATCHMODECONFIG_ENABLE and SRFID_BATCHMODECONFIG_DISABLE
    SRFID_RESULT srfid_result = SRFID_RESULT_FAILURE;
   
    for(int i = 0; i < 2; i++)
    {
        srfid_result = [self->_apiInstance srfidSetBatchModeConfig:_connectedRederID aBatchModeConfig:batchModeConfig aStatusMessage:statusMessage];
        if ((srfid_result != SRFID_RESULT_RESPONSE_TIMEOUT) && (srfid_result != SRFID_RESULT_FAILURE)) {
            break;
        }
    }
    
    if (srfid_result == SRFID_RESULT_SUCCESS)
    {
       NSLog(@"setBatchModeConfig Response Success: %u", srfid_result);
        
    }
    else if(srfid_result == SRFID_RESULT_RESPONSE_ERROR)
    {
        NSLog(@"Response Error");
    }
    else if(srfid_result == SRFID_RESULT_FAILURE || srfid_result == SRFID_RESULT_RESPONSE_TIMEOUT)
    {
        NSLog(@"Timeout or Failure");
    }

}


</code></pre>
<h2 id="pair-by-scan2" class="anchor">Get Tags in Batch Mode</a></h2>
<p align="justify">This “srfidgetTags”  API will request to receive tags read in batch mode from a particular RFID reader.</p>

<pre class="prettyprint"><code>
- (SRFID_RESULT)getTags:(NSString **)statusMessage
{

    NSString *status_msg = nil;

    if (nil != self->_apiInstance)
    {
        SRFID_RESULT result;
        result = [self->_apiInstance srfidgetTags:_connectedRederID aStatusMessage:&status_msg];
        return result;
    }
    return SRFID_RESULT_FAILURE;
}

</code>
</pre>
<h2 id="pair-by-scan3" class="anchor">Purge Tag</a></h2>
<p align="justify">Request to purge tags read in batch mode from a particular RFID reader.</p>
<pre class="prettyprint"><code>
- (SRFID_RESULT)purgeTags:(NSString **)statusMessage
{
    NSString *status_msg = nil;
    
    if (nil != self->_apiInstance)
    {
        SRFID_RESULT result;
        result = [self->_apiInstance srfidPurgeTags:self->_connectedRederID aS<h1></h1>tatusMessage:&status_msg];
        return result;
    }
    return SRFID_RESULT_FAILURE;
}

</code>
</pre>

<h2 id="pair-by-scan3" class="anchor">Get Reader Configuration</a></h2>
<p align="justify">Request to get the reader configurations after batch mode reconnect.</p>
<pre class="prettyprint"><code>
- (void) reconnectAfterBatchMode
{
    [self->_apiInstance srfidGetConfigurations];
}
Parameters
(BOOL)enable
[in] Whether the option should be enabled or disabled:
YES
Requests to enable “Automatic communication session reestablishment” option.
NO
Requests to disable “Automatic communication session reestablishment” option.
Return Values
SRFID_RESULT_SUCCESS
“Automatic communication session reestablishment” option has been enabled/disabled successfully. 

</code>
</pre>

<p><strong>NOTES</strong></p>
<p align="justify">If the option is enabled the SDK will automatically establish communication session with the last active RFID reader that had unexpectedly disappeared once the RFID reader will be recognized as available:
The RFID reader could be recognized as available automatically by SDK if “Available readers detection” option is enabled.
The RFID reader could be recognized as available during discovery procedure requested by srfidGetAvailableReadersList API.
“Session Established” notification will be provided once the communication session is established, if this type of notification is enabled
</p>


<h1 class="anchor">Setting up the Pair by Scan</h1>

                                                    <h3 id="pair-by-scan-overview" class="anchor"><a class="heading-anchor" href="#pair-by-scan-overview"><span></span></a>Overview</h3>

                                                    <p>Pair by Scan will provide a faster way to connect to the MFI scanner. This solution provide pair with MFI scanner inside the sample app, by using camera view in the iPhone inbuilt camera scan the device barcode image and get the serial number and try to connect with that device.</p>

                                                    <h3 id="pair-by-scan-steps" class="anchor"><a class="heading-anchor" href="#pair-by-scan-steps"><span></span></a>Steps</h3>

                                                    <p>Before follow bellow steps first unpair RFD8500 device (the device you want to pair) from Bluetooth settings.</p>

                                                    <div style="display: block; margin: 0 auto; text-align: center;">
                                                        <img src="../../images/ios/pair-by-scan-001-paired-devcies-list.png" style="display: block; margin: 0 auto;"><strong>Figure 10</strong> Paired Bluetooth Devices
                                                    </div>

                           -                         <br />

                                                    <div style="display: block; margin: 0 auto; text-align: center;">
                                                        <img src="../../images/ios/pair-by-scan-002-upair-device.png" style="display: block; margin: 0 auto;"><strong>Figure 11</strong> Unpairing a Bluetooth Device
                                                    </div>

                                                    <p><strong>Step 1</strong> Open the 123RFID mobile app and go to “Reader list page” and click pair by scan icon which is in navigation bar right corner. Then camera view will be appeared as below.</p>

                                                    <div style="display: block; margin: 0 auto; text-align: center;">
                                                        <img src="../../images/ios/pair-by-scan-003-readers-list.png" style="display: block; margin: 0 auto;"><strong>Figure 12</strong> Readers List
                                                    </div>

                                                    <br />

                                                    <div style="display: block; margin: 0 auto; text-align: center;">
                                                        <img src="../../images/ios/pair-by-scan-004-reader-bluetooth-address.png" style="display: block; margin: 0 auto;"><strong>Figure 13</strong> Reader Bluetooth Address
                                                    </div>

                                                    <p><strong>Step 2</strong> After opening the camera view scan the device barcode. Before doing this, the RFD8500 Bluetooth indicator led should blink. Otherwise, device does not appear in picker list.</p>

                                                    <div style="display: block; margin: 0 auto; text-align: center;">
                                                        <img src="../../images/ios/pair-by-scan-005-reader-bluetooth-status.png" style="display: block; margin: 0 auto;"><strong>Figure 14</strong> Reader Bluetooth Status
                                                    </div>

                                                    <br />

                                                    <div style="display: block; margin: 0 auto; text-align: center;">
                                                        <img src="../../images/ios/pair-by-scan-006-reader-list-ready-to-pair.png" style="display: block; margin: 0 auto;"><strong>Figure 15</strong> Readers List - Ready to Pair
                                                    </div>

                                                    <p><strong>Step 3</strong> Click the device which you want to pair and press the RFD8500 trigger to pair when the Bluetooth LED is start flashing fast. You will get a beep sound once it paired successfully.</p>

                                                    <div style="display: block; margin: 0 auto; text-align: center;">
                                                        <img src="../../images/ios/pair-by-scan-007-reader-list-pairing.png" style="display: block; margin: 0 auto;"><strong>Figure 16</strong> Readers List - Pairing
                                                    </div>

                                                    <br />

                                                    <div style="display: block; margin: 0 auto; text-align: center;">
                                                        <img src="../../images/ios/pair-by-scan-008-reader-list-paired.png" style="display: block; margin: 0 auto;"><strong>Figure 17</strong> Readers List - Paired
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>
                </div>
            </section>    
            <div class="modal fade" id="basicModal" tabindex="-1" role="dialog" aria-labelledby="basicModal" aria-hidden="true" data-backdrop="true">
			    <div class="modal-dialog">
				    <div class="modal-content">
					    <div class="modal-header">
						    <button type="button" class="close" data-dismiss="modal" aria-hidden="true">X</button>
					    </div>
					    <div class="modal-body">
						    <div id="modalImg"></div>
					    </div>
			        </div>
		        </div>
            </div>
        </div>
        <footer id="footer" class="navbar-fixed-bottom">
            <div class="container-fluid">
                <div class="row">
                    <div class="col-sm-10">
                        ZEBRA and the stylized Zebra head are trademarks of Zebra Technologies Corporation, registered in many jurisdictions worldwide. All other trademarks are the property of their respective owners. &copy;2022 Zebra Technologies Corporation and/or its affiliates. All rights reserved. <a href="https://www.zebra.com/us/en/about-zebra/company-information/legal/terms-of-use.html">Terms &amp; Conditions</a>
                    </div>
                    <div class="col-sm-2">
                        <ul class="social-icons">
                            <li><a href="http://www.facebook.com/pages/Zebra-Technologies/107703715989073"><i class="fa fa-facebook"></i></a></li>
                            <li><a href="https://twitter.com/ZebraDevs"><i class="fa fa-twitter"></i></a></li>
                            <li><a href="http://www.youtube.com/zebratechnologies/"><i class="fa fa-youtube"></i></a></li>
                            <li><a href="https://www.linkedin.com/groups?home=&amp;gid=3220074&amp;trk=anet_ug_hm&amp;goback=%2Egmr_3220074"><i class="fa fa-linkedin"></i></a></li>
                            <li><a href="https://github.com/zebra-technologies"><i class="fa fa-github"></i></a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </footer><!--/#footer-->
        <script src="/js/bootstrap.min.js"></script>
        <script src="/js/owl.carousel.min.js"></script>
        <script src="/js/mousescroll.js"></script>
        <script src="/js/smoothscroll.js"></script>
        <script src="/js/jquery.prettyPhoto.js"></script>
        <script src="/js/jquery.isotope.min.js"></script>
        <script src="/js/jquery.inview.min.js"></script>
        <script src="/js/wow.min.js"></script>
        <script src="/js/bootstrap-treenav.min.js"></script>
        <script src="/js/prettify.js"></script>
        <script src="/js/zepto.js"></script>
        <script src="/js/jquery.waterfall.js"></script>   
        <script src="/js/main.js"></script>
        <script type="text/javascript">
            (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
                (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
                e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
            })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

            _st('install','zRzEsAUhWTTkrdEN2YfA','2.0.0');
        </script>
        <script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-72584442-1', 'auto');
            ga('send', 'pageview');
        </script> 
        <script>
            ChatraID = 'QDvZ76min4DhLW5vJ';
            (function(d, w, c) {
                var n = d.getElementsByTagName('script')[0],
                    s = d.createElement('script');
                w[c] = w[c] || function() {
                    (w[c].q = w[c].q || []).push(arguments);
                };
                s.async = true;
                s.src = (d.location.protocol === 'https:' ? 'https:': 'http:')
                    + '//call.chatra.io/chatra.js';
                n.parentNode.insertBefore(s, n);
            })(document, window, 'Chatra');
        </script>         
    </body>
</html>