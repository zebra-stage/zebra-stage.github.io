
<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Online Documentation for Zebra Technologies developer tools and utiltiescomp including EMDK for Android, EMDK for Xamarin, StageNow, Enterprise Browser.">
    <meta name="author" content="Zebra Technologies">
    <meta name="google-site-verification" content="i4B78BrWnNy8ShJwe5feRW3jO3HE6gfYlYqYbxfl8yY">
    <meta name="msvalidate.01" content="6B651B00161BCE79B8950AC09D5C4C75">
    <meta title="Hello RFID Application">
    <title>Hello RFID Application - Zebra Technologies Techdocs</title>
    <!-- core CSS -->
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="/css/font-awesome.min.css" rel="stylesheet">
    <link href="/css/animate.min.css" rel="stylesheet">
    <link href="/css/owl.carousel.css" rel="stylesheet">
    <link href="/css/owl.transitions.css" rel="stylesheet">
    <link href="/css/prettyPhoto.css" rel="stylesheet">
    <link href="/css/main.css" rel="stylesheet">
    <link href="/css/responsive.css" rel="stylesheet">
    <link href="/css/prettify.css" rel="stylesheet">
    <link href="/css/bootstrap-treenav.min.css" rel="stylesheet">
    <!--[if lt IE 9]>
    <script src="js/html5shiv.js"></script>
    <script src="js/respond.min.js"></script>
    <![endif]--> 

    <script src="//load.sumome.com/" data-sumo-site-id="699cb66cf4dc59352efb45705526d15cbe314e1cd43f7761b94d96f3cf7338e8" async="async"></script>
    <link rel="shortcut icon" href="/favicon.ico">
<script src="/js/jquery.js"></script></head><!--/head-->


<body id="home" class="homepage" data-spy="scroll" data-offset="100" data-target="#toc">

    <header id="header">
        <nav id="main-menu" class="navbar navbar-default navbar-fixed-top" role="banner">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/"><img src="/images/logo.png" alt="logo" style="max-height:66px;float: inherit;
    padding-right: 3px;"></a> 
                    
                   
                </div>
                <div class="collapse navbar-collapse navbar-left">
                    <ul class="nav navbar-nav">
                        <li class="navbar-text pull-left"><strong>TECHDOCS</strong></li>
                        <li>
                                <a href="/dcs/rfid">RFID</a>
                        </li>
                        <p class="navbar-text">RFID SDK for Android</p>                
                    </ul>
                </div>
                                <div class="collapse navbar-collapse navbar-right">
                    <ul class="nav navbar-nav">
                        


                        <li>
                            <a href="/dcs/rfid/android/2-0-5-238/guide/about">
                                    About
                            </a>
                        </li>
                        <li>
                            <a href="/dcs/rfid/android/2-0-5-238/guide/gettingstarted">
                                    Getting Started
                            </a>
                        </li>
                        <li>
                            <a href="/dcs/rfid/android/2-0-5-238/tutorials">
                                    Tutorials
                            </a>
                        </li>                        
                        <li>
                            <a href="/dcs/rfid/android/2-0-5-238/samples">
                                    Samples
                            </a>
                        </li>
                        <li>
                            <a href="/dcs/rfid/android/2-0-5-238/guide/programming-guides">
                                    Guides
                            </a>
                        </li>
                        <li>
                            <a href="/dcs/rfid/android/2-0-5-238/apis">
                                    APIs
                            </a>
                        </li>
                        <li>
                            <a href="https://developer.zebra.com/community/home/discussions/">
                                    <i class="fa fa-comments-o"></i>
                            </a>
                        </li>
                        <li>
                            <a href="/dcs/rfid/android/2-0-5-238/search">
                                    <i class="fa fa-search"></i>
                            </a>
                        </li>
                        
                        <!-- <li ><a href="/products">SDKs</a></li>
                        <li ><a href="/samples">Samples</a></li>
                        <li ><a href="/guides">Guides</a></li>
                        <li ><a href="/tutorials">Tutorials</a></li>
                        <li ><a href="/apis">APIs</a></li> -->
                        <!-- <li><a href="#"><input type="text" class="st-default-search-input"></a></li> -->
                    </ul>
                </div>
            </div><!--/.container-->
        </nav><!--/nav-->
    </header><!--/header-->
<div class="container-fluid">
    <section id="blog">
        <div class="">
            <section class="content-with-sidebar">
            <div class="row">
                <div class="col-sm-3 hidden-sm hidden-xs" id="sidebar">
                    
                    
                    <nav id="toc" data-toggle="toc" data-spy="affix" style="height: 75%; max-width: 225px; overflow-y: auto; ">
                        
                        <ul class="nav">
                            <li><strong>Scan-Scan-Write</strong></li>
                        </ul>
                    </nav>
                    
                    <script type="text/javascript">
                        $(document).ready(function() {
                        	$( "#btn_SaveSmartDocOptions" ).click(function() {
                      			console.log('Saving Options');
                      			$("#modal-smartdocs").modal({show: false});
                    		});
                        	$( "#btn_SaveSmartDocOptions" ).click(function() {
                      			console.log('Clearing Options');
                      			$("#modal-smartdocs").modal({show: false});
                    		});
                        });
                    </script><link rel="stylesheet" href="https://cdn.rawgit.com/afeld/bootstrap-toc/v0.3.0/dist/bootstrap-toc.min.css">
                    <script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v0.3.0/dist/bootstrap-toc.min.js"></script>
                    <script type="text/javascript">
                        $(document).ready(function() {
                    
                        });
                    
                    
                    </script>
                </div>                
                <div class="col-sm-9 ">
                    <div class="row">
                        <div class="col-sm-12">
                            <section id="cta" class="wow fadeIn">
                                <div class="">
                                    <h1 id="hello-rfid-tutorial" class="anchor"><a class="heading-anchor" href="#hello-rfid-tutorial"><span></span></a>Scan-Scan-Write</h1>
                                    <p>
                                      RFID SDK For Android
                                            2.0.5.238
                              </p>
                                </div>
                            </section>                    
                        </div>
                    </div>
                    <div id="mainContent" class="row">
                        <div class="col-sm-12">
                            <div class="blog-post blog-large wow fadeInLeft" data-wow-duration="300ms" data-wow-delay="0ms">
                            <!-- Start of guide -->
                                <div class="service-box wow fadeInRight">
                                    <div class="">

                                        <p></p><h2 id="overview" class="anchor"><a class="heading-anchor" href="#overview"><span></span></a>Overview</h2>
<p>This guide provides a walk-through for creating an application that uses barcode scanning and  <a href="../../apis">RFID APIs</a> to implement a scan-scan-write workflow. The application allows users to:
<ol>
    <li>Scan a product barcode</li>
    <li>Convert that barcode to a SGTIN-96 format EPC</li>
    <li>Scan a RFID tag with barcode</li>
    <li>Write the converted EPC to the scanned RFID tag</li>
</ol>
</p>

<blockquote>
  <p>Note: <strong>The demo app in this guide is intended for tutorial purposes only</strong> and should not be used in production environments. </p>
</blockquote>

<hr>
<h3 id="basicaddition" class="anchor"><a class="heading-anchor" href="#enableandroidpermissions"><span></span></a>Prerequisites</h3>

<ol>
<li><p>Developer machine with latest Android studio</p></li>
<li><p>Developer machine with Zebra Android device USB driver installed</p></li>
<li><p>Zebra Android device with developer mode turned on</p></li>
<li><p>Reader regulatory is configured as per norms using RFID Manager or Zebra RFID Demo application</p></li>
<li><p>DataWedge profile configured for barcode scanning</p></li>
</ol>

<h3 id="createtheproject" class="anchor"><a class="heading-anchor" href="#createtheproject"><span></span></a>Create The Project</h3>

<p>Start by creating a new project in Android Studio. Call it <code>Scan-Scan-Write</code> to match later references in this guide. For help, see the <a href="../../tutorials/tutCreateProjectAndroidStudio">Android Studio tutorial</a>. </p>

<h3 id="basicaddition" class="anchor"><a class="heading-anchor" href="#enableandroidpermissions"><span></span></a>Adding essentials</h3>

<p>Modify the application's <code>MainActivity.java</code> file to use the RFID SDK library.</p>

<ol>
<li><p>Declare RFID readers fields</code>:  </p>
<pre class="prettyprint"><code>
    private static Readers readers;`
    private static ArrayList<ReaderDevice> availableRFIDReaderList;
    private static ReaderDevice readerDevice;
    private static RFIDReader reader;
    private static String TAG = "DEMO";
</code></pre></li>

<li>
<p>Create SDK <code>Readers</code> instance</p>
<pre class="prettyprint"><code>
    // SDK
    if (readers == null) {
        readers = new Readers(this, ENUM_TRANSPORT.SERVICE_SERIAL);
    }
</code></pre>
<p><strong>Note :</strong> For RFD40XX USB connectivity create reader instance with</p>
<pre class="prettyprint"><code>
    readers = new Readers(this, ENUM_TRANSPORT.SERVICE_USB)
</code></pre>

<p><strong>Note :</strong> For Bluetooth instance</p>
<pre class="prettyprint"><code>
    readers = new Readers(this, ENUM_TRANSPORT.BLUETOOTH)
</code></pre>

<p><strong>Note :</strong> For TC53E/EM45/ET6x device</p>
<pre class="prettyprint"><code>
    readers = new Readers(this, ENUM_TRANSPORT.RE_SERIAL)
</code></pre>
</li>

<li>
<p>Create <code>AsyncTask</code> to retrieve available readers using <code>GetAvailableRFIDReaderList</code> </p>
<pre class="prettyprint"><code>
    new AsyncTask<Void, Void, Boolean>() {
        @Override
        protected Boolean doInBackground(Void... voids) {
            try {
                if (readers != null) {
                    if (readers.GetAvailableRFIDReaderList() != null) {
                        availableRFIDReaderList = readers.GetAvailableRFIDReaderList();
                        if (availableRFIDReaderList.size() != 0) {
                            // get first reader from list
                            readerDevice = availableRFIDReaderList.get(0);
                            reader = readerDevice.getRFIDReader();
                            if (!reader.isConnected()) {
                                // Establish connection to the RFID Reader
                                reader.connect();
                                ConfigureReader();
                                return true;
                            }
                        }
                    }
                }
            } catch (InvalidUsageException e) {
                e.printStackTrace();
            } catch (OperationFailureException e) {
                e.printStackTrace();
                Log.d(TAG, "OperationFailureException " + e.getVendorMessage());
            }
            return false;
        }

        @Override
        protected void onPostExecute(Boolean aBoolean) {
            super.onPostExecute(aBoolean);
            if (aBoolean) {
                Toast.makeText(getApplicationContext(), "Reader Connected", Toast.LENGTH_LONG).show();
                //textView.setText("Reader connected");
            }
        }
    }.execute();
</code></pre></li>


<li><p>Add <code>ConfigureReader</code> method to configure the reader for trigger type and adding event handler / listener <code>addEventsListener</code> </p>
<pre class="prettyprint"><code>
    private void ConfigureReader() {
        if (reader.isConnected()) {
            TriggerInfo triggerInfo = new TriggerInfo();
            triggerInfo.StartTrigger.setTriggerType(START_TRIGGER_TYPE.START_TRIGGER_TYPE_IMMEDIATE);
            triggerInfo.StopTrigger.setTriggerType(STOP_TRIGGER_TYPE.STOP_TRIGGER_TYPE_IMMEDIATE);
            try {
                // receive events from reader
                if (eventHandler == null)
                    eventHandler = new EventHandler();
                reader.Events.addEventsListener(eventHandler);
                // HH event
                reader.Events.setHandheldEvent(true);
                // tag event with tag data
                reader.Events.setTagReadEvent(true);
                // application will collect tag using getReadTags API
                reader.Events.setAttachTagDataWithReadEvent(false);
                // set trigger mode as rfid so scanner beam will not come
                reader.Config.setTriggerMode(ENUM_TRIGGER_MODE.RFID_MODE, true);
                // set start and stop triggers
                reader.Config.setStartTrigger(triggerInfo.StartTrigger);
                reader.Config.setStopTrigger(triggerInfo.StopTrigger);
            } catch (InvalidUsageException e) {
                e.printStackTrace();
            } catch (OperationFailureException e) {
                e.printStackTrace();
            }
        }
    }
</code></pre></li>

<li><p>Add <code>EventHandler</code> class to handle Reader operation events - <code>eventReadNotify</code> and Reader status events - <code>eventStatusNotify</code> </p>
<pre class="prettyprint"><code>
    // Read/Status Notify handler
    // Implement the RfidEventsListener class to receive event notifications
    public class EventHandler implements RfidEventsListener {
        // Read Event Notification
        public void eventReadNotify(RfidReadEvents e) {
            TagData[] tags = reader.Actions.getReadTags(100);
            int accessSuccess = 0;
            int accessFailure = 0;
            
            if (tags != null && currentState == WorkflowState.WRITING) {
                for (TagData tag : tags) {
                    Log.d(TAG, tag.getTagID() + " :: " + tag.getOpCode() + " :: " + tag.getOpStatus());
                    
                    if (tag.getOpCode() == ACCESS_OPERATION_CODE.ACCESS_OPERATION_LOCK) {
                        if (tag.getOpStatus() == ACCESS_OPERATION_STATUS.ACCESS_SUCCESS) {
                            accessSuccess++;
                            Log.d(TAG, "LOCK SUCCESS");
                        }
                    } else if (tag.getOpCode() == ACCESS_OPERATION_CODE.ACCESS_OPERATION_WRITE) {
                        if (tag.getOpStatus() == ACCESS_OPERATION_STATUS.ACCESS_SUCCESS) {
                            accessSuccess++;
                            Log.d(TAG, "WRITE SUCCESS");
                        }
                    } else if (tag.getOpCode() == ACCESS_OPERATION_CODE.ACCESS_OPERATION_READ) {
                        if (tag.getOpStatus() == ACCESS_OPERATION_STATUS.ACCESS_SUCCESS) {
                            accessSuccess++;
                            Log.d(TAG, "READ SUCCESS");
                        }
                    }
                    
                    if (tag.getOpStatus() != ACCESS_OPERATION_STATUS.ACCESS_SUCCESS) {
                        accessFailure++;
                        try {
                            reader.Actions.TagAccess.OperationSequence.deleteAll();
                        } catch (Exception ex) {
                            ex.printStackTrace();
                        }
                    }
                    
                    if (accessSuccess == 4) {
                        System.out.println(tag.getTagID() + " ALL Encoding Success ");
                        try {
                            reader.Actions.TagAccess.OperationSequence.deleteAll();
                        } catch (Exception ex) {
                            ex.printStackTrace();
                        }
                    }
                }
                
                // Update UI based on operation results
                final int finalAccessSuccess = accessSuccess;
                runOnUiThread(() -> {
                    if (finalAccessSuccess == 4) {
                        Toast.makeText(MainActivity.this,
                        "Tag written successfully!", Toast.LENGTH_LONG).show();
                    } else {
                        Toast.makeText(MainActivity.this,
                        "Tag operation failed. Only " + finalAccessSuccess + " of 4 operations succeeded",
                        Toast.LENGTH_LONG).show();
                    }
                    currentState = WorkflowState.IDLE;
                    updateStatusDisplay();
                });
            }
        }
     
        // Status Event Notification
        public void eventStatusNotify(RfidStatusEvents rfidStatusEvents) {
            Log.d(TAG, "Status Notification: " + rfidStatusEvents.StatusEventData.getStatusEventType());
        }
     
    }
    
</code></pre></li>
</ol>


<h2 id="runningapp" class="anchor"><a class="heading-anchor" href="#code1"><span></span></a>Running the application</h2>

<h3 id="basicaddition" class="anchor"><a class="heading-anchor" href="#enableandroidpermissions"><span></span></a>Connection with device</h3>

<ol>
<li><p>Connect any android terminal with PC over USB</p></li>
<li><p>Make sure project is already built successfully</p></li>
<li><p>Click on <code>Run app (shift+F10)</code> from top right corner</p></li>
<li><p>Now Application should be launched on Zebra Android device.</p></li>
<li><p>Application should be showing <code>Reader connected</code> toast message on screen</p></li>
<div style="display: flex; gap: 12px; justify-content: flex-start;">
<p><img src="../../images/CreatingProjectAndroidStudioImages/ssw1.png" alt="img" style="max-width:200px; height:400px;"></p>
<p><img src="../../images/CreatingProjectAndroidStudioImages/ssw2.png" alt="img" style="max-width:200px; height:400px;"></p>
<p><img src="../../images/CreatingProjectAndroidStudioImages/ssw3.png" alt="img" style="max-width:200px; height:400px;"></p>
</div>
</ol>

<h2 id="tips" class="anchor"><a class="heading-anchor" href="#tips"><span></span></a>Programming tips</h2>
<ol>
<li><p> <code>GetAvailableRFIDReaderList</code> must be called from background thread, in current example uses <code>AsyncTask</code> for same purpose</p></li>
<li><p>At time of exit, application shounld disconnect with reader using <code>Disconnect</code> API and free up SDK instance. Refer MainActivity <code>OnDestroy</code> method </p></li>
<li><p>In case of failures or exceptions, refer messages returned by API call to get more details</p></li>
</ol>

<h2 id="whatsnext" class="anchor"><a class="heading-anchor" href="#whatsnext"><span></span></a>What's Next</h2>

<p>Add code to perfrom Scan-Scan-Write.</p>
<ol>
<li><p>Create states to track the multi-step operation.</p>
<pre class="prettyprint"><code>
    // State tracking for scan-scan-write workflow
    private enum WorkflowState {
        IDLE,              // Waiting to start
        FIRST_BARCODE_SCANNED, // First barcode scanned, waiting for RFID tag barcode
        SECOND_BARCODE_SCANNED, // Tag ID scanned, ready to write
        WRITING            // Writing in progress
    }

    private WorkflowState currentState = WorkflowState.IDLE;
    private String scannedBarcode = null;
    private String scannedTagId = null;
    private EPC encodedEpc = null;
    private TextView statusTextView;
    private final String ACCESS_PASSWORD = "00000000";

</code></pre></li>

<li><p>Initialize Components</p>
    <p>Set up the required components in the onCreate() method</p>
<pre class="prettyprint"><code>
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    
        // Initialize the status TextView
        statusTextView = findViewById(R.id.statusTextView);
    
        // Initialize RFID reader
        if (readers == null) {
            readers = new Readers(this, ENUM_TRANSPORT.SERVICE_USB);
        }
        // Connect to the RFID reader
        new ConnectionTask().execute();
    
        // Initialize barcode to RFID conversion API
        BarcodeToRfidApi.initialize(this);
    
        // Register the barcode receiver
        IntentFilter filter = new IntentFilter();
        filter.addAction(DataWedge.INTENT_NAME);
        filter.addCategory(Intent.CATEGORY_DEFAULT);
        registerReceiver(barcodeReceiver, filter, Context.RECEIVER_EXPORTED);
    
        // Set up scan-scan-write button
        Button btnScanScanWrite = findViewById(R.id.btnScanScanWrite);
        btnScanScanWrite.setOnClickListener(v -> {
            if (reader != null && reader.isConnected()) {
                // Reset the workflow
                currentState = WorkflowState.IDLE;
                scannedBarcode = null;
                scannedTagId = null;
                encodedEpc = null;
                updateStatusDisplay();
                // Start the workflow - trigger barcode scanner
                startBarcodeScanning();
            } else {
                Toast.makeText(this, "RFID Reader not connected", Toast.LENGTH_SHORT).show();
            }
        });
    }
</code></pre></li>

<li><p>Barcode Scanning</p>
    <p>Trigger the barcode scanner using DataWedge</p>
<pre class="prettyprint"><code>
    private void startBarcodeScanning() {
        // Trigger DataWedge scanner
        Intent dwIntent = new Intent();
        dwIntent.setAction("com.symbol.datawedge.api.ACTION");
        dwIntent.putExtra("com.symbol.datawedge.api.SOFT_SCAN_TRIGGER", "START_SCANNING");
        sendBroadcast(dwIntent);
        Toast.makeText(this, "Please scan a barcode", Toast.LENGTH_SHORT).show();
    }    
</code></pre></li>

<li><p>Processing Barcode Scans</p>
    <p>Create a BroadcastReceiver to handle barcode scan results</p>
<pre class="prettyprint"><code>
    private final BroadcastReceiver barcodeReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
    
            if (action != null && action.equals(DataWedge.INTENT_NAME)) {
                // Barcode scan from DataWedge
                String barcode = intent.getStringExtra(DataWedge.DATAWEDGE_EXTRA);
    
                if (barcode != null && !barcode.isEmpty()) {
                   Log.d(TAG, "Scanned barcode: " + barcode);
    
                    // Stop barcode scanner
                    Intent dwIntent = new Intent();
                    dwIntent.setAction("com.symbol.datawedge.api.ACTION");
                    dwIntent.putExtra("com.symbol.datawedge.api.SOFT_SCAN_TRIGGER", "STOP_SCANNING");
                    context.sendBroadcast(dwIntent);
    
                    // Process based on current state
                    if (currentState == WorkflowState.IDLE) {
                        // First barcode scan - product barcode
                        try {
                            // Process the barcode with BarcodeToRfidApi
                            encodedEpc = BarcodeToRfidApi.encodeBarcodeToRfid(barcode, "1234567890");
                            Log.d(TAG, "Encoded EPC: " + encodedEpc.toString());
    
                            // Store barcode and update state
                            scannedBarcode = barcode;
                            currentState = WorkflowState.FIRST_BARCODE_SCANNED;
                            updateStatusDisplay();
    
                            // Start second barcode scan after a short delay
                            new Handler().postDelayed(() -> startBarcodeScanning(), 1000);
                        } catch (Exception e) {
                            Log.e(TAG, "Error processing barcode", e);
                            Toast.makeText(context, "Error processing barcode: " + e.getMessage(),
                                    Toast.LENGTH_SHORT).show();
                            currentState = WorkflowState.IDLE;
                            updateStatusDisplay();
                        }
                    }
                    else if (currentState == WorkflowState.FIRST_BARCODE_SCANNED) {
                        // Second barcode scan - RFID tag ID
                        scannedTagId = barcode;
                        currentState = WorkflowState.SECOND_BARCODE_SCANNED;
                        updateStatusDisplay();
    
                        // Ask user to confirm write
                        runOnUiThread(() -> {
                            AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this);
                            builder.setTitle("Confirm Write");
                            builder.setMessage("Write EPC " + encodedEpc.toString() + " to tag " + scannedTagId + "?");
                            builder.setPositiveButton("Write", (dialog, which) -> {
                                unlockAndWriteEpcToTag(scannedTagId, encodedEpc);
                            });
                            builder.setNegativeButton("Cancel", (dialog, which) -> {
                                currentState = WorkflowState.IDLE;
                                updateStatusDisplay();
                            });
                            builder.show();
                        });
                    }
                }
            }
        }
    };       
</code></pre></li>

<li><p>Converting Barcode to RFID EPC Format</p>
    <p>The BarcodeToRfidApi class provides the interface between barcode data and RFID EPC format</p>
<pre class="prettyprint"><code>
    public class BarcodeToRfidApi {
        public static void initialize(Context context) {
            EPCConverter.initEpcConverter(context);
            DataWedge.setDWProfile(context);
        }
    
        public static EPC encodeBarcodeToRfid(String scannedUpc, String serialNumber) {
            EPC epc = EPCConverter.encodeSGTIN96(scannedUpc, serialNumber);
            return epc;
        }
    }
</code></pre></li>

<pre class="prettyprint"><code>
    package com.zebra.ssw.EncodeBarcodeToRFID;

    import androidx.annotation.NonNull;
    import java.io.Serializable;

    public class EPC implements Serializable {

        public static final EPC DEFAULT = new EPC("0000000000000");

        private final String content;

        public EPC(String s) {
            content = s.toUpperCase();
        }
    }
</code></pre></li>

<li><p>Create a filter to specify which tags should be operated on</p>
<pre class="prettyprint"><code>
    private AccessFilter setAccessFilter(String tagID) {
        int len = tagID.length()/2;
        AccessFilter accessFilter = new AccessFilter();
        byte[] tagMask = new byte[len];
        byte[] tagData = hexStringToByteArray(tagID);
        for(int i= 0; i < len; i++){
            tagMask[i] = (byte)0xff;
        }
    
        // Tag Pattern A
        accessFilter.TagPatternA.setMemoryBank(MEMORY_BANK.MEMORY_BANK_EPC);
        accessFilter.TagPatternA.setTagPattern(tagData);
        accessFilter.TagPatternA.setTagPatternBitCount(len*8);
        accessFilter.TagPatternA.setBitOffset(32);
        accessFilter.TagPatternA.setTagMask(tagMask);
        accessFilter.TagPatternA.setTagMaskBitCount(tagMask.length*8);
        accessFilter.setAccessFilterMatchPattern(FILTER_MATCH_PATTERN.A);
        return accessFilter;
    }
</code></pre></li>

<li><p>Writing to RFID Tag</p>
    <p>Perform the write operation using a sequence of RFID tag access operations</p>
<pre class="prettyprint"><code>
    private void unlockAndWriteEpcToTag(String tagId, EPC newEpc) {
        currentState = WorkflowState.WRITING;
        updateStatusDisplay();
    
        try {
            //operation sequence for unlock-write-lock
            performTagOperationSequence(tagId, newEpc.toString());
            Log.d(TAG, "Tag operation sequence started successfully");
    
        } catch (InvalidUsageException | OperationFailureException e) {
            Log.e(TAG, "Error in tag operation sequence", e);
            runOnUiThread(() -> Toast.makeText(MainActivity.this,
                    "Error: " + e.getMessage(), Toast.LENGTH_LONG).show());
            currentState = WorkflowState.IDLE;
            updateStatusDisplay();
        }
    }    
</code></pre></li>

<li><p>RFID Access Sequence Operation</p>
    <p>Define the sequence of operations to unlock, write, and lock the RFID tag</p>
<pre class="prettyprint"><code>
    private void performTagOperationSequence(String tagId, String epcData)
        throws OperationFailureException, InvalidUsageException {

        Log.d(TAG, "Starting operation sequence for tag: " + tagId);
        long accessPassword = Long.parseLong(ACCESS_PASSWORD, 16);

        try {
            reader.Actions.TagAccess.OperationSequence.deleteAll();
        } catch (Exception e) {
            Log.w(TAG, "Error clearing operation sequence", e);
        }

        TagAccess tagAccess = reader.Actions.TagAccess;
        TagAccess.Sequence opSequence = tagAccess.new Sequence(tagAccess);

        // Operation 1: Read TID memory bank
        TagAccess.Sequence.Operation op1 = opSequence.new Operation();
        op1.setAccessOperationCode(ACCESS_OPERATION_CODE.ACCESS_OPERATION_READ);
        op1.ReadAccessParams.setMemoryBank(MEMORY_BANK.MEMORY_BANK_TID);
        op1.ReadAccessParams.setCount(1);
        op1.ReadAccessParams.setOffset(0);
        reader.Actions.TagAccess.OperationSequence.add(op1);

        // Operation 2: Unlock the EPC Memory
        TagAccess.Sequence.Operation unlockOp = opSequence.new Operation();
        unlockOp.setAccessOperationCode(ACCESS_OPERATION_CODE.ACCESS_OPERATION_LOCK);
        unlockOp.LockAccessParams.setLockPrivilege(LOCK_DATA_FIELD.LOCK_EPC_MEMORY,
                LOCK_PRIVILEGE.LOCK_PRIVILEGE_UNLOCK);
        unlockOp.LockAccessParams.setAccessPassword(Long.decode("0X" + accessPassword));
        reader.Actions.TagAccess.OperationSequence.add(unlockOp);

        // Operation 3: Write EPC to tag
        TagAccess.Sequence.Operation writeOp = opSequence.new Operation();
        writeOp.setAccessOperationCode(ACCESS_OPERATION_CODE.ACCESS_OPERATION_WRITE);
        writeOp.WriteAccessParams.setMemoryBank(MEMORY_BANK.MEMORY_BANK_EPC);
        writeOp.WriteAccessParams.setOffset(2);
        writeOp.WriteAccessParams.setWriteData(epcData);
        writeOp.WriteAccessParams.setWriteDataLength(epcData.length()/4);
        reader.Actions.TagAccess.OperationSequence.add(writeOp);

        // Operation 4: Lock the EPC Memory
        TagAccess.Sequence.Operation lockOp = opSequence.new Operation();
        lockOp.setAccessOperationCode(ACCESS_OPERATION_CODE.ACCESS_OPERATION_LOCK);
        lockOp.LockAccessParams.setLockPrivilege(LOCK_DATA_FIELD.LOCK_EPC_MEMORY,
                LOCK_PRIVILEGE.LOCK_PRIVILEGE_READ_WRITE);
        lockOp.LockAccessParams.setAccessPassword(Long.decode("0X" + accessPassword));
        reader.Actions.TagAccess.OperationSequence.add(lockOp);

        // Execute the sequence on the specific tag
        reader.Actions.TagAccess.OperationSequence.performSequence(setAccessFilter(tagId), null, null);
    }
</code></pre></li>

</ol>
                                
<h2 id="fullapp" class="anchor"><a class="heading-anchor" href="#fullapp"><span></span></a>Complete Implementation</h2>

<p>Below is the complete implementation which combines all the code snippets discussed earlier. This class handles RFID reader initialization, connection, configuration, event handling, and performs scan-scan-write. Key features include:</p>

<ul>
<li><b>MainActivity:</b> Manages the workflow and RFID operations. Controls the UI state transitions and implements the scan-scan-write process flow. Handles RFID reader connections and events, including tag access operations.</li>
<li><b>EPCConverter:</b> Converts barcode formats to RFID EPC format. Contains algorithms to properly encode UPC product codes into standardized SGTIN-96 EPC format following GS1 specifications.</li>
<li><b>DataWedge:</b> Handles barcode scanning integration. Provides constants and methods to communicate with Zebra's DataWedge service for triggering barcode scans and receiving scan results.</li>
<li><b>EPC:</b> Represents an Electronic Product Code used in RFID tags. Contains the data structure and formatting rules for EPCs, supporting different encoding schemes and providing string representation methods for display and debugging.</li>
</ul>

<h3 id="fullapp" class="anchor"><a class="heading-anchor" href="#fullapp"><span></span></a>Complete MainActivity.java Implementation</h3>
<pre class="prettyprint"><code>
    package com.zebra.ssw;

    import androidx.appcompat.app.AppCompatActivity;
    import android.os.AsyncTask;
    import android.os.Bundle;
    import android.util.Log;
    import android.widget.Button;
    import android.widget.TextView;
    import android.widget.Toast;
    import android.content.BroadcastReceiver;
    import android.content.Context;
    import android.content.Intent;
    import android.content.IntentFilter;
    import com.zebra.ssw.EncodeBarcodeToRFID.DataWedge;
    import com.zebra.ssw.EncodeBarcodeToRFID.EPC;
    import com.zebra.rfid.api3.ACCESS_OPERATION_CODE;
    import com.zebra.rfid.api3.ACCESS_OPERATION_STATUS;
    import com.zebra.rfid.api3.AccessFilter;
    import com.zebra.rfid.api3.ENUM_TRANSPORT;
    import com.zebra.rfid.api3.FILTER_MATCH_PATTERN;
    import com.zebra.rfid.api3.InvalidUsageException;
    import com.zebra.rfid.api3.LOCK_DATA_FIELD;
    import com.zebra.rfid.api3.LOCK_PRIVILEGE;
    import com.zebra.rfid.api3.MEMORY_BANK;
    import com.zebra.rfid.api3.OperationFailureException;
    import com.zebra.rfid.api3.RFIDReader;
    import com.zebra.rfid.api3.ReaderDevice;
    import com.zebra.rfid.api3.Readers;
    import com.zebra.rfid.api3.RfidEventsListener;
    import com.zebra.rfid.api3.RfidReadEvents;
    import com.zebra.rfid.api3.RfidStatusEvents;
    import com.zebra.rfid.api3.TagAccess;
    import com.zebra.rfid.api3.TagData;
    import java.security.InvalidParameterException;
    import java.util.ArrayList;
    import android.app.AlertDialog;
    import android.os.Handler;
    
    public class MainActivity extends AppCompatActivity {
    
        private  final String TAG = "sswApp";
        private Readers readers;
        private ReaderDevice readerDevice;
        private EventHandler eventHandler;
    
    
        // State tracking for scan-scan-write workflow
        private enum WorkflowState {
            IDLE,              // Waiting to start
            FIRST_BARCODE_SCANNED, // First barcode scanned, waiting for RFID tag barcode
            SECOND_BARCODE_SCANNED, // Tag ID scanned, ready to write
            WRITING            // Writing in progress
        }
    
        private WorkflowState currentState = WorkflowState.IDLE;
        private String scannedBarcode = null;
        private String scannedTagId = null;
        private EPC encodedEpc = null;
        private TextView statusTextView;
        private final String ACCESS_PASSWORD = "00000000";
    
        static RFIDReader reader;
        private ArrayList<ReaderDevice> availableRFIDReaderList;
    
        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main);
    
            // Initialize the status TextView
            statusTextView = findViewById(R.id.statusTextView);
    
            if (readers == null) {
                readers = new Readers(this, ENUM_TRANSPORT.SERVICE_USB);
            }
            System.out.println("Connection BEGINS");
            new ConnectionTask().execute();
    
    
            BarcodeToRfidApi.initialize(this);
    
            // Register the barcode receiver
            IntentFilter filter = new IntentFilter();
            filter.addAction(DataWedge.INTENT_NAME);
            filter.addCategory(Intent.CATEGORY_DEFAULT);
            registerReceiver(barcodeReceiver, filter, Context.RECEIVER_EXPORTED);
    
    
            //scan-scan-write button
            Button btnScanScanWrite = findViewById(R.id.btnScanScanWrite);
            btnScanScanWrite.setOnClickListener(v -> {
                if (reader != null && reader.isConnected()) {
                    // Reset the workflow
                    currentState = WorkflowState.IDLE;
                    scannedBarcode = null;
                    scannedTagId = null;
                    encodedEpc = null;
                    updateStatusDisplay();
                    // Start the workflow - trigger barcode scanner
                    startBarcodeScanning();
                } else {
                    Toast.makeText(this, "RFID Reader not connected", Toast.LENGTH_SHORT).show();
                }
            });
        }
    
    
        @Override
        protected void onPause() {
            super.onPause();
            // Unregister barcode receiver
            try {
                unregisterReceiver(barcodeReceiver);
            } catch (IllegalArgumentException e) {
                // Receiver not registered
            }
        }
    
        private void updateStatusDisplay() {
            runOnUiThread(() -> {
                // Null check to avoid crashes
                if (statusTextView == null) {
                    Log.e(TAG, "Status TextView not initialized!");
                    return;
                }
    
                switch (currentState) {
                    case IDLE:
                        statusTextView.setText("Ready to scan product barcode");
                        break;
                    case FIRST_BARCODE_SCANNED:
                        statusTextView.setText("Product barcode scanned: " + scannedBarcode +
                                "\nNow scan RFID tag barcode");
                        break;
                    case SECOND_BARCODE_SCANNED:
                        statusTextView.setText("Product barcode: " + scannedBarcode +
                                "\nTag ID: " + scannedTagId +
                                "\nReady to write");
                        break;
                    case WRITING:
                        statusTextView.setText("Writing to tag...");
                        break;
                }
            });
        }
    
    
        private void startBarcodeScanning() {
            // Trigger DataWedge scanner
            Intent dwIntent = new Intent();
            dwIntent.setAction("com.symbol.datawedge.api.ACTION");
            dwIntent.putExtra("com.symbol.datawedge.api.SOFT_SCAN_TRIGGER", "START_SCANNING");
            sendBroadcast(dwIntent);
            Toast.makeText(this, "Please scan a barcode", Toast.LENGTH_SHORT).show();
        }
    
        private final BroadcastReceiver barcodeReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                String action = intent.getAction();
    
                if (action != null && action.equals(DataWedge.INTENT_NAME)) {
                    // Barcode scan from DataWedge
                    String barcode = intent.getStringExtra(DataWedge.DATAWEDGE_EXTRA);
    
                    if (barcode != null && !barcode.isEmpty()) {
                        Log.d(TAG, "Scanned barcode: " + barcode);
    
                        // Stop barcode scanner
                        Intent dwIntent = new Intent();
                        dwIntent.setAction("com.symbol.datawedge.api.ACTION");
                        dwIntent.putExtra("com.symbol.datawedge.api.SOFT_SCAN_TRIGGER", "STOP_SCANNING");
                        context.sendBroadcast(dwIntent);
    
                        // Process based on current state
                        if (currentState == WorkflowState.IDLE) {
                            // First barcode scan - product barcode
                            try {
                                // Process the barcode with BarcodeToRfidApi
                                encodedEpc = BarcodeToRfidApi.encodeBarcodeToRfid(barcode, "1234567890");
                                Log.d(TAG, "Encoded EPC: " + encodedEpc.toString());
    
                                // Store barcode and update state
                                scannedBarcode = barcode;
                                currentState = WorkflowState.FIRST_BARCODE_SCANNED;
                                updateStatusDisplay();
    
                                // Start second barcode scan after a short delay
                                new Handler().postDelayed(() -> startBarcodeScanning(), 1000);
                            } catch (Exception e) {
                                Log.e(TAG, "Error processing barcode", e);
                                Toast.makeText(context, "Error processing barcode: " + e.getMessage(),
                                        Toast.LENGTH_SHORT).show();
                                currentState = WorkflowState.IDLE;
                                updateStatusDisplay();
                            }
                        }
                        else if (currentState == WorkflowState.FIRST_BARCODE_SCANNED) {
                            // Second barcode scan - RFID tag ID
                            scannedTagId = barcode;
                            currentState = WorkflowState.SECOND_BARCODE_SCANNED;
                            updateStatusDisplay();
    
                            // Ask user to confirm write
                            runOnUiThread(() -> {
                                AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this);
                                builder.setTitle("Confirm Write");
                                builder.setMessage("Write EPC " + encodedEpc.toString() + " to tag " + scannedTagId + "?");
                                builder.setPositiveButton("Write", (dialog, which) -> {
                                    unlockAndWriteEpcToTag(scannedTagId, encodedEpc);
                                });
                                builder.setNegativeButton("Cancel", (dialog, which) -> {
                                    currentState = WorkflowState.IDLE;
                                    updateStatusDisplay();
                                });
                                builder.show();
                            });
                        }
                    }
                }
            }
        };
    
    
        private void unlockAndWriteEpcToTag(String tagId, EPC newEpc) {
            currentState = WorkflowState.WRITING;
            updateStatusDisplay();
    
            try {
                //operation sequence for unlock-write-lock
                performTagOperationSequence(tagId, newEpc.toString());
                Log.d(TAG, "Tag operation sequence started successfully");
    
            } catch (InvalidUsageException | OperationFailureException e) {
                Log.e(TAG, "Error in tag operation sequence", e);
                runOnUiThread(() -> Toast.makeText(MainActivity.this,
                        "Error: " + e.getMessage(), Toast.LENGTH_LONG).show());
                currentState = WorkflowState.IDLE;
                updateStatusDisplay();
            }
        }
    
        private void performTagOperationSequence(String tagId, String epcData)
                throws OperationFailureException, InvalidUsageException {
    
            Log.d(TAG, "Starting operation sequence for tag: " + tagId);
            long accessPassword = Long.parseLong(ACCESS_PASSWORD, 16);
    
            try {
                reader.Actions.TagAccess.OperationSequence.deleteAll();
            } catch (Exception e) {
                Log.w(TAG, "Error clearing operation sequence", e);
            }
    
            TagAccess tagAccess = reader.Actions.TagAccess;
            TagAccess.Sequence opSequence = tagAccess.new Sequence(tagAccess);
    
            TagAccess.Sequence.Operation op1 = opSequence.new Operation();
            op1.setAccessOperationCode(ACCESS_OPERATION_CODE.ACCESS_OPERATION_READ);
            op1.ReadAccessParams.setMemoryBank(MEMORY_BANK.MEMORY_BANK_TID);
            op1.ReadAccessParams.setCount(1);
            op1.ReadAccessParams.setOffset(0);
            reader.Actions.TagAccess.OperationSequence.add(op1);
    
            //operation 1: Unlock the EPC Memory
            TagAccess.Sequence.Operation unlockOp = opSequence.new Operation();
            unlockOp.setAccessOperationCode(ACCESS_OPERATION_CODE.ACCESS_OPERATION_LOCK);
            unlockOp.LockAccessParams.setLockPrivilege(LOCK_DATA_FIELD.LOCK_EPC_MEMORY,
                    LOCK_PRIVILEGE.LOCK_PRIVILEGE_UNLOCK);
            unlockOp.LockAccessParams.setAccessPassword(Long.decode("0X" + accessPassword));
            reader.Actions.TagAccess.OperationSequence.add(unlockOp);
    
            //operation 2: Write EPC to tag
            TagAccess.Sequence.Operation writeOp = opSequence.new Operation();
            writeOp.setAccessOperationCode(ACCESS_OPERATION_CODE.ACCESS_OPERATION_WRITE);
            writeOp.WriteAccessParams.setMemoryBank(MEMORY_BANK.MEMORY_BANK_EPC);
            writeOp.WriteAccessParams.setOffset(2);
            writeOp.WriteAccessParams.setWriteData(epcData);
            writeOp.WriteAccessParams.setWriteDataLength(epcData.length()/4);
            reader.Actions.TagAccess.OperationSequence.add(writeOp);
    
            //operation 3: Lock the EPC Memory
            TagAccess.Sequence.Operation lockOp = opSequence.new Operation();
            lockOp.setAccessOperationCode(ACCESS_OPERATION_CODE.ACCESS_OPERATION_LOCK);
            lockOp.LockAccessParams.setLockPrivilege(LOCK_DATA_FIELD.LOCK_EPC_MEMORY,
                    LOCK_PRIVILEGE.LOCK_PRIVILEGE_READ_WRITE);
            lockOp.LockAccessParams.setAccessPassword(Long.decode("0X" + accessPassword));
            reader.Actions.TagAccess.OperationSequence.add(lockOp);
    
            // Execute the sequence on the specific tag
            reader.Actions.TagAccess.OperationSequence.performSequence(setAccessFilter(tagId), null, null);
        }
    
    
        //Utility functions
        private AccessFilter setAccessFilter(String tagID) {
            int len = tagID.length()/2;
            AccessFilter accessFilter = new AccessFilter();
            byte[] tagMask = new byte[len];
            byte[] tagData = hexStringToByteArray(tagID);
            for(int i= 0; i < len; i++){
                tagMask[i] = (byte)0xff;
            }
    
            // Tag Pattern A
            accessFilter.TagPatternA.setMemoryBank(MEMORY_BANK.MEMORY_BANK_EPC);
            accessFilter.TagPatternA.setTagPattern(tagData);
            accessFilter.TagPatternA.setTagPatternBitCount(len*8);
            accessFilter.TagPatternA.setBitOffset(32);
            accessFilter.TagPatternA.setTagMask(tagMask);
            accessFilter.TagPatternA.setTagMaskBitCount(tagMask.length*8);
            accessFilter.setAccessFilterMatchPattern(FILTER_MATCH_PATTERN.A);
            return accessFilter;
        }
    
        public static byte[] hexStringToByteArray(String hexString) {
            int length = hexString.length();
            byte[] buffer = new byte[length / 2];
    
            for (int i = 0; i < length; i += 2) {
                buffer[i / 2] = (byte) ((toByte(hexString.charAt(i)) << 4) | toByte(hexString
                        .charAt(i + 1)));
            }
    
            return buffer;
        }
        private static int toByte(char c) {
            if (c >= '0' && c <= '9')
                return (c - '0');
            if (c >= 'A' && c <= 'F')
                return (c - 'A' + 10);
            if (c >= 'a' && c <= 'f')
                return (c - 'a' + 10);
    
            throw new InvalidParameterException("Invalid hex char '" + c + "'");
        }
    
        private class ConnectionTask extends AsyncTask<Void, Void, Boolean> {
            protected Boolean doInBackground(Void... voids) {
                try {
                    if (readers != null) {
                        System.out.println("Connection start");
                        if (readers.GetAvailableRFIDReaderList() != null) {
                            availableRFIDReaderList = readers.GetAvailableRFIDReaderList();
                            if (availableRFIDReaderList.size() != 0) {
                                // get first reader from list
                                readerDevice = availableRFIDReaderList.get(0);
                                reader = readerDevice.getRFIDReader();
                                if (!reader.isConnected()) {
                                    reader.connect();
                                    ConfigureReader();
    
                                    System.out.println("Reader Capabilities = "+ reader.ReaderCapabilities.getFirwareVersion());
    
    
                                    return true;
                                }
                            }
                        }
                    }
                } catch (InvalidUsageException e) {
                    e.printStackTrace();
                } catch (OperationFailureException e) {
                    e.printStackTrace();
                    Log.d("Demo", "OperationFailureException " + e.getVendorMessage());
                }
                return false;
            }
    
            protected void onPostExecute(Boolean aBoolean) {
                super.onPostExecute(aBoolean);
                if (aBoolean) {
                    Toast.makeText(getApplicationContext(), "Reader Connected", Toast.LENGTH_LONG).show();
                }
            }
        }
    
        private void ConfigureReader() {
            if (reader.isConnected()) {
    
                try {
                    if (eventHandler == null)
                        eventHandler = new EventHandler();
                    reader.Events.addEventsListener(eventHandler);
                    reader.Events.setHandheldEvent(true);
                    reader.Events.setTagReadEvent(true);
                    reader.Events.setReaderDisconnectEvent(true);
                    reader.Events.setInventoryStartEvent(true);
                    reader.Events.setInventoryStopEvent(true);
                    reader.Events.setAttachTagDataWithReadEvent(false);
                } catch (InvalidUsageException e) {
                    e.printStackTrace();
                } catch (OperationFailureException e) {
                    e.printStackTrace();
                }
            }
        }
    
    
        class EventHandler implements RfidEventsListener {
            public void eventReadNotify(RfidReadEvents e) {
                TagData[] tags = reader.Actions.getReadTags(100);
                int accessSuccess = 0;
                int accessFailure = 0;
    
                if (tags != null && currentState == WorkflowState.WRITING) {
                    for (TagData tag : tags) {
                        Log.d(TAG, tag.getTagID() + " :: " + tag.getOpCode() + " :: " + tag.getOpStatus());
    
                        if (tag.getOpCode() == ACCESS_OPERATION_CODE.ACCESS_OPERATION_LOCK) {
                            if (tag.getOpStatus() == ACCESS_OPERATION_STATUS.ACCESS_SUCCESS) {
                                accessSuccess++;
                                Log.d(TAG, "LOCK SUCCESS");
                            }
                        } else if (tag.getOpCode() == ACCESS_OPERATION_CODE.ACCESS_OPERATION_WRITE) {
                            if (tag.getOpStatus() == ACCESS_OPERATION_STATUS.ACCESS_SUCCESS) {
                                accessSuccess++;
                                Log.d(TAG, "WRITE SUCCESS");
                            }
                        } else if (tag.getOpCode() == ACCESS_OPERATION_CODE.ACCESS_OPERATION_READ) {
                            if (tag.getOpStatus() == ACCESS_OPERATION_STATUS.ACCESS_SUCCESS) {
                                accessSuccess++;
                                Log.d(TAG, "READ SUCCESS");
                            }
                        }
    
                        if (tag.getOpStatus() != ACCESS_OPERATION_STATUS.ACCESS_SUCCESS) {
                            accessFailure++;
                            try {
                                reader.Actions.TagAccess.OperationSequence.deleteAll();
                            } catch (InvalidUsageException ex) {
                                ex.printStackTrace();
                            } catch (final OperationFailureException ex) {
                                ex.printStackTrace();
                            }
                        }
    
                        if (accessSuccess == 4) {
                            System.out.println(tag.getTagID() + " ALL Encoding Success ");
                            try {
                                reader.Actions.TagAccess.OperationSequence.deleteAll();
                            } catch (InvalidUsageException ex) {
                                ex.printStackTrace();
                            } catch (final OperationFailureException ex) {
                                ex.printStackTrace();
                            }
                        }
                    }
    
                    Log.d(TAG, "ACCESS SUCCESS: " + accessSuccess);
                    Log.d(TAG, "NOT ACCESS SUCCESS: " + accessFailure);
    
                    // Update UI based on operation results
                    final int finalAccessSuccess = accessSuccess;
                    runOnUiThread(() -> {
                        if (finalAccessSuccess == 4) {
                            Toast.makeText(MainActivity.this,
                                    "Tag written successfully!", Toast.LENGTH_LONG).show();
                        } else {
                            Toast.makeText(MainActivity.this,
                                    "Tag operation failed. Only " + finalAccessSuccess + " of 4 operations succeeded",
                                    Toast.LENGTH_LONG).show();
                        }
                        currentState = WorkflowState.IDLE;
                        updateStatusDisplay();
                    });
                }
            }
    
            public void eventStatusNotify(RfidStatusEvents rfidStatusEvents) {
                Log.d(TAG, "Status Notification: " + rfidStatusEvents.StatusEventData.getStatusEventType());
            }
        }
    
    
    
        @Override
        protected void onDestroy() {
            super.onDestroy();
            // Unregister barcode receiver
            try {
                unregisterReceiver(barcodeReceiver);
            } catch (IllegalArgumentException e) {
                // Receiver not registered, ignore
            }
    
            // Disconnect RFID reader
            if (reader != null && reader.isConnected()) {
                try {
                    reader.disconnect();
                } catch (Exception e) {
                    Log.e(TAG, "Error disconnecting reader", e);
                }
            }
        }
    }
</code></pre>

<h3 id="fullapp" class="anchor"><a class="heading-anchor" href="#fullapp"><span></span></a>Complete EPCConverter.java Implementation</h3>
<pre class="prettyprint"><code>

    package com.zebra.ssw.EncodeBarcodeToRFID;

    import android.content.Context;
    import android.util.Log;
    import org.json.JSONArray;
    import org.json.JSONObject;
    import java.io.IOException;
    import java.io.InputStream;
    import java.math.BigInteger;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.concurrent.CompletableFuture;

    public class EPCConverter {

        //Note: This may only be valid for the SGTIN-96 scheme

        // The number of bits used to store the company prefix in the EPC depending on the partition value
        private static final int[] COMPANY_PREFIX_BITS = {40, 37, 34, 30, 27, 24, 20};

        // The number of digits in the company prefix depending on the partition value
        private static final int[] COMPANY_PREFIX_DIGITS = {12, 11, 10, 9, 8, 7, 6};

        // The number of bits used to store the item reference in the EPC depending on the partition value
        private static final int[] ITEM_REF_BITS = {4, 7, 10, 14, 17, 20, 24};

        // Header
        private static final String SGTIN96_HEADER = "00110000"; // SGTIN-96 Header
        // Filter Value
        private static final String FILTER = "001"; // POS Item Filter Value

        private static Map<String, Integer> prefixMap;

        private static final Object usageLock = new Object();

        private EPCConverter() {}

        public static void initEpcConverter(Context context) {
            // Do this synchronously instead of async
            synchronized (usageLock) {
                String jsonData = loadJSONFromAsset(context);
                prefixMap = buildPrefixMap(jsonData);
                Log.d("EPCConverter", "Prefix map initialized with " +
                        (prefixMap != null ? prefixMap.size() : 0) + " entries");
            }
        }

        /**
        * This method encodes the given GTIN (Global Trade Item Number) and serial number into SGTIN-96 format.
        *
        * @param gtin - The Global Trade Item Number.
        * @param serialNumber - The serial number.
        * @return The encoded SGTIN-96 in hexadecimal format.
        */
        public static EPC encodeSGTIN96(String gtin, String serialNumber){
            synchronized (usageLock) {
                if (gtin.length() < 14) { // Pad gtin string to 14 characters
                    gtin = new String(new char[14 - gtin.length()]).replace('\0', '0').concat(gtin);
                }

                Log.v("EPCConverter", "GTIN: " + gtin);

                try {

                    // Get the length of the prefix in the GTIN
                    int gcpLength = getPrefixLength(prefixMap, gtin);
                    Log.d("EPCConverter", "GCP Len: " + gcpLength);

                    // Get the partition value which is dependent on the length of the prefix
                    int partitionValue = getPartition(gcpLength);
                    Log.d("EPCConverter", "Partition Val: " + partitionValue);

                    // Extract the company prefix from the GTIN
                    String companyPrefix = gtin.substring(1, gcpLength + 1);

                    // Extract the item reference from the GTIN
                    String itemReference = gtin.charAt(0) + gtin.substring(gcpLength + 1, 13);
                    Log.d("EPCConverter", companyPrefix + "    " + itemReference);

                    // Convert the partition value to binary format
                    String partitionBinary = String.format("%3s", Integer.toBinaryString(partitionValue)).replace(' ', '0');

                    // Convert the company prefix to binary format
                    String companyPrefixBinary = String.format("%" + getCompanyPrefixBits(partitionValue) + "s", Long.toBinaryString(Long.parseLong(companyPrefix))).replace(' ', '0');

                    // Convert the item reference to binary format
                    String itemReferenceBinary = String.format("%" + getItemReferenceBits(partitionValue) + "s", Long.toBinaryString(Long.parseLong(itemReference))).replace(' ', '0');

                    // Convert the serial number to binary format
                    String serialNumberBinary = String.format("%38s", Long.toBinaryString(Long.parseLong(serialNumber))).replace(' ', '0');

                    // Combine all the binary strings to form the complete SGTIN-96 binary string
                    String sgtin96Binary = SGTIN96_HEADER + FILTER + partitionBinary + companyPrefixBinary + itemReferenceBinary + serialNumberBinary;

                    // Convert the binary string to hexadecimal format
                    StringBuilder hex = new StringBuilder();
                    for (int i = 0; i < sgtin96Binary.length(); i += 4) {
                        String chunk = sgtin96Binary.substring(i, i + 4);
                        hex.append(Integer.toString(Byte.parseByte(chunk, 2), 16));
                    }

                    // Return the hexadecimal string in uppercase
                    EPC epc = new EPC(hex.toString().toUpperCase());
                    return epc;
                } catch (Exception e) {
                    Log.d("ENCODE", e.getMessage());
                    return EPC.DEFAULT;
                }
            }
        }

        /**
        * This method returns the partition value which is dependent on the prefix length.
        *
        * @param prefixLength - The length of the prefix in the GTIN.
        * @return The partition value.
        */
        public static int getPartition(int prefixLength){
            switch (prefixLength) {
                case 12: return 0;
                case 11: return 1;
                case 10: return 2;
                case 9: return 3;
                case 8: return 4;
                case 7: return 5;
                case 6: return 6;
                default: throw new IllegalArgumentException("Invalid GS1 Company Prefix Length");
            }
        }

        /**
        * This method returns the number of bits that should be used for the company prefix based on the partition value.
        *
        * @param partitionValue - The partition value.
        * @return The number of bits for the company prefix.
        */
        private static int getCompanyPrefixBits(int partitionValue) {
            switch (partitionValue) {
                case 0: return 40;
                case 1: return 37;
                case 2: return 34;
                case 3: return 30;
                case 4: return 27;
                case 5: return 24;
                case 6: return 20;
                default: throw new IllegalArgumentException("Invalid Partition Value");
            }
        }

        /**
        * This method returns the number of bits that should be used for the item reference based on the partition value.
        *
        * @param partitionValue - The partition value.
        * @return The number of bits for the item reference.
        */
        private static int getItemReferenceBits(int partitionValue) {
            switch (partitionValue) {
                case 0: return 4;
                case 1: return 7;
                case 2: return 10;
                case 3: return 14;
                case 4: return 17;
                case 5: return 20;
                case 6: return 24;
                default: throw new IllegalArgumentException("Invalid Partition Value");
            }
        }

        /**
        * This method gets the prefix length by checking the given GTIN against a map of known prefixes.
        *
        * @param prefixMap - The map of known prefixes.
        * @param gtin - The Global Trade Item Number.
        * @return The length of the prefix.
        */
        private static int getPrefixLength(Map<String, Integer> prefixMap, String gtin) {
            for (int i = 4; i <= 12; i++){
                String prefix = gtin.substring(1,i);
                Integer gcpLength = prefixMap.get(prefix);
                if(gcpLength != null){
                    return gcpLength;
                }
            }
            throw new IllegalArgumentException("prefix not found");
        }

        //GCPMap Builder Functions:

        /**
        * This method loads a JSON file from the app's assets folder.
        *
        * @param context - The context of the calling activity.
        * @return The JSON data in string format.
        */
        private static String loadJSONFromAsset(Context context){
            String json;
            try {
                InputStream is = context.getAssets().open("gcpprefixformatlist.json");
                int size = is.available();
                byte[] buffer = new byte[size];
                is.read(buffer);
                is.close();
                json = new String(buffer, "UTF-8");
            } catch(IOException e){
                e.printStackTrace();
                return null;
            }
            return json;
        }

        /**
        * This method builds a map from the loaded JSON data where the keys are prefixes and the values are prefix lengths.
        *
        * @param jsonData - The JSON data in string format.
        * @return The map of prefixes and their lengths.
        */
        private static Map<String, Integer> buildPrefixMap(String jsonData){
            Map<String, Integer> prefixMap = new HashMap<>();
            try{
                JSONObject obj = new JSONObject(jsonData);
                JSONArray entries = obj.getJSONObject("GCPPrefixFormatList").getJSONArray("entry");
                for (int i = 0; i < entries.length(); i++){
                    JSONObject entry = entries.getJSONObject(i);
                    prefixMap.put(entry.getString("prefix"), entry.getInt("gcpLength"));
                }

            }catch (Exception e){
                e.printStackTrace();
            }
            return prefixMap;
        }
    }

</code></pre>

<h3 id="fullapp" class="anchor"><a class="heading-anchor" href="#fullapp"><span></span></a>Complete DataWedge.java Implementation</h3>
<pre class="prettyprint"><code>

    package com.zebra.ssw.EncodeBarcodeToRFID;

    import android.content.Context;
    import android.content.Intent;
    import android.os.Bundle;
    import java.util.ArrayList;
    import com.zebra.ssw.R;

    public class DataWedge {
        private static final String APPLICATION_ID          =   "com.zebra.ssw";
        public static final String INTENT_NAME              =   APPLICATION_ID + ".BARCODE";
        public static final String DATAWEDGE_EXTRA          =   "com.symbol.datawedge.data_string";
        private static final String ACTION_DATAWEDGE        =   "com.symbol.datawedge.api.ACTION";
        private static final String EXTRA_SET_CONFIG        =   "com.symbol.datawedge.api.SET_CONFIG";

        /**
        * Setup the datawedge profile for application
        * @param context Application Context
        */
        public static void setDWProfile(Context context) {
            //Main
            Bundle bMain = new Bundle();
            bMain.putString("PROFILE_NAME", context.getString(R.string.app_name));
            bMain.putString("PROFILE_ENABLED","true");
            bMain.putString("CONFIG_MODE","CREATE_IF_NOT_EXIST");

            // Create APP_LIST bundle to associate app with profile
            Bundle appConfig = new Bundle();
            appConfig.putString("PACKAGE_NAME", context.getPackageName());
            appConfig.putStringArray("ACTIVITY_LIST", new String[]{"*"});
            bMain.putParcelableArray("APP_LIST", new Bundle[]{appConfig});
            Intent dwIntent = new Intent();
            dwIntent.setAction(ACTION_DATAWEDGE);
            dwIntent.putExtra(EXTRA_SET_CONFIG, bMain);
            context.sendBroadcast(dwIntent);

            //PLUGIN_CONFIG
            Bundle bConfig = new Bundle();
            bConfig.putString("PLUGIN_NAME","INTENT");
            bConfig.putString("RESET_CONFIG","true");

            //PARAM_LIST
            Bundle bParams = new Bundle();
            bParams.putString("intent_output_enabled","true");
            bParams.putString("intent_action",INTENT_NAME);
            bParams.putString("intent_category", Intent.CATEGORY_DEFAULT);
            bParams.putInt("intent_delivery",2);                                                        //Use "0" for Start Activity, "1" for Start Service, "2" for Broadcast
            bConfig.putBundle("PARAM_LIST", bParams);
            bMain.putBundle("PLUGIN_CONFIG", bConfig);

            // APP_LIST
            Bundle bundleApp1 = new Bundle();
            bundleApp1.putStringArray("ACTIVITY_LIST", new String[]{ "com.zebra.findit.*" });
            bMain.putParcelableArray("APP_LIST", new Bundle[] { bundleApp1 });

            //Send Intent to add Config
            Intent i = new Intent();
            i.setAction("com.symbol.datawedge.api.ACTION");
            i.putExtra("com.symbol.datawedge.api.SET_CONFIG", bMain);
            context.sendBroadcast(i);

            //****************** Turn Off Keystroke and RFID *****************************
            bMain = new Bundle();
            bMain.putString("PROFILE_NAME",context.getString(R.string.app_name));
            bMain.putString("PROFILE_ENABLED","true");
            bMain.putString("CONFIG_MODE","UPDATE");

            ArrayList<Bundle> plugins = new ArrayList<>();

            //KEYSTROKE PLUGIN_CONFIG
            bConfig = new Bundle();
            bConfig.putString("PLUGIN_NAME","KEYSTROKE");
            bConfig.putString("RESET_CONFIG","true");

            bParams = new Bundle();
            bParams.putString("keystroke_output_enabled","false");

            bConfig.putBundle("PARAM_LIST", bParams);
            plugins.add(bConfig);

            //RFID PLUGIN_CONFIG
            bConfig = new Bundle();
            bConfig.putString("PLUGIN_NAME","RFID");
            bConfig.putString("RESET_CONFIG","true");

            bParams = new Bundle();
            bParams.putString("rfid_input_enabled", "false");

            bConfig.putBundle("PARAM_LIST", bParams);
            plugins.add(bConfig);

            bMain.putParcelableArrayList("PLUGIN_CONFIG", plugins);
            i.setAction("com.symbol.datawedge.api.ACTION");
            i.putExtra("com.symbol.datawedge.api.SET_CONFIG", bMain);
            context.sendBroadcast(i);

            // Register this
            registerProfile(context);
        }

        public static void registerProfile(Context context) {
            Bundle bMain = new Bundle();
            bMain.putString("com.symbol.datawedge.api.APPLICATION_NAME", APPLICATION_ID);
            bMain.putString("com.symbol.datawedge.api.NOTIFICATION_TYPE", "PROFILE_SWITCH");

            Bundle bParams = new Bundle();
            bParams.putString("PROFILE_IMPORTED", "FULL_DB_IMPORTED");
            bParams.putString("PROFILE_NAME", context.getString(R.string.app_name));
            bMain.putBundle("com.symbol.datawedge.api.NOTIFICATION", bParams);

            Intent i = new Intent();
            i.setAction("com.symbol.datawedge.api.ACTION");
            i.putExtra("com.symbol.datawedge.api.REGISTER_FOR_NOTIFICATION", bMain);
            context.sendBroadcast(i);
        }
    }

</code></pre>

<h3 id="fullapp" class="anchor"><a class="heading-anchor" href="#fullapp"><span></span></a>Complete BarcodeToRfidApi.java Implementation</h3>
<pre class="prettyprint"><code>

    package com.zebra.ssw;

    import android.content.Context;
    import android.content.Intent;
    import com.zebra.ssw.EncodeBarcodeToRFID.DataWedge;
    import com.zebra.ssw.EncodeBarcodeToRFID.EPC;
    import com.zebra.ssw.EncodeBarcodeToRFID.EPCConverter;

    public class BarcodeToRfidApi {
        public static void initialize(Context context) {
            EPCConverter.initEpcConverter(context);
            DataWedge.setDWProfile(context);
        }

        public static EPC encodeBarcodeToRfid(String scannedUpc, String serialNumber) {
            EPC epc = EPCConverter.encodeSGTIN96(scannedUpc, serialNumber);
            return epc;
        }
    }

</code></pre>

<!-- 4/24/18- dead link removed. No corresponding folder or sample found. -EC
## Downloading the Sample
Download the source for this project in the [associated sample](/emdk-for-android/6-10/guide/sample/samplebatteryintent).

 --><p></p>
                                        


                                    </div>
                                </div>

                            </div>
                        </div>
                    </div>
                </div><!--/.col-sm-6-->
            </div>
            </section>
        </div>
    </section>    

<div class="modal fade" id="basicModal" tabindex="-1" role="dialog" aria-labelledby="basicModal" aria-hidden="true" data-backdrop="true">
			<div class="modal-dialog">
				<div class="modal-content">
					<div class="modal-header">
						<button type="button" class="close" data-dismiss="modal" aria-hidden="true">X</button>
					</div>
					<div class="modal-body">
						<div id="modalImg">
						
						</div>
					</div>
			</div>
		  </div>
		</div> </div>
         <footer id="footer" class="navbar-fixed-bottom">
            <div class="container-fluid">
                <div class="row">
                    <div class="col-sm-10">
                        ZEBRA and the stylized Zebra head are trademarks of Zebra Technologies Corporation, registered in many jurisdictions worldwide. All other trademarks are the property of their respective owners. 2024 Zebra Technologies Corporation and/or its affiliates. All rights reserved. <a href="https://www.zebra.com/us/en/about-zebra/company-information/compliance/information-privacy/terms-of-use.html">Terms &amp; Conditions</a>
                    </div>
    <!--                 
                    <div class="col-sm-2">
                        <ul class="social-icons">
                            <li><a href="http://www.facebook.com/pages/Zebra-Technologies/107703715989073"><i class="fa fa-facebook"></i></a></li>
                            <li><a href="https://twitter.com/ZebraDevs"><i class="fa fa-twitter"></i></a></li>
                            <li><a href="http://www.youtube.com/zebratechnologies/"><i class="fa fa-youtube"></i></a></li>
                            <li><a href="https://www.linkedin.com/groups?home=&gid=3220074&trk=anet_ug_hm&goback=%2Egmr_3220074"><i class="fa fa-linkedin"></i></a></li>
                            <li><a href="https://github.com/developer-zebra"><i class="fa fa-github"></i></a></li>
                        </ul>
                    </div> -->
                </div>
            </div>
        </footer><!--/#footer-->
    <script src="/js/bootstrap.min.js"></script>
    <script src="/js/owl.carousel.min.js"></script>
    <script src="/js/mousescroll.js"></script>
    <script src="/js/smoothscroll.js"></script>
    <script src="/js/jquery.prettyPhoto.js"></script>
    <script src="/js/jquery.isotope.min.js"></script>
    <script src="/js/jquery.inview.min.js"></script>
    <script src="/js/wow.min.js"></script>
    <script src="/js/bootstrap-treenav.min.js"></script>
    <script src="/js/prettify.js"></script>
    <script src="/js/zepto.js"></script>
    <script src="/js/jquery.waterfall.js"></script>   
    <script src="/js/main.js"></script>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','zRzEsAUhWTTkrdEN2YfA','2.0.0');
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-72584442-1', 'auto');
  ga('send', 'pageview');

</script> 

<script>
    ChatraID = 'QDvZ76min4DhLW5vJ';
    (function(d, w, c) {
        var n = d.getElementsByTagName('script')[0],
            s = d.createElement('script');
        w[c] = w[c] || function() {
            (w[c].q = w[c].q || []).push(arguments);
        };
        s.async = true;
        s.src = (d.location.protocol === 'https:' ? 'https:': 'http:')
            + '//call.chatra.io/chatra.js';
        n.parentNode.insertBefore(s, n);
    })(document, window, 'Chatra');
</script>         


</body></html>