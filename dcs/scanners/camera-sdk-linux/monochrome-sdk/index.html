<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Programmers can use these scanner Software Development Kits to build applications.">
        <meta name="author" content="Zebra Technologies">
        <meta name="google-site-verification" content="i4B78BrWnNy8ShJwe5feRW3jO3HE6gfYlYqYbxfl8yY">
        <meta name="msvalidate.01" content="6B651B00161BCE79B8950AC09D5C4C75">
        <meta title="Bioptic Color Camera SDK for Windows">
        <title>Bioptic Color Camera SDK for Linux - Monochrome SDK - Zebra Technologies</title>
        <!-- core CSS -->
        <link href="/css/bootstrap.min.css" rel="stylesheet">
        <link href="/css/font-awesome.min.css" rel="stylesheet">
        <link href="/css/animate.min.css" rel="stylesheet">
        <link href="/css/owl.carousel.css" rel="stylesheet">
        <link href="/css/owl.transitions.css" rel="stylesheet">
        <link href="/css/prettyPhoto.css" rel="stylesheet">
        <link href="/css/main.css" rel="stylesheet">
        <link href="/css/responsive.css" rel="stylesheet">
        <link href="/css/prettify.css" rel="stylesheet">
        <link href="/css/bootstrap-treenav.min.css" rel="stylesheet">
        <link href="../../dcs_styles.css" rel="stylesheet">
        <!--[if lt IE 9]>
        <script src="js/html5shiv.js"></script>
        <script src="js/respond.min.js"></script>
        <![endif]--> 
        <script src="//load.sumome.com/" data-sumo-site-id="699cb66cf4dc59352efb45705526d15cbe314e1cd43f7761b94d96f3cf7338e8" async="async"></script>
        <link rel="shortcut icon" href="/favicon.ico">
        <script src="/js/jquery.js"></script>
    </head>
    <body id="home" class="homepage" data-spy="scroll" data-offset="100" data-target="#toc">
        <header id="header">
            <nav id="main-menu" class="navbar navbar-default navbar-fixed-top" role="banner">
                <div class="container-fluid">
                    <div class="navbar-header">
                        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                            <span class="sr-only">Toggle navigation</span>
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                        </button>
                        <a class="navbar-brand" href="/">
                            <img src="/images/logo.png" alt="logo" style="max-height:66px;float: inherit; padding-right: 3px;">
                        </a> 
                    </div>
                    <div class="collapse navbar-collapse navbar-left">
                        <ul class="nav navbar-nav">
                            <li class="navbar-text pull-left"><strong>TechDocs</strong></li>
                            <li>
                                <a href="/dcs/scanners">Barcode Scanner Tools</a>
                            </li>
                            <p class="navbar-text">Bioptic Color Camera SDK for Linux</p>
                        </ul>
                    </div>
                    <div class="collapse navbar-collapse navbar-right">
                        <ul class="nav navbar-nav">
                            <li>
                                <a href="/dcs/scanners/camera-sdk-linux/about/">About</a>
                            </li>
                            <li>
                                <a href="/dcs/scanners/camera-sdk-linux/getting-started/">Getting Started</a>
                            </li>
                            <li>
                                <a href="/dcs/scanners/camera-sdk-linux/sdk/">SDK</a>
                            </li>
                            <li>
                                <a href="/dcs/scanners/camera-sdk-linux/bounding-box/">Bounding Box Detection</a>
                            </li>
                            <li>
                                <a href="/dcs/scanners/camera-sdk-linux/monochrome-sdk/">Monochrome Library</a>
                            </li>
                            <li>
                                <a href="/dcs/scanners/camera-sdk-linux/download/">
                                    <i class="fa fa-download"></i>
                                </a>
                            </li>
                        </ul>
                    </div>
                </div><!--/.container-->
            </nav><!--/nav-->
        </header><!--/header-->
        <div class="container-fluid">
            <section id="blog">
                <div class="">
                    <section class="content-with-sidebar">
                        <div class="row">
                            <div class="col-sm-3 hidden-sm hidden-xs" id="sidebar">
                                <nav id="toc" data-toggle="toc" data-spy="affix" style="height: 75%; max-width: 225px; overflow-y: auto; ">
                                    <ul class="nav">
                                        <li><strong>Monochrome Library</strong></li>
                                    </ul>
                                </nav>                    
                                <script type="text/javascript">
                                    $(document).ready(function() {
                        	            $( "#btn_SaveSmartDocOptions" ).click(function() {
                      			            console.log('Saving Options');
                      			            $("#modal-smartdocs").modal({show: false});
                    		            });
                        	            $( "#btn_SaveSmartDocOptions" ).click(function() {
                      			            console.log('Clearing Options');
                      			            $("#modal-smartdocs").modal({show: false});
                    		            });
                                    });
                                </script>
                                <link rel="stylesheet" href="https://cdn.rawgit.com/afeld/bootstrap-toc/v0.3.0/dist/bootstrap-toc.min.css">
                                <script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v0.3.0/dist/bootstrap-toc.min.js"></script>
                                <script type="text/javascript">
                                    $(document).ready(function() {                    
                                    });
                                </script>
                            </div>                
                            <div class="col-sm-9 ">
                                <div class="row">
                                    <div class="col-sm-12">
                                        <section id="cta" class="wow fadeIn">
                                            <div class="">
                                                <h1 id="bcc-linux-monochrome" class="anchor">
                                                    <a class="heading-anchor" href="#bcc-linux-monochrome"><span></span></a>Monochrome Library
                                                </h1>
                                            </div>
                                        </section>                    
                                    </div>
                                </div>
                                <div id="mainContent" class="row">
                                    <div class="col-sm-12">
                                        <div class="blog-post blog-large wow fadeInLeft" data-wow-duration="300ms" data-wow-delay="0ms">
                                            <!-- Start of guide -->
                                            <div class="service-box wow fadeInRight">
                                                <div class="">
                                                    <h2 id="overview" class="anchor"><a class="heading-anchor" href="#overview"><span></span></a>Pre-requisites</h2>

                                                    <p><a href="#bcc-linux-jetson-configuration">Please refer the Jetson Nano - USB 2.0 OTG Mass Storage Configuration Instructions to configure the hardware setup required to get tower platter images from MP7</a></p>

                                                    <p><strong>Create a C++ application with a preferred IDE. In this example, IDE ‘CodeBlocks’ has been used.</strong></p>

                                                    <ol>
                                                        <li>
                                                            <p>Create a sample GUI.</p>

                                                            <p>
                                                                For this sample application, a simple UI is created with only 2 buttons.
                                                                <br />Start – Registers app with monochrome library. Requests to send events when available.
                                                                <br />Stop – Requests to stop sending events.
                                                            </p>

                                                            <div style="display: block; margin: 0 auto; text-align: center;">
                                                                <img src="../../images/camera-sdk-linux/007-bcc-linux-monochrome-new-project.png" style="display: block; margin: 0 auto;"><strong>Figure 1</strong> Creating a New Project
                                                            </div>
                                                        </li>
                                                        <li>
                                                            <p>Add Monochrome library to the application. For the purpose of documentation,</p>
                                                            <ol type="a">
                                                                <li>Create a directory named ‘lib’ and place the ‘libmonochrome-sdk.so’ shared object files (This can be found inside /usr/lib/zebra-camera) in the ‘lib’ directory.</li>
                                                                <li>Create a directory named ‘include_tp_header’ and place the header files of the monochrome library in that directory.(headers can be found inside /usr/include/zebra-camera/monochrome_sdk directory.)</li>
                                                            </ol>
                                                        </li>
                                                        <li>
                                                            <p>Create ‘button-click’ events for the application.</p>

                                                            <div style="display: block; margin: 0 auto; text-align: center;">
                                                                <img src="../../images/camera-sdk-linux/008-bcc-linux-monochrome-new-project-add-control.png" style="display: block; margin: 0 auto;"><strong>Figure 2</strong> Create Events
                                                            </div>
                                                        </li>
                                                        <li>
                                                            <p>Create a class to register to events by implementing a pure abstract class “ImageEventSubscriber”. In this example, a class called ‘ImageEventSubscriberSample’ is created.</p>
                                                            <ol type="a">
                                                                <li>
                                                                    <p>The header file is given below.</p>

                                                                    <!-- code segment -->
<pre class="prettyprint">
<code>
#ifndef IMAGE_EVENT_SUBSCRIPTION_IMPL_H
#define IMAGE_EVENT_SUBSCRIPTION_IMPL_H

#include "image_event.h"
#include "image_event_subscriber.h"

/**
* Sample implementation of the ImageEventSubscriber class.
* ImageEventSubscriber is a pure abstract class. User can implement(inherit)
* the class to own class and override the RecieveImageEvents method to get the image events.
*/
class ImageEventSubscriberSample : public ImageEventSubscriber 
{
    public:
        /**
        * Sample implementation of the pure virtual method RecieveImageEvents
        * given in the ImageEventSubscriber class.
        * @param image_creation_event ImageCreationEvent object contains the tower platter image data.
        */
        void RecieveImageEvents(ImageCreationEvent *image_creation_event);
};

#endif /* IMAGE_EVENT_SUBSCRIPTION_IMPL_H */
</code>
</pre>
                                                                </li>
                                                                <li>
                                                                    <p>Source (cpp) file is provided below.</p>

                                                                    <p><strong>Note:</strong> As the document is a guide on implementing the monochrome library, the example here only shows, how to retrieve image data. User can use preferred method to show the data in GUI or save images as files. The tower platter image data is contained inside ‘ImageCreationEvent’ class. Data can be retrieved using GetTowerImage() api and GetPlatterImage() APIs. The pure virtual method ‘void RecieveImageEvents (ImageCreationEvent *image_creation_event)’ has to be overridden to receive events.</p>

                                                                    <!-- code segment -->
<pre class="prettyprint">
<code>
#include &lt;iostream>
#include &lt;string>
#include "image_event_subscriber.h"
#include "image_event.h"
#include "image_event_subscription_impl.h"

void ImageEventSubscriberSample::RecieveImageEvents(ImageCreationEvent *image_creation_event)
{
    uint8_t *tower_image_ptr = image_creation_event_.GetTowerImage();
    uint8_t *platter_image_ptr = image_creation_event_.GetPlatterImage(); 
}
</code>
</pre>
                                                                </li>
                                                            </ol>
                                                        </li>
                                                        <li>
                                                            <p>In the main program header, two member variables are created to hold the instance of two classes. Namely, ‘ImageEventSubscriberSample’ class that was created earlier and the pure virtual ‘DirectoryObserver’ class. ‘DirectoryObserver’ can be initialized with the implementation of ‘ImageCreationObserver’ object.</p>

                                                            <p><strong>Note:</strong> The auto generated code snippets of the CodeBlocks IDE haven been left out of this Guide for better understanding and only applicable sections of the ‘header’ file have been included.</p>

                                                            <!-- code segment -->
<pre class="prettyprint">
<code>
#include "image_event_subscription_impl.h"
#include "directory_observer.h"
#include "image_event.h"

class Tower_Platter_SampleFrame: public wxFrame
{
    public:
        Tower_Platter_SampleFrame(wxWindow* parent,wxWindowID id = -1);
        virtual ~Tower_Platter_SampleFrame();

    private:
        // ... some more auto generated codes

        //(*Declarations(Tower_Platter_SampleFrame)
        wxStatusBar* StatusBar1;
        wxButton* btn_stop_;
        wxButton* btn_start_;
        //*)

        ImageEventSubscriber* subscriber_;
        DirectoryObserver *dir_observer_;

        DECLARE_EVENT_TABLE()
};
</code>
</pre>
                                                        </li>
                                                        <li>
                                                            <p>Implementation of the ‘onclick’ event of the ‘start’ button takes place in the source of the main program</p>

<pre class="prettyprint">
<code>
void Tower_Platter_SampleFrame::Onbtn_start_Click(wxCommandEvent& event)
{
    try
    {
        subscriber_ = new ImageEventSubscriberSample();

        // creates DirectoryObserver object and registers the above
        // created ImageEventSubscriber object.
        dir_observer_ = new ImageCreationObserver();
        dir_observer_->StartObserving(subscriber_);
    }
    catch (std::exception& exception)
    {
        std::cout &lt;&lt; "Exception : " &lt;&lt; exception.what()  &lt;&lt; std::endl;
    }
}                                                                    
</code>
</pre>
                                                        </li>
                                                        <li>
                                                            <p>OnClick’ event of the ‘Stop button’</p>

<pre class="prettyprint">
<code>
void Tower_Platter_SampleFrame::Onbtn_stop_Click(wxCommandEvent& event)
{
    try
    {
        // stops scanning for new tower platter images
        dir_observer_->StopObserving();
    }
    catch (std::exception& exception)
    {
        std::cout &lt;&lt; "Exception : " &lt;&lt; exception.what()  &lt;&lt; std::endl;
    }
}                                                                    
</code>
</pre>
                                                        </li>
                                                        <li>
                                                            <p>In order to receive image events, TriggerTowerPlatterImageEvent() API should be called, once  the DecodeImageEvent is received from the camera SDK.</p>

                                                            <!-- code segment -->
<pre class="prettyprint">
<code>
class DecodeImageEventObserver: public DecodeImageEventListener 
{
    public:
        void ImageReceived(ImageEventData ev, ImageEventMetaData md) {
            dir_observer_->TriggerTowerPlatterImageEvent();
        }
};
</code>
</pre>

                                                            <p>Notifies the trigger Tower/Platter Image Events.</p>

                                                            <!-- code segment -->
<pre class="prettyprint">
<code>
TriggerTowerPlatterImageEvent();
</code>
</pre>

                                                            <p>Every time a Decode Image event is triggered, the two corresponding Tower/Platter images will be saved in the Mass Storage by the MP7. When a call is made to ‘TriggerTowerPlatterImageEvent()’, those two images can be retrieved from the Mass Storage through ‘ReceiveImageEvents()’.</p>
                                                        </li>
                                                        <li>
                                                            <p>'CMakeList’ file creation.</p>

                                                            <p>Monochrome library can be linked to the project using ‘cmake’. If the user wishes, the same can be achieved with terminal commands as well.</p>

                                                            <!-- code segment -->
<pre class="prettyprint">
<code>
cmake_minimum_required (VERSION 3.8)
project (gui_sample)

find_package(wxWidgets COMPONENTS core base REQUIRED)
# wxWidgets include
include( "${wxWidgets_USE_FILE}" )

set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED on)

#include library headers 
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/include_tp_header)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/include)

# Link with the shared library:
link_directories(${CMAKE_CURRENT_SOURCE_DIR}/lib/)
set ( PROJECT_LINK_LIBS libmonochrome-sdk.so )

# Create an executable
file(GLOB SOURCE "*.cpp")
add_executable(gui_sample ${SOURCE})

# Set output target to build directory
set_target_properties(gui_sample PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/build)

target_link_libraries(gui_sample ${PROJECT_LINK_LIBS} )
target_link_libraries(gui_sample ${wxWidgets_LIBRARIES})
</code>
</pre>
                                                        </li>
                                                        <li>
                                                            <p>Build and Run.</p>

                                                            <p>A terminal should be opened in the same folder that contains the CMakeList.txt. Then the following commands should be executed as shown in the code snippets below.</p>

                                                            <!-- code segment -->
<pre class="prettyprint">
<code>
cmake .
make
</code>
</pre>

                                                            <p>The ‘build’ directory should be opened, and the following code line should be used for execution of the program.</p>

                                                            <!-- code segment -->
<pre class="prettyprint">
<code>
run “./gui_sample” 
</code>
</pre>
                                                        </li>
                                                        <li>
                                                            <p>Configuration settings of tower/platter imaging library.</p>
                                                                
                                                            <p>Tower/platter imaging library configuration file is available at: "/usr/share/zebra-camera/configs/zebra-camera-sdk/camera-sdk-conf.xml"</p>
                                                                
                                                            <ul>
                                                                <li>mp_mass_storage_path – Partition path of the SD card that MP7 writes tower/platter images (without trailing “/”). e.g.&lt;mp_mass_storage_path>/media/zebra/mp7flash/Zebra_DecodeImages&lt;/mp_mass_storage_path></li>
                                                                    
                                                                <li>mass_storage_dev_path – Device path of the mass-storage (without trailing “/”). e.g. &lt;mass_storage_dev_path>/dev/mmcblk0p15&lt;/mass_storage_dev_path></li>
                                                                    
                                                                <li>mp_mass_storage_mount_point – Specify the mount location of the mass storage device. It will be appeared as storage device after mounting to this location. e.g.&lt;mp_mass_storage_mount_point>/media/zebra/mp7flash&lt;/mp_mass_storage_mount_point></li>
                                                                    
                                                                <li>mount_command_wait_time - Specify the time delay for mount command to return.The default value is sufficient and can be increased according to the environment. e.g.&lt;mount_command_wait_time>100000&lt;/mount_command_wait_time></li>
                                                                    
                                                                <li>umount_command_wait_time  - Specify the time delay for mount command to return. The default value is sufficient can be increased according to the environment. e.g. &lt;umount_command_wait_time>100000&lt;/umount_command_wait_time></li>
                                                            </ul>
                                                        </li>
                                                    </ol>

                                                    <hr>

                                                    <h2 id="bcc-linux-jetson-configuration" class="anchor"><a class="heading-anchor" href="#bcc-linux-jetson-configuration"><span></span></a>Jetson Nano - USB 2.0 OTG Mass Storage Configuration Instructions</h2>

                                                    <ul>
                                                        <li>Create ‘FAT32’ partition on the Jetson Nano SD Card using ‘gparted’.</li>
                                                        <li>Insert SD card into the ‘Jetson Nano’ and power-up the board.</li> 
                                                        <li>Record the partition location (i.e: /dev/mmcblk0p13) that was created on the SD card. This will be used in a step further down the document.</li>
                                                        <li>
                                                            <p>Disable ‘NVIDIA’ demo service to stop NVIDIA USB OTG demos scripts from running at startup.</p> 
                                                            <!-- code segment -->
                                                            sudo systemctl disable nv-l4t-usb-device-mode
                                                        </li> 
                                                        <li>Create a new folder by the name,’/opt/zebra’</li>
                                                        <li>Copy ‘zebra-usb-msd’ folder to ‘/opt/zebra/’</li>
                                                        <li>
                                                            <p>Update the Zebra MSD script (zebra-usb-msd.sh) to include the location of the FAT32 partition that was created on the SD card:</p>
                                                            <!-- code segment -->
                                                            e.g. fs_img="/dev/mmcblk0p13"
                                                        </li>
                                                        <li>
                                                            <p>Update permissions of the script files:</p> 
                                                            <!-- code segment -->
                                                            chmod a+x zebra-usb-msd.sh chmod a+x zebra-usb-msd-stop.sh
                                                        </li> 
                                                        <li>
                                                            <p>Enable Zebra MSD service:</p>
                                                            <!-- code segment --> 
                                                            sudo systemctl enable /opt/zebra/zebra-usb-msd/zebra-usbmsd.service
                                                        </li> 
                                                        <li>
                                                            <p>Start Zebra MSD service:</p>
                                                            <!-- code segment -->
                                                            sudo systemctl start zebra-usb-msd
                                                        </li>
                                                        <li>Reboot the Jetson Nano</li> 
                                                        <li>After the Jetson Nano is rebooted, USB cable from the OTG port should be attached to an Ubuntu machine.</li> 
                                                        <li>‘Disks’ tool on the Ubuntu machine can be used to format the connected partition (FAT).</li> 
                                                        <li>Once the above instructions are followed, the Jetson Nano USB MSD will then ready to be interfaced with the MP7.</li>
                                                    </ul>

                                                    <hr>

                                                    <h2 id="bcc-linux-mass-storage" class="anchor"><a class="heading-anchor" href="#bcc-linux-mass-storage"><span></span></a>MP7 Mass Storage Configuration Instructions for Saving Monochrome Images</h2>

                                                    <p><em><strong>Table 1</strong> Mass Storage Configurations</p></em>
                                                    <table class="hovertable" id="#table1">
                                                        <tr>
                                                            <th>Attribute Name</th>
                                                            <th>Attribute ID</th>
                                                            <th>Description</th>
                                                            <th>Default Value</th>
                                                            <th>Other Values</th>
                                                        </tr>
                                                        <tr>
                                                            <td>ATT_ STORE_DECODE_IMAGES</td>
                                                            <td>1824</td>
                                                            <td>Gives the command to save Decoded images</td>
                                                            <td>0</td>
                                                            <td>   
                                                                <ul>
                                                                    <li>0 - No saving</li> 
                                                                    <li>1 - Saves the image with the slowest decode time</li>
                                                                    <li>2 - Saves all Decoded Images in the USB drive</li>
                                                                </ul>
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>ATT_IMAGE_SUBSAMPLE</td>
                                                            <td>302</td>
                                                            <td>More time is consumed during image saving when the image resolution is high. Decode Image resolution can be reduced by varying the Attribute value.</td>
                                                            <td>0</td>
                                                            <td>
                                                                <ul>                                                 
                                                                    <li>0 – Full resolution</li>
                                                                    <li>1 – Reduces the image resolution by 1/2</li>
                                                                    <li>2 – Reduces the image resolution by 1/4</li>
                                                                </ul>
                                                            </td>
                                                        </tr>
                                                        <tr>
                                                            <td>ATT_STORE_DECODE_IMAGES_COUNT</td>
                                                            <td>2046</td>
                                                            <td>Determines the number of images that can be saved in the storage device</td>
                                                            <td>4</td>
                                                            <td>Any value between 4 -100. Recommended value for tower/platter images is 10.</td>
                                                        </tr>
                                                    </table>

                                                    <hr>

                                                    <h2 id="bcc-linux-multi-client" class="anchor"><a class="heading-anchor" href="#bcc-linux-multi-client"><span></span></a>Changes Introduced with Multiclient Approach</h2>

                                                    <h3 id="bcc-linux-multi-client-camera" class="anchor"><a class="heading-anchor" href="#bcc-linux-multi-client-camera"><span></span></a>Zebra_camera_client.h</h3>

                                                    <p>Listed below are some of the API calls that underwent changes with the introduction of the Multiclient approach. User may locate the following API s in ‘zebra_camera_client.h’ file.</p>

                                                    <h4 id="bcc-linux-multi-client-api-expert" class="anchor"><a class="heading-anchor" href="#bcc-linux-multi-client-api-expert"><span></span></a>Expert Level APIs</h4>

                                                    <!-- code segment -->
<pre class="prettyprint">
<code>
// Returns property value as a buffer.
virtual std::vector<uint8_t> GetProperty(Get function, uint8_t unit_or_terminal_id, uint8_t property_id) = 0;

// Set property value as a buffer.
virtual void SetProperty(Set function, uint8_t unit_or_terminal_id, uint8_t property_id, std::vector<uint8_t> value) = 0;

// Returns property attributes
virtual AttributeInfo GetPropertyInfo(uint8_t unit_or_terminal_id, uint8_t property_id) = 0;

// Returns true if the specified property is unit or terminal supported.
virtual bool IsPropertySupported(uint8_t unit_or_terminal_id, uint8_t property_id) = 0;

// Returns true if the property supports auto control
virtual bool IsAutoSupported(uint8_t unit_or_terminal_id, uint8_t property_id) = 0;

// Returns true if auto functionality of an auto supported property is enabled.
virtual bool IsAutoEnabled(uint8_t unit_or_terminal_id, uint8_t property_id) = 0;

// Enable/disable auto functionality of an auto supported property.
virtual void AutoEnable(bool enable, uint8_t unit_or_terminal_id, uint8_t property_id) = 0;
</code>
</pre>

                                                    <h4 id="bcc-linux-multi-client-api-asset" class="anchor"><a class="heading-anchor" href="#bcc-linux-multi-client-api-asset"><span></span></a>Asset Tracking APIs</h4>

                                                    <!-- code segment -->
<pre class="prettyprint">
<code>
// Returns serial number as a string.
virtual std::string GetSerialNumber() = 0;

// Returns Camera model number as a string.
virtual std::string GetModelNumber() = 0;

// Returns Date of manufacture as a string.
virtual std::string GetDateOfManufacture() = 0;

// Returns Date of first program as a string.
virtual std::string GetDateOfFirstProgram() = 0;

// Returns First service date as a string.
virtual std::string GetFirstServiceDate() = 0;

// Returns Firmware version as a string.
virtual std::string GetFirmwareVersion() = 0;

// Returns Hardware version as a string.
virtual std::string GetHardwareVersion() = 0;
</code>
</pre>

                                                    <h4 id="bcc-linux-multi-client-api-video" class="anchor"><a class="heading-anchor" href="#bcc-linux-multi-client-api-video"><span></span></a>Video APIs</h4>

                                                    <!-- code segment -->
<pre class="prettyprint">
<code>
// Returns supported frame types.
virtual std::vector<FrameType> GetSupportedFrameTypes() = 0;

// Returns current setting for the frame type.
virtual FrameType GetCurrentFrameType() = 0;

// Set Current setting for the frame type.
virtual void SetCurrentFrameType(FrameType frame_type) = 0;

// Adding a listener for continuous image events.
virtual void AddContinuousImageEventListener(ContinuousImageEventListener& listener) = 0;

// Removing the specified continuous image event listener
virtual void RemoveContinuousImageEventListener(ContinuousImageEventListener& listener) = 0;

// Adding a listener for snapshot image events
virtual void AddSnapshotImageEventListener(SnapshotImageEventListener& listener) = 0;

// Removing the snapshot image listener
virtual void RemoveSnapshotImageEventListener(SnapshotImageEventListener& listener) = 0;

// Adding a listener for produce image events.
virtual void AddProduceImageEventListener(ProduceImageEventListener& listener) = 0;

Removing the produce image event listener.// 
virtual void RemoveProduceImageEventListener(ProduceImageEventListener& listener) = 0;

// Adding a listener for decode image events.
virtual void AddDecodeImageEventListener(DecodeImageEventListener& listener) = 0;

// Removing the decode image event listener.
virtual void RemoveDecodeImageEventListener(DecodeImageEventListener& listener) = 0;

// Adding a listener for decode session status change event.
virtual void AddDecodeSessionStatusChangeEventListener(DecodeSessionStatusChangeEventListener& listener) = 0;

// Removing the decode session status change listener.
virtual void RemoveDecodeSessionStatusChangeEventListener(DecodeSessionStatusChangeEventListener& listener) = 0;
</code>
</pre>

                                                    <h4 id="bcc-linux-multi-client-miscellaneous" class="anchor"><a class="heading-anchor" href="#bcc-linux-multi-client-miscellaneous"><span></span></a>Miscellaneous</h4>

                                                    <!-- code segment -->
<pre class="prettyprint">
<code>
// Set values of the parameters to their default values.
virtual void SetDefaults() = 0;

// Write current property values to flash memory.
virtual void WriteToFlash() = 0;

// Capture a single frame of image (Snapshot).	
virtual Image CaptureSnapshot() = 0;
</code>
</pre>

                                                    <h3 id="bcc-linux-camera-manager" class="anchor"><a class="heading-anchor" href="#bcc-linux-camera-manager"><span></span></a>zebra_camera_manager_client.h</h3>

                                                    <p>The following two files need to be included in the ‘zebra_camera_manager_client.h’.</p>

                                                    <!-- code segment -->
<pre class="prettyprint">
<code>
#include "zebra_camera_manager_types.h"
#include "zebra_camera_client.h"
</code>
</pre>

                                                    <p>An abstract class that represents an observer of the "Firmware Update" event has been newly introduced.</p>

                                                    <!-- code segment -->
<pre class="prettyprint">
<code>
class FirmwareDownloadEventListener 
{
    public:
        virtual ~FirmwareDownloadEventListener() {}
        virtual void EventReceived(FirmwareDownloadEventsArgs) = 0;
};
</code>
</pre>

                                                    <p>The following API calls were modified to incorporate the Multiclient approach. The files can be found inside ‘zebra_camera_manager_client.h’.</p>

                                                    <!-- code segment -->
                        <pre class="prettyprint">
                            <code>
// Create a ZebraCameraClient from the provided CameraInfo.	
virtual std::shared_ptr&lt;ZebraCameraClient> CreateZebraCamera(zebra::DeviceInfo camera_info) = 0;

// Reboot the specified ZebraCamera.	
virtual std::shared_ptr&lt;ZebraCameraClient> Reboot(std::shared_ptr&lt;ZebraCameraClient> camera, uint16_t timeout = 20) = 0;
	
// Download firmware to Zebra camera.	
virtual void DownloadFirmware(std::shared_ptr&lt;ZebraCameraClient> camera, std::string filepath) = 0;
	
// Install downloaded firmware.
virtual std::shared_ptr&lt;ZebraCameraClient> InstallFirmware(std::shared_ptr&lt;ZebraCameraClient> camera, uint16_t timeout = 20) = 0;

// Cancel a firmware update.	
virtual void CancelFirmwareDownload(std::shared_ptr&lt;ZebraCameraClient> camera) = 0;
	
// Add firmware download event listener.	 
virtual void AddFirmwareDownloadEventListener(FirmwareDownloadEventListener& firmware_download_event_listener) = 0;

// Remove the specified firmware download event listener.
virtual void RemoveFirmwareDownloadEventListener(FirmwareDownloadEventListener& firmware_download_event_listener) = 0;

// Retrieve the current configuration of the provided camera and return as an XML.
virtual std::string RetrieveConfiguration(std::shared_ptr&lt;ZebraCameraClient> camera) = 0;

// Retrieve the current configuration of the provided camera and save to a *.camcfg file.
virtual void RetrieveConfigurationToFile(std::shared_ptr&lt;ZebraCameraClient> camera, std::string configuration_file_path) = 0;
	
// Load provided configuration as an XML string to the provided camera.
virtual void LoadConfiguration(std::shared_ptr&lt;ZebraCameraClient> camera, std::string configuration, bool persist=true) = 0;
            
// Load provided configuration as an XML file (*camcfg) to the provided camera.
virtual void LoadConfigurationFromFile(std::shared_ptr&lt;ZebraCameraClient> camera, std::string configuration_file_path, bool persist=true) = 0;

// The following method has been newly introduced to the ‘zebra_camera_manager_client.h’.
extern std::unique_ptr&lt;ZebraCameraManagerClient> CreateZebraCameraManagerClient();
</code>
</pre>

                                                    <h3 id="bcc-linux-camera-types" class="anchor"><a class="heading-anchor" href="#bcc-linux-camera-types"><span></span></a>camera_types.h</h3>

                                                    <p>The changes introduced to ‘camera_type.h’ are as follows. Generic type for camera property is given. ‘ZebraCameraClient’ is now given access to the protected constructor.</p>

                                                    <!-- code segment -->
<pre class="prettyprint">
<code>
template &lt;typename T, CameraPropertyId ID>
class Property {
    friend class ZebraCameraClient; 

protected:
    ZebraCameraClient *camera_client_ = nullptr;
</code>
</pre>

                                                    <p>Generic type is given for camera property that supports UVC Auto setting.  ‘ZebraCameraClient’ is given access to the protected constructor.</p>

                                                    <!-- code segment -->
<pre class="prettyprint">
<code>
template &lt;typename T, CameraPropertyId ID>
class PropertyAuto: public Property&lt;T, ID> {
    friend class ZebraCameraClient;
</code>
</pre> 

                                                    <p>Generic type is given for enum type properties where resolution is not applicable. ‘ZebraCameraClient’ is provided with access to the protected constructor.</p>

                                                    <!-- code segment -->
<pre class="prettyprint">
<code>
template &lt;typename T, CameraPropertyId ID>
class PropertyEx: public Property&lt;T, ID> {
    friend class ZebraCameraClient;
</code>
</pre>
    
                                                    <hr>

                                                    <h2 id="bcc-linux-multiclient-app" class="anchor"><a class="heading-anchor" href="#bcc-linux-multiclient-app"><span></span></a>Multiclient Sample Test App</h2>

                                                    <p>Given below is a code snippet of the test app written for the purpose of testing and verification of the API calls. The way in which the’ ZebraCameraManagerClient’ object is created is shown by the lines</p>

                                                    <!-- code segment -->
<pre class="prettyprint">
<code>
std::unique_ptr&lt;zebra::camera_sdk::ZebraCameraManagerClient> cammgr = zebra::camera_sdk::CreateZebraCameraManagerClient();
</code>
</pre>

                                                    <!-- code segment -->
<pre class="prettyprint">
<code>
int main() 
{
    cout &lt;&lt; "begin" &lt;&lt; endl;

    int i;
    DeviceManager mgr;
    auto devinfolist = mgr.EnumerateDevices();

    cout &lt;&lt; "enum" &lt;&lt; endl;

    for (auto info: devinfolist)
    {
        printf("%s: vid/pid %0x:%0x bus/addr %0x:%0x %s\n",
                __func__,
                info.vid, info.pid,
                info.bus_number, info.device_address,
                info.serial_number.c_str());
    }

    cout &lt;&lt; "# cams = " &lt;&lt; devinfolist.size() &lt;&lt; endl;

    if (0 == devinfolist.size())
    {
        exit(0);
    }

    std::unique_ptr<zebra::camera_sdk::ZebraCameraManagerClient> cammgr = zebra::camera_sdk::CreateZebraCameraManagerClient();

    cout &lt;&lt; "Created camera manager client" &lt;&lt; endl;
    cin >> i;

    std::shared_ptr<zebra::camera_sdk::ZebraCameraClient> camera = cammgr->CreateZebraCamera(devinfolist[0]);

    cout &lt;&lt; "Created camera client" &lt;&lt; endl;
    cin >> i;

    return 0;
}
</code>
</pre>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>
                </div>
            </section>    
            <div class="modal fade" id="basicModal" tabindex="-1" role="dialog" aria-labelledby="basicModal" aria-hidden="true" data-backdrop="true">
			    <div class="modal-dialog">
				    <div class="modal-content">
					    <div class="modal-header">
						    <button type="button" class="close" data-dismiss="modal" aria-hidden="true">X</button>
					    </div>
					    <div class="modal-body">
						    <div id="modalImg"></div>
					    </div>
			        </div>
		        </div>
            </div>
        </div>
        <footer id="footer" class="navbar-fixed-bottom">
            <div class="container-fluid">
                <div class="row">
                    <div class="col-sm-10">
                        ZEBRA and the stylized Zebra head are trademarks of Zebra Technologies Corporation, registered in many jurisdictions worldwide. All other trademarks are the property of their respective owners. &copy;2022 Zebra Technologies Corporation and/or its affiliates. All rights reserved. <a href="https://www.zebra.com/us/en/about-zebra/company-information/legal/terms-of-use.html">Terms &amp; Conditions</a>
                    </div>
                    <div class="col-sm-2">
                        <ul class="social-icons">
                            <li><a href="http://www.facebook.com/pages/Zebra-Technologies/107703715989073"><i class="fa fa-facebook"></i></a></li>
                            <li><a href="https://twitter.com/ZebraDevs"><i class="fa fa-twitter"></i></a></li>
                            <li><a href="http://www.youtube.com/zebratechnologies/"><i class="fa fa-youtube"></i></a></li>
                            <li><a href="https://www.linkedin.com/groups?home=&amp;gid=3220074&amp;trk=anet_ug_hm&amp;goback=%2Egmr_3220074"><i class="fa fa-linkedin"></i></a></li>
                            <li><a href="https://github.com/zebra-technologies"><i class="fa fa-github"></i></a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </footer><!--/#footer-->
        <script src="/js/bootstrap.min.js"></script>
        <script src="/js/owl.carousel.min.js"></script>
        <script src="/js/mousescroll.js"></script>
        <script src="/js/smoothscroll.js"></script>
        <script src="/js/jquery.prettyPhoto.js"></script>
        <script src="/js/jquery.isotope.min.js"></script>
        <script src="/js/jquery.inview.min.js"></script>
        <script src="/js/wow.min.js"></script>
        <script src="/js/bootstrap-treenav.min.js"></script>
        <script src="/js/prettify.js"></script>
        <script src="/js/zepto.js"></script>
        <script src="/js/jquery.waterfall.js"></script>   
        <script src="/js/main.js"></script>
        <script type="text/javascript">
            (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
                (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
                e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
            })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

            _st('install','zRzEsAUhWTTkrdEN2YfA','2.0.0');
        </script>
        <script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-72584442-1', 'auto');
            ga('send', 'pageview');
        </script> 
        <script>
            ChatraID = 'QDvZ76min4DhLW5vJ';
            (function(d, w, c) {
                var n = d.getElementsByTagName('script')[0],
                    s = d.createElement('script');
                w[c] = w[c] || function() {
                    (w[c].q = w[c].q || []).push(arguments);
                };
                s.async = true;
                s.src = (d.location.protocol === 'https:' ? 'https:': 'http:')
                    + '//call.chatra.io/chatra.js';
                n.parentNode.insertBefore(s, n);
            })(document, window, 'Chatra');
        </script>         
    </body>
</html>