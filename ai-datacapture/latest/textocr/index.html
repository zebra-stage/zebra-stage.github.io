
<!DOCTYPE html>
<html lang="en"><head>

    <meta charset="utf-8">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="-1">
    <meta http-equiv="CACHE-CONTROL" content="NO-CACHE">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Online Documentation for Zebra Technologies developer tools and utilties, including EMDK for Android, EMDK for Xamarin, StageNow and Enterprise Browser.">
    <meta name="author" content="Zebra Technologies">
    <meta name="google-site-verification" content="i4B78BrWnNy8ShJwe5feRW3jO3HE6gfYlYqYbxfl8yY">
    <meta name="msvalidate.01" content="6B651B00161BCE79B8950AC09D5C4C75">
    <meta title="Text OCR">
    <title>Text OCR - TechDocs</title>
    <!-- core CSS -->
    <link href="/css/bootstrap.min.css" rel="stylesheet">
<!--     
    <link href="/css/font-awesome.min.css" rel="stylesheet">
 -->    
    <link href="/css/all.css" rel="stylesheet">
    <link href="/css/v4-shims.css" rel="stylesheet">
    <link href="/css/animate.min.css" rel="stylesheet">
    <link href="/css/owl.carousel.css" rel="stylesheet">
    <link href="/css/owl.transitions.css" rel="stylesheet">
    <link href="/css/prettyPhoto.css" rel="stylesheet">
    <link href="/css/main.css" rel="stylesheet">
    <link href="/css/responsive.css" rel="stylesheet">
    <link href="/css/prettify.css" rel="stylesheet">
    <link href="/css/bootstrap-treenav.min.css" rel="stylesheet">
    <!--[if lt IE 9]>
    <script src="js/html5shiv.js"></script>
    <script src="js/respond.min.js"></script>
    <![endif]--> 

    <!-- 6/13/24- a "crown" icon randomly appeared in the MX matrix today. Rob said it looked like sumo. 
        <script src="//load.sumome.com/" data-sumo-site-id="699cb66cf4dc59352efb45705526d15cbe314e1cd43f7761b94d96f3cf7338e8" async="async"></script> -->
    <link rel="shortcut icon" href="/favicon.ico">
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-01QJCMQM9N"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-01QJCMQM9N');
</script><script src="/js/jquery.js"></script></head><!--/head-->

<!-- Google tag -->





<body id="home" class="homepage" data-spy="scroll" data-offset="100" data-target="#toc">

    <header id="header">
        <nav id="main-menu" class="navbar navbar-default navbar-fixed-top" role="banner">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/"><img src="/images/logo.png" alt="logo" style="max-height:66px;float: inherit;
    padding-right: 3px;"></a> 
                    
                   
                </div>
                <div class="collapse navbar-collapse navbar-left">
                    <ul class="nav navbar-nav">
                        <li class="navbar-text pull-left"><strong>TechDocs</strong></li>
                        <p class="navbar-text">
                                            AI Data Capture SDK
                        </p>

                    </ul>
                </div>
                <div class="collapse navbar-collapse navbar-right">
                    <ul class="nav navbar-nav">
                        


                        <li>
                            <a href="/ai-datacapture/latest/about">
                                    About
                            </a>
                        </li>
                        <li>
                            <a href="/ai-datacapture/latest/setup">
                                    Setup
                            </a>
                        </li>
                        <li>
                            <a href="/ai-datacapture/latest/localizer">
                                    Localizer
                            </a>
                        </li>
                        <li>
                            <a href="/ai-datacapture/latest/productrecognition">
                                    Product Recognition
                            </a>
                        </li>
                        <li>
                            <a href="/ai-datacapture/latest/barcodedecoder">
                                    Barcode Decoder
                            </a>
                        </li>
                        <li>
                            <a href="/ai-datacapture/latest/textocr">
                                    Text OCR
                            </a>
                        </li>
                        <li>
                            <a href="/ai-datacapture/latest/camerax">
                                    CameraX
                            </a>
                        </li>
                        <li>
                            <a href="/ai-datacapture/latest/search">
                                    <i class="fa fa-search"></i>
                            </a>
                        </li>
                        
                        <!-- <li ><a href="/products">SDKs</a></li>
                        <li ><a href="/samples">Samples</a></li>
                        <li ><a href="/guides">Guides</a></li>
                        <li ><a href="/tutorials">Tutorials</a></li>
                        <li ><a href="/apis">APIs</a></li> -->
                        <!-- <li><a href="#"><input type="text" class="st-default-search-input"></a></li> -->
                    </ul>
                </div>
            </div><!--/.container-->
        </nav><!--/nav-->
    </header><!--/header-->
<div class="container-fluid">
    <section id="blog">
        <div class="">
            <section class="content-with-sidebar">
            <div class="row">
                <div class="col-sm-3 hidden-sm hidden-xs" id="sidebar">
                    
                    
                    <nav id="toc" data-toggle="toc" data-spy="affix" style="height: 75%; max-width: 225px; overflow-y: auto; ">
                        
                        <ul class="nav">
                            <li><strong>Text OCR</strong></li>
                        </ul>
                    </nav>
                    <div class="modal fade" id="modal-smartdocs" tabindex="-1" role="dialog" aria-labelledby="basicModal" aria-hidden="true" data-backdrop="true">
                    	<div class="modal-dialog">
                    		<div class="modal-content">
                    			<div class="modal-header">
                    				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">X</button>
                    			</div>
                    			<div class="modal-body">
                    				<form>
                    				  <div class="form-group">
                    				    <label for="exampleInputEmail1">MX Version On Device:</label>
                    				    <select class="form-control">
                    					  <option value="4.0">4.0</option>
                    					  <option value="4.1">4.1</option>
                    					  <option value="4.2">4.2</option>
                    					  <option value="4.3">4.3</option>
                    					  <option value="5.0">5.0</option>
                    					</select>
                    				  </div>						
                    				  <div class="form-group">
                    				    <label for="exampleInputEmail1">OSX Version On Device:</label>
                    				    <select class="form-control">
                    					  <option value="1.0">1.0</option>
                    					  <option value="1.2">1.2</option>
                    					  <option value="1.3.4-56">1.3.4-56</option>
                    					  <option value="3.4">3.4</option>
                    					  <option value="3.5">3.5</option>
                    					  <option value="3.6">3.6</option>
                    					  <option value="4.1">4.1</option>
                    					  <option value="4.2">4.2</option>
                    					  <option value="4.3">4.3</option>
                    					  <option value="4.4">4.4</option>
                    					</select>
                    				  </div>						
                    				  <div class="form-group">
                    				    <label for="exampleInputEmail1">Android Version On Device:</label>
                    				    <select class="form-control">
                    					  <option value="23">6.0 Marshmallow</option>
                    					  <option value="22">5.1 Lollipop</option>
                    					  <option value="21">5.0 Lollipop</option>
                    					  <option value="19">4.4 Kitkat</option>
                    					  <option value="18">4.3 Jellybean</option>
                    					  <option value="17">4.2.x Jellybean</option>
                    					  <option value="16">4.1.x Jellybean</option>
                    					  <option value="15">4.0.3-4.0.4 Ice Cream Sandwich</option>
                    					  <option value="14">4.0-4.0.2 Ice Cream Sandwich</option>
                    					  <option value="10">2.3.3-2.3.4 Gingerbread</option>
                    					</select>
                    				  </div>
                    				  <div class="form-group">
                    				  	<button class="primary" id="btn_SaveSmartDocOptions">Save Changes</button><button class="primary" id="btn_ClearSmartDocOptions">Clear Changes</button>
                    				  </div>
                    				</form>
                    			</div>
                    	</div>
                      </div>
                    </div>
                    
                    <script type="text/javascript">
                        $(document).ready(function() {
                        	$( "#btn_SaveSmartDocOptions" ).click(function() {
                      			console.log('Saving Options');
                      			$("#modal-smartdocs").modal({show: false});
                    		});
                        	$( "#btn_SaveSmartDocOptions" ).click(function() {
                      			console.log('Clearing Options');
                      			$("#modal-smartdocs").modal({show: false});
                    		});
                        });
                    </script><link rel="stylesheet" href="https://cdn.rawgit.com/afeld/bootstrap-toc/v0.3.0/dist/bootstrap-toc.min.css">
                    <script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v0.3.0/dist/bootstrap-toc.min.js"></script>
                    <script type="text/javascript">
                        $(document).ready(function() {
                    
                        });
                    
                    
                    </script>
                </div>                
                <div class="col-sm-9 ">
                    <div class="row">
                        <div class="col-sm-12">
                            <section id="cta" class="wow fadeIn">
                                <div class="">
                                    <h1 id="text-ocr" class="anchor"><a class="heading-anchor" href="#text-ocr"><span></span></a>Text OCR</h1>
                                    <p>
                                            AI Data Capture SDK
                                    </p>
                                </div>
                            </section>                    
                        </div>
                    </div>
                    <div id="mainContent" class="row">
                        <div class="col-sm-12">
                            <div class="blog-post blog-large wow fadeInLeft" data-wow-duration="300ms" data-wow-delay="0ms">
                            <!-- Start of guide -->
                                <div class="service-box wow fadeInRight">
                                    <div class="">

                                        <p></p><h2 id="overview" class="anchor"><a class="heading-anchor" href="#overview"><span></span></a>Overview</h2>

<p>The <code>TextOCR</code> class leverages Optical Character Recognition (OCR) to detect, recognize, and group text from  images. It it processes images through three stages: Detection, Recognition, and Grouping. The flexibility of its parameters allows developers to fine-tune performance for diverse use cases, including document scanning, real-time recognition, and automated data entry.</p>

<p>This guide begins with initial instructions for basic setup of OCR. Subsequent sections offer a comprehensive list of OCR settings that can be fine-tuned for specific needs:</p>

<ul>
<li><a href="../class/inferenceroptions/">Inferencer Options</a></li>

<li><a href="#detectionparameters">Detection Parameters</a></li>

<li><a href="#recognitionparameters">Recognition Parameters</a>


<ul>
<li><a href="#tilersettings">Tiler Settings</a></li></ul>
</li>

<li><a href="#groupersettings">Grouper Settings</a></li>
</ul>

<p>For non-standard use cases, particularly for <a href="#groupersettings">Grouper Settings</a>, developers are encouraged to experiment with and adjust these parameters to optimize performance.</p>

<p>Additionally, the process() method of the <code>TextOCR</code> class can be utilized to detect and recognize text within images. This interface enables developers to build CameraX analyzers that integrate with other detectors. </p>

<hr>

<h2 id="capabilities" class="anchor"><a class="heading-anchor" href="#capabilities"><span></span></a>Capabilities</h2>

<h3 id="supportedcharacters" class="anchor"><a class="heading-anchor" href="#supportedcharacters"><span></span></a>Supported Characters</h3>

<p>TextOCR recognizes a range of characters, including:</p>

<pre class="prettyprint"><code>    *0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~*
</code></pre>

<p>By default, it supports a maximum word length of approximately 15 characters, though this limit may decrease with the use of uncommon fonts. Enabling <a href="#tilersettings">tiling</a> removes this restriction.</p>

<h3 id="inputoutput" class="anchor"><a class="heading-anchor" href="#inputoutput"><span></span></a>Input/Output</h3>

<p><strong>Input Parameters:</strong> The default model input size is 640x640 pixels, but this can be adjusted during runtime initialization.</p>

<p><strong>Output Parameters:</strong> The output consists of a list of text detections, each accompanied by a list of <a href="../types/#complexbbox">complex bounding boxes</a> that define the location and content of the detected text.</p>

<hr>

<h2 id="configuration" class="anchor"><a class="heading-anchor" href="#configuration"><span></span></a>Configuration</h2>

<p>Before starting with TextOCR, configure key settings such as model input size, resolution, and inference type. Changes to these settings will require reinitializing the models. Information on configuring these settings are provided in the sections that follow.</p>

<h3 id="modelinputsize" class="anchor"><a class="heading-anchor" href="#modelinputsize"><span></span></a>Model Input Size</h3>

<p>The Model Input Size defines the resolution at which the AI processes images. Before analysis, images are resized to this dimension. Adjusting this size balances speed and accuracy.  </p>

<p><strong>Key Considerations:</strong></p>

<ul>
<li>Start with the default resolution 640x640 for optimal processing. </li>

<li>If the results are not sufficiently accurate for small text, increasing the resolution can improve precision.</li>
</ul>

<table class="facelift" style="width:20" border="1" padding="5px">  
  <thead>
    <tr bgcolor="#dce8ef">
      <th>Input Size</th>
      <th>Best For</th>
      <th>Use Case</th>
      <th>Consideration</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Smaller (e.g., 640x640)</td>
      <td>Speed: Faster processing</td>
      <td>Large or close text</td>
      <td>Reduced accuracy for small text</td>
    </tr>
    <tr>
      <td>Larger (e.g., 1600x1600)</td>
      <td>Accuracy: Better for details</td>
      <td>Fine print, distant, or dense text</td>
      <td>Slower processing, higher memory usage</td>
    </tr>
    <tr>
      <td>Custom (Multiples of 32, e.g., 800x800)</td>
      <td>Balancing speed and accuracy</td>
      <td>Low-contrast or medium-sized text</td>
      <td>Requires experimentation to find the optimal setting</td>
    </tr>
  </tbody>
</table>

<p><br></p>

<h3 id="resolution" class="anchor"><a class="heading-anchor" href="#resolution"><span></span></a>Resolution</h3>

<p>Camera resolution refers to the number of pixels the device’s camera sensor can capture (e.g., 1MP = 1280x720, 8MP = 3840x2160). It determines the quality of the source image before any resizing occurs for AI processing.</p>

<p>Higher camera resolution provides a more detailed and higher-quality original image, which can significantly enhance the AI model's ability to detect and recognize small, faint, or distant text. However, this increased detail comes at the cost of greater processing power and memory usage.</p>

<p><strong>Key Considerations:</strong></p>

<ul>
<li><strong>Impact of Camera Resolution -</strong> Higher resolutions enhance input image detail, aiding in recognizing small, low-contrast, or distant text. However, images are downscaled to the model's input size for processing, so the benefits of high-resolution cameras diminish with low model input sizes.</li>

<li><strong>General Guidance -</strong> Aim for a minimum text height of 16 pixels in the input image, adjusting for font size and camera distance from the target.</li>
</ul>

<table class="facelift" style="width:20" border="1" padding="5px">  
  <thead>
    <tr bgcolor="#dce8ef">
      <th>Resolution</th>
      <th>Best For</th>
      <th>Use Case</th>
      <th>Consideration</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1MP (1280x720)</td>
      <td>Speed, power efficiency</td>
      <td>Large/simple text</td>
      <td>May miss fine details</td>
    </tr>
    <tr>
      <td>2MP (1920x1080)</td>
      <td>General use</td>
      <td>Stylized or moderately detailed text</td>
      <td>Balanced performance</td>
    </tr>
    <tr>
      <td>4MP (2688x1512)</td>
      <td>Detailed scans</td>
      <td>Contracts, forms, dense text</td>
      <td>Higher memory and battery use</td>
    </tr>
    <tr>
      <td>8MP (3840x2160)</td>
      <td>Maximum detail</td>
      <td>Archival purposes</td>
      <td>Large files, diminishing returns for low input sizes</td>
    </tr>
  </tbody>
</table>

<p><br></p>

<p><strong>Relationship Between Model Input Size and Camera Resolution:</strong></p>

<table class="facelift" style="width:20" border="1" padding="5px">  
  <thead>
    <tr bgcolor="#dce8ef">
      <th>Resolution</th>
      <th>Low Input Size (e.g., 640x640)</th>
      <th>High Input Size (e.g., 1600x1600)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Low Resolution (e.g., 1MP / 1280x720)</strong></td>
      <td>
        <strong>Speed:</strong> Fastest<br>
        <strong>Accuracy:</strong> Lowest<br>
        <strong>Use Case:</strong> Large, clear text close to the camera<br>
        <strong>Note:</strong> Small/fine details may be lost
      </td>
      <td>
        <strong>Not Recommended:</strong> Wasted computation with little accuracy gain
      </td>
    </tr>
    <tr>
      <td><strong>High Resolution (e.g., 8MP / 3840x2160)</strong></td>
      <td>
        <strong>Speed:</strong> Fast<br>
        <strong>Accuracy:</strong> Moderate<br>
        <strong>Use Case:</strong> Large/medium text, quick scans<br>
        <strong>Note:</strong> High-resolution source is downsampled for AI, so small text may still be missed
      </td>
      <td>
        <strong>Speed:</strong> Slowest<br>
        <strong>Accuracy:</strong> Highest<br>
        <strong>Use Case:</strong> Detailed, small, dense, or distant text<br>
        <strong>Note:</strong> High memory and battery usage; may stress low-end devices
      </td>
    </tr>
  </tbody>
</table>

<p><br></p>

<h3 id="inferencetypeprocessor" class="anchor"><a class="heading-anchor" href="#inferencetypeprocessor"><span></span></a>Inference Type (Processor)</h3>

<p>The <strong>Inference Type</strong> specifies which chip on the device is responsible for performing AI computations (referred to as "inference"). This choice directly impacts the speed and efficiency of image processing.</p>

<p><strong>Key Considerations:</strong></p>

<ul>
<li><strong>DSP (Digital Signal Processor) -</strong> Use DSP if available, as it is specifically designed for real-time, energy-efficient AI tasks and provides optimal performance.</li>

<li><strong>GPU (Graphics Processing Unit) -</strong> If DSP is not available, the GPU serves as an alternative for handling AI workloads efficiently. </li>
</ul>

<table class="facelift" style="width:20" border="1" padding="5px">  
  <thead>
    <tr bgcolor="#dce8ef">
      <th>Processor</th>
      <th>Description</th>
      <th>Performance</th>
      <th>Use Case</th>
      <th>Device Platform</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>DSP (Digital Signal Processor)</strong></td>
      <td>
        Optimized for real-time, energy-efficient tasks. Ideal for specific AI workloads where battery life and efficiency are critical.
      </td>
      <td>
        <ul>
          <li><strong>Best:</strong> Fastest and most efficient.</li>
          <li>Preserves battery life during continuous use.</li>
        </ul>
      </td>
      <td>
        Best choice for real-time, low-energy tasks such as edge AI inference.
      </td>
      <td><strong>Best for:</strong> SD6490, SD5430 FP2; for relevant device models, visit <a href="https://supportcommunity.zebra.com/s/article/000022440?language=en_US">Zebra Platform Devices</a></td>
    </tr>
    <tr>
      <td><strong>GPU (Graphics Processing Unit)</strong></td>
      <td>
        Designed for heavy, parallel AI tasks and complex models. Suitable for computationally intensive workloads.
      </td>
      <td>
        <ul>
          <li><strong>Good:</strong> High-speed performance but consumes more power than DSP.</li>
          <li>Handles large-scale parallel tasks effectively.</li>
        </ul>
      </td>
      <td>
        Best for handling complex AI models or tasks requiring significant computational power.
      </td>
      <td><strong>Best for:</strong> SD4490, SD5430 FP1<br><strong>Good for:</strong> SD6490, SD5430 FP2; for relevant device models, visit <a href="https://supportcommunity.zebra.com/s/article/000022440?language=en_US">Zebra Platform Devices</a></td>
    </tr>
    <tr>
      <td><strong>CPU (Central Processing Unit)</strong></td>
      <td>
        Acts as the fallback processor for AI inference tasks. Always available but less efficient compared to DSP and GPU.
      </td>
      <td>
        <ul>
          <li><strong>Fallback:</strong> Slower and less efficient but always available.</li>
          <li>Consumes more power, making it less suitable for continuous tasks.</li>
        </ul>
      </td>
      <td>
        Suitable for lightweight tasks or as a fallback when DSP or GPU are unavailable or causing issues.
      </td>
      <td><strong>Fallback for:</strong> SD6490, SD4490, SD5430 FP2, SD5430 FP1; for relevant device models, visit <a href="https://supportcommunity.zebra.com/s/article/000022440?language=en_US">Zebra Platform Devices</a></td>
    </tr>
  </tbody>
</table>

<hr>

<h2 id="stagesoftextocr" class="anchor"><a class="heading-anchor" href="#stagesoftextocr"><span></span></a>Stages of TextOCR</h2>

<p>The <strong>Text OCR</strong> process consists of three stages:</p>

<ol>
<li><strong>Text Detection -</strong> Identifies and filters text boxes within the image</li>

<li><strong>Text Recognition -</strong> Reads and extracts text content from each identified text box. </li>

<li><strong>Text Grouping -</strong> Organizes recognized words into lines or paragraphs. </li>
</ol>

<p>Information about each stage is provided in the subsequent sections.</p>

<!--
1. **Detection -** Identifies and filters text boxes with the image. Processes the input image to generate text boxes (complex bbox), represented by rectangular frames that enclose detected objects within an image. [Detection Parameters](#detectionparameters) can be adjusted to fine-tune what is detected.
2. **Recognition -** Analyzes the text within each text box to recognize the text content. Each text box yields a list of potential text decodes. [Recognition Parameters](#recognitionparameters) can be adjusted to refine the recognition process.
3. **Grouping -** It offers methods for identifying text, words, and paragraphs across various image formats, with options to customize the output, such as grouping detected words into "lines" or grouping lines into "paragraphs."
-->

<h3 id="stage1textdetection" class="anchor"><a class="heading-anchor" href="#stage1textdetection"><span></span></a>Stage 1: Text Detection</h3>

<p>The text detection process occurs in two main stages:</p>

<ol>
<li><strong>Heatmap Threshold (Pixel-Level Filtering) -</strong> A heatmap is generated where each pixel is assigned a score indicating the likelihood of it being part of a text character. The <strong>Heatmap Threshold</strong> filters out individual pixels based on these scores, retaining only the most probable candidates.</li>

<li><strong>Box Threshold (Box-Level Filtering) -</strong> After pixel filtering, the system identifies groups of pixels and draws bounding boxes around them. Each box is assigned a confidence score, and the <strong>Box Threshold</strong> filters out boxes with low confidence, retaining only those likely to contain text.</li>
</ol>

<h4 id="filteringparameters" class="anchor"><a class="heading-anchor" href="#filteringparameters"><span></span></a>Filtering Parameters</h4>

<p>Once potential text boxes are identified, additional filtering can be applied to refine results by eliminating noise or unwanted detections. These filters also allow adjustments to the image and bounding box handling:</p>

<ul>
<li><strong>Min Box Size (Filtering Narrow Boxes) -</strong> Removes text boxes that are too narrow or short, such as underscores, divider lines, or other elongated shapes that are unlikely to contain text.</li>

<li><strong>Min Box Area (Filtering Small Boxes) -</strong> Excludes text boxes with a total area (width × height) that is too small. This is particularly effective for ignoring noise such as tiny specks or dots in the image.</li>

<li><strong>Unclip Ratio (Expanding Box Size) -</strong> Expands the bounding boxes after they are detected but before text recognition occurs. Initial bounding boxes are often tightly fitted to the text, and this parameter increases their size to include some background, improving text recognition accuracy.</li>

<li><strong>Min Ratio for Rotation (Handling Vertical Text) -</strong> Rotates vertically oriented boxes (e.g., bottom-up or top-down text) to a horizontal orientation for better recognition. Applies only to boxes with a height-to-width ratio exceeding the specified value, rotating them 90 degrees to facilitate decoding.</li>
</ul>

<table class="facelift" style="width:20" border="1" padding="5px">  
  <thead>
    <tr bgcolor="#dce8ef">
      <th>Parameter</th>
      <th>Description</th>
      <th>Guidance</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Heatmap Threshold</strong></td>
      <td>
        Minimum pixel confidence for potential text regions. (Pixel-level filtering)
      </td>
      <td>
        <ul>
          <li><strong>↑</strong> To cut noise, best for clear text or high contrast.</li>
          <li><strong>↓</strong> To capture faint, curved, or blurred text with low contrast.</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><strong>Box Threshold</strong></td>
      <td>
        Filters detected boxes by their overall confidence. (Box-level filtering)
      </td>
      <td>
        <ul>
          <li><strong>↑</strong> To reduce false positives.</li>
          <li><strong>↓</strong> To catch weak detections.</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><strong>Min Box Size</strong></td>
      <td>
        Filters out text boxes that are too narrow or too short. (Filtering "skinny" boxes)
      </td>
      <td>
        <ul>
          <li><strong>↑</strong> To ignore divider lines, underscores, or non-text lines.</li>
          <li><strong>↓</strong> To detect smaller text.</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><strong>Min Box Area</strong></td>
      <td>
        Filters out text boxes if their total area (width × height) is too small. (Filtering "tiny" boxes)
      </td>
      <td>
        <ul>
          <li><strong>↑</strong> To eliminate dust, dots, or tiny artifacts.</li>
          <li><strong>↓</strong> To allow smaller text or marks.</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><strong>Unclip Ratio</strong></td>
      <td>
        Expands or "stretches" detected boxes outward to include full characters and some background. (Expands box size)
      </td>
      <td>
        <ul>
          <li><strong>↑</strong> For curved, rotated, or incomplete detections.</li>
          <li><strong>↓</strong> To avoid overlapping with neighboring text regions or noisy regions.</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><strong>Min Ratio for Rotation</strong></td>
      <td>
        Rotates vertically (high height, low width) oriented boxes so they become horizontal. (Rotates vertical boxes)
      </td>
      <td>
        Only adjust if the images contain many rotated texts (e.g., upright or vertical text).
      </td>
    </tr>
  </tbody>
</table>

<p><strong>Legend:</strong></p>

<ul>
<li><strong>↑:</strong> Increase the value of the parameter.</li>

<li><strong>↓:</strong> Decrease the value of the parameter.</li>
</ul>

<h3 id="stage2textrecognition" class="anchor"><a class="heading-anchor" href="#stage2textrecognition"><span></span></a>Stage 2: Text Recognition</h3>

<p>After text boxes are detected, the next step is to extract and accurately read the text within each bounding box.
AI Suite uses the <strong>"Total" decoder</strong> to convert character predictions into meaningful words, even in cases where the model is uncertain about specific characters. </p>

<p>The <strong>"Total" decoder</strong> evaluates all possible character options for each position and balances confidence and flexibility using two key parameters: <strong>TopK Ignore Cutoff, Total Prob Threshold,</strong> and <strong>Max Word Combinations.</strong> These parameters act as filters to refine predictions and determine the final output.</p>

<h4 id="decoderparameters" class="anchor"><a class="heading-anchor" href="#decoderparameters"><span></span></a>Decoder Parameters</h4>

<table class="facelift" style="width:20" border="1" padding="5px">  
  <thead>
    <tr bgcolor="#dce8ef">
      <th>Parameter</th>
      <th>Description</th>
      <th>Guidance</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>TopK Ignore Cutoff</strong> <br> <i>The Gatekeeper</i></td>
      <td>
        The maximum number of highest-confidence character predictions the "Total" decoder considers for each character position. If additional are needed to meet the <b>Total Prob Threshold,</b> the model outputs a replacement character (e.g., "�").
      </td>
      <td>
        <ul>
          <li><strong>↑</strong> If the desired character isn’t appearing, allow more guesses.</li>
          <li>Leave at default for most cases; adjust only if necessary.</li>
        </ul>
      </td>
      <td>
        <strong>Example:</strong>  
        If predictions are: 'S' (40%), 's' (30%), '5' (15%), 'B' (5%), '8' (2%) And the cutoff is set to 4, only the top four predictions ('S', 's', '5', 'B') are retained. '8' and lower-ranked options are discarded.
      </td>
    </tr>
    <tr>
      <td><strong>Total Prob Threshold</strong> <br> <i>The Quality Check</i></td>
      <td>
        The minimum cumulative confidence score required for a word prediction to be accepted. If the total score is below the threshold, the model outputs a replacement character (e.g., "�").
      </td>
      <td>
        <ul>
          <li><strong>↑</strong> For more flexible but potentially noisier results.</li>
          <li><strong>↓</strong> For more trustworthy, reliable outputs.</li>
        </ul>
      </td>
      <td>
        <strong>Example:</strong> Using the predictions above, their combined confidence is:  
        0.40 (S) + 0.30 (s) + 0.15 (5) + 0.05 (B) = 0.90. If the threshold is 0.85, the decoder proceeds. If the combined score is less, it outputs a replacement character (e.g., "�").
      </td>
    </tr>
    <tr>
      <td><strong>Max Word Combinations</strong> <br> <i>Result Limiter</i></td>
      <td>
        Restricts the number of valid word outputs generated from possible character combinations for each detection. This helps avoid overwhelming results, particularly for ambiguous inputs, by limiting the model’s consideration of all potential character combinations across all positions in the word.
      </td>
      <td>
        <ul>
          <li><strong>↑</strong> For tougher, longer words to see more possible outputs.</li>
          <li><strong>↓</strong> For faster processing and fewer alternatives.</li>
        </ul>
      </td>
      <td>
        <strong>Example:</strong> Suppose there are 20 possible valid word combinations after applying the above filters. If Max Word Combinations is set to 5, only the top 5 most confident word outputs are returned. The other 15 combinations are ignored, even if valid.
      </td>
    </tr>
  </tbody>
</table>

<p><strong>Legend:</strong></p>

<ul>
<li><strong>↑:</strong> Increase the value of the parameter.</li>

<li><strong>↓:</strong> Decrease the value of the parameter.</li>
</ul>

<h4 id="recognitionspecialcases" class="anchor"><a class="heading-anchor" href="#recognitionspecialcases"><span></span></a>Recognition: Special Cases</h4>

<p>These features are designed for specific scenarios and are generally not required for most OCR tasks. Use them only when needed to address unique text recognition challenges.</p>

<h5 id="flip" class="anchor"><a class="heading-anchor" href="#flip"><span></span></a>Flip</h5>

<p>Runs recognition in multiple orientations to improve accuracy for rotated or flipped text. While this increases accuracy for text in varying orientations, it also adds processing time.</p>

<table class="facelift" style="width:20" border="1" padding="5px">  
  <thead>
    <tr bgcolor="#dce8ef">
      <th>What It Does</th>
      <th>When/How to Adjust It</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        Runs recognition in multiple orientations to handle rotated or flipped text.
      </td>
      <td>
        <ul>
          <li><strong>Enable:</strong> If text orientation varies significantly.</li>
          <li><strong>Disable:</strong> For standard horizontal text to reduce processing time.</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<h5 id="tiling" class="anchor"><a class="heading-anchor" href="#tiling"><span></span></a>Tiling</h5>

<p>Splits very long, thin lines of text (e.g., serial numbers, document titles, part numbers) into smaller, manageable "tiles" for better recognition. This is useful when a word box exceeds the recognition limit (15 characters). While tiling improves accuracy, it also adds processing time, so it should be used only when necessary.</p>

<table class="facelift" style="width:20" border="1" padding="5px">  
  <thead>
    <tr bgcolor="#dce8ef">
      <th>Parameter</th>
      <th>What It Does</th>
      <th>When/How to Adjust It</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Aspect Ratio Lower Threshold</strong></td>
      <td>
        Sets the minimum width-to-height ratio for boxes to be tiled. Only boxes wider than this value are tiled, helping to control which boxes are considered "elongated."
      </td>
      <td>
        <ul>
          <li><strong>↑</strong> To tile only very long boxes.</li>
          <li><strong>↓</strong> To tile shorter boxes, resulting in more tiled boxes.</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><strong>Aspect Ratio Upper Threshold</strong></td>
      <td>
        Sets the maximum width-to-height ratio for boxes to be tiled. Only boxes up to this ratio get tiled. This prevents extremely long or oddly shaped boxes from being tiled.
      </td>
      <td>
        <ul>
          <li><strong>↑</strong> To allow longer boxes to be tiled.</li>
          <li><strong>↓</strong> To avoid tiling very stretched or oddly shaped boxes.</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><strong>TopK Merged Predictions</strong></td>
      <td>
        Limits the number of "best guess" decodes returned after tiling.
      </td>
      <td>
        <ul>
          <li><strong>↑</strong> To see more possible results for review.</li>
          <li><strong>↓</strong> For fewer, faster results.</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<p><strong>Legend:</strong></p>

<ul>
<li><strong>↑:</strong> Increase the value of the parameter.</li>

<li><strong>↓:</strong> Decrease the value of the parameter.</li>
</ul>

<h3 id="stage3textgrouping" class="anchor"><a class="heading-anchor" href="#stage3textgrouping"><span></span></a>Stage 3: Text Grouping</h3>

<p><strong>Text grouping</strong> is used to organize OCR results into logical chunks, such as lines and paragraphs, for better structure and readability. The grouping process relies on several parameters that define spacing, alignment, and font size differences.</p>

<table class="facelift" style="width:20" border="1" padding="5px">  
  <thead>
    <tr bgcolor="#dce8ef">
      <th>Parameter</th>
      <th>What It Does</th>
      <th>When/How to Adjust It</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Width Distance Ratio</strong></td>
      <td>
        Defines how much space is allowed between words before they are considered part of separate lines.
      </td>
      <td>
        <ul>
          <li><strong>↑</strong> If wide spaces between words should still be grouped in the same line.</li>
          <li><strong>↓</strong> If words are being incorrectly joined into the same line.</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><strong>Height Distance Ratio</strong></td>
      <td>
        Allows grouping of words into a single line even if their font sizes are significantly different.
      </td>
      <td>
        <ul>
          <li><strong>↑</strong> If words with different font sizes should be grouped together in a line.</li>
          <li><strong>↓</strong> If large font-size differences are causing messy groupings.</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><strong>Center Distance Ratio</strong></td>
      <td>
        Enables grouping of words into a single line even if they are not perfectly aligned (e.g., curved or wavy text).
      </td>
      <td>
        <ul>
          <li><strong>↑</strong> If curved or zigzag text should be grouped in the same line.</li>
          <li><strong>↓</strong> If only straight lines should be grouped together.</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><strong>Paragraph Height Distance</strong></td>
      <td>
        Specifies the maximum distance between lines that can still be grouped into the same paragraph.
      </td>
      <td>
        <ul>
          <li><strong>↑</strong> If lines spaced far apart should still be grouped into one paragraph.</li>
          <li><strong>↓</strong> If too many lines are being grouped into a single paragraph.</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><strong>Paragraph Height Ratio Threshold</strong></td>
      <td>
        Allows lines with very different heights (font sizes) to be grouped into the same paragraph.
      </td>
      <td>
        <ul>
          <li><strong>↑</strong> If lines with similar font sizes should be grouped.</li>
          <li><strong>↓</strong> To allow lines with very different font sizes to be grouped together.</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<p><strong>Legend:</strong></p>

<ul>
<li><strong>↑:</strong> Increase the value of the parameter.</li>

<li><strong>↓:</strong> Decrease the value of the parameter.</li>
</ul>

<hr>

<h2 id="developerguide" class="anchor"><a class="heading-anchor" href="#developerguide"><span></span></a>Developer Guide</h2>

<p>This guide outlines the process for using TextOCR to detect and recognize text within images, from initialization to outputting the identified text.</p>

<h3 id="step1initialization" class="anchor"><a class="heading-anchor" href="#step1initialization"><span></span></a>Step 1: Initialization</h3>

<p>Follow these steps to set up and initialize a <code>TextOCR</code> object:</p>

<ol>
<li><p><strong>Import the TextOCR class</strong> using <code>com.zebra.ai.vision.detector.TextOCR</code>.</p></li>

<li><p><strong>Configure OCR Settings:</strong> Create a <code>TextOCR.Settings</code> object.</p></li>

<li><p><strong>Optional: Set model input dimensions:</strong> If needed, customize the model input dimensions (height and width). These should be multiples of 32 (e.g., 640).</p>

<pre class="prettyprint"><code>settings.detectionInferencerOptions.defaultDims.width = [your value];
settings.detectionInferencerOptions.defaultDims.height = [your value];
</code></pre>

<ul>
<li><strong>Smaller Input Sizes -</strong> Reduce processing time and increase speed, but may decrease accuracy. Ideal for larger or closer text.</li>

<li><strong>Larger Input Sizes -</strong> Improve accuracy for smaller or more distant text, but increase inference time. An input size that is too large may cause out-of-memory errors and potentially cause an application crash at run-time.</li></ul></li>

<li><p><strong>Optional: Configure the additional OCR settings to optimize detection and recognition:</strong></p>

<ul>
<li><a href="#groupersettings">Grouper Settings</a></li>

<li><a href="#tilersettings">Tiler Settings</a></li>

<li><a href="#recognitionparameters">Recognition Parameters</a></li>

<li><a href="#detectionparameters">Detection Parameters</a></li>

<li><a href="../class/inferenceroptions/">Inferencer Options</a></li></ul></li>

<li><p><strong>Initialize the OCR object -</strong> Declare a <code>TextOCR</code> object. Use <code>CompletableFuture</code> to initialize it asynchronously with an <code>Executor</code> for concurrent processing.</p></li>

<li><p><strong>Callback Handling -</strong> Use <code>thenAccept()</code> to assign the initialized <code>TextOCR</code> object to the <code>textocr</code> variable, enabling it for text detection tasks like barcodes and products in images.</p></li>
</ol>

<h4 id="samplecode" class="anchor"><a class="heading-anchor" href="#samplecode"><span></span></a>Sample Code</h4>

<p>Initialization sample code:</p>

<pre class="prettyprint"><code>    import com.zebra.ai.vision.TextOCR;

    TextOCR.Settings settings = new TextOCR.Settings();

    // Optional: Override the default model input size
    settings.detectionInferencerOptions.defaultDims.width = 1280;
    settings.detectionInferencerOptions.defaultDims.height = 1280;

    // Initialize OCR object
    TextOCR textocr = null;

    // Initialize textocr
    // settings = TextOCR.Settings object created above
    // Executor = An executor thread for processing API calls and returning results
    CompletableFuture&lt;TextOCR&gt; futureObject = getTextOCR(settings, executor);

    // Use the futureObject to implement the thenAccept() callback of CompletableFuture
    futureObject.thenAccept (OCRInstance -&gt; {
        // Use the Textocr object returned here for detecting barcodes/Shelves/products
        textocr = OCRInstance;
    });
</code></pre>

<h3 id="step2captureimage" class="anchor"><a class="heading-anchor" href="#step2captureimage"><span></span></a>Step 2: Capture Image</h3>

<p>Capture the image and ensure the image is in the form of a Bitmap.</p>

<h3 id="step3detecttext" class="anchor"><a class="heading-anchor" href="#step3detecttext"><span></span></a>Step 3: Detect Text</h3>

<p>Use one of the following methods to detect text within an image, based on the type of text to detect:</p>

<ul>
<li><p><strong>Generic Text -</strong> Outputs text in <a href="../types/#complexbbox">complex bounding boxes</a>. Sample code:</p>

<pre class="prettyprint"><code>Bitmap image = ... // Your bitmap image here

// Initialize executor
Executor executor = Executors.newFixedThreadPool(1);

// Input parameters include a bitmap image and an executor thread object for performing detections
CompletableFuture&lt;OCRResult[]&gt; futureResult = textocr.detect(bitmap,executor);

futureResult.thenAccept (ocrResults -&gt; {
    // Process the returned output that contains complex bounding boxes and text within
});

// Once finished with the textOCR object, dispose of it to release resources and memory used during detection.
textOCR.dispose();
</code></pre></li>

<li><p><strong>Words –</strong> Outputs an array of <a href="../types/#word">words</a>. A word is a discrete unit of text identified within an image, typically separated by spaces or punctuation. Sample code:</p>

<pre class="prettyprint"><code>Bitmap image = ... // Your bitmap image here

// Initialize executor
Executor executor = Executors.newFixedThreadPool(1);

// Input parameters include a bitmap image and an executor thread object for performing detections
CompletableFuture&lt;Word[]&gt; futureWords = textocr.detectWords(bitmap,executor);

futureWords.thenAccept (words -&gt; {
    // Process the returned array of detected words
});

// Once finished with the textOCR object, dispose of it to release resources and memory used during detection
textOCR.dispose();
</code></pre></li>

<li><p><strong>Paragraphs -</strong> Outputs a hierarchical structure of <a href="../types/#textparagraph">paragraphs</a> using the grouping mechanism described in <a href="#textocrgroupersettings">Grouper Settings</a>. A paragraph is formed by grouping words that appear on the same line, and these lines are then organized into paragraphs. The process is parameterized, with relevant parameters detailed in the Grouper Settings. Sample code:</p>

<pre class="prettyprint"><code>Bitmap image = ... // Your bitmap image here

// Initialize executor
Executor executor = Executors.newFixedThreadPool(1);

// Input parameters include a bitmap image and an executor thread object for performing detection
CompletableFuture&lt;TextParagraph[]&gt; futureTextParagraph = textOCR.detectParagraphs(bitmap,executor);

futureTextParagraph.thenAccept (paragraphs -&gt; {
    // Process the returned array of detected paragraphs.
});

// Once finished with the textOCR object, dispose of it to release resources and memory used during detection
textOCR.dispose();
</code></pre></li>
</ul>

<hr>

<h2 id="methods" class="anchor"><a class="heading-anchor" href="#methods"><span></span></a>Methods</h2>

<h3 id="textocrsettingssettings" class="anchor"><a class="heading-anchor" href="#textocrsettingssettings"><span></span></a>TextOCR (Settings settings)</h3>

<pre class="prettyprint"><code>    TextOCR.TextOCR(Settings settings) throws IOException
</code></pre>

<p><strong>Description:</strong> Initializes the OCR engine with the specified settings, allowing subsequent text detection and analysis on image inputs. It checks for the necessary model file and verifies the integrity of the archive. If issues are detected, appropriate exceptions are thrown.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><strong>settings TextOCR.Settings -</strong> An instance of the <code>Settings</code> class containing configuration options for the OCR engine.</li>
</ul>

<p><strong>Return Value:</strong> <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html">CompletableFuture</a>&lt;TextOCR&gt;</p>

<p><strong>Exceptions:</strong></p>

<ul>
<li><strong>IOException -</strong> Thrown if the archive is corrupted.</li>
</ul>

<hr>

<h3 id="detectbitmapsrcimgexecutorexecutor" class="anchor"><a class="heading-anchor" href="#detectbitmapsrcimgexecutorexecutor"><span></span></a>detect (Bitmap srcImg, Executor executor)</h3>

<pre class="prettyprint"><code>    CompletableFuture&lt;OCRResult[]&gt; detect (Bitmap srcImg, Executor executor) throws InvalidInputException, IllegalStateException
</code></pre>

<p><strong>Description:</strong> Performs Optical Character Recognition (OCR) on the provided Bitmap image, using the specified executor for asynchronous execution.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><strong>srcImg (Bitmap srcImg) -</strong> The Bitmap image to perform OCR on.</li>

<li><strong>executor -</strong> Manages asynchronous task execution.</li>
</ul>

<p><strong>Return Value:</strong> A <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html">CompletableFuture</a> that resolves to an array of <a href="../types/#ocrresult">OCRResult</a>, each containing <a href="../types/#complexbbox">complex bounding boxes</a> and recognized text.</p>

<p><strong>Exceptions:</strong></p>

<ul>
<li><strong>InvalidInputException -</strong> Thrown if the Bitmap is null.</li>

<li><strong>IllegalStateException -</strong> Thrown if the OCR engine is in an invalid state for detection.</li>
</ul>

<hr>

<h3 id="detectwordsbitmapsrcimgexecutorexecutor" class="anchor"><a class="heading-anchor" href="#detectwordsbitmapsrcimgexecutorexecutor"><span></span></a>detectWords (Bitmap srcImg, Executor executor)</h3>

<pre class="prettyprint"><code>    CompletableFuture&lt;Word[]&gt; TextOCR.detectWords (Bitmap srcImg, Executor executor) throws InvalidInputException, IllegalStateException
</code></pre>

<p><strong>Description:</strong> Detects individual words in the provided Bitmap image using the specified executor for asynchronous execution.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><strong>srcImg (Bitmap srcImg) -</strong> The image to analyze for word detection.</li>

<li><strong>Executor -</strong> Manages asynchronous task execution.</li>
</ul>

<p><strong>Return Value:</strong> A <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html">CompletableFuture</a> that resolves to an array of Word objects, each containing <a href="../types/#complexbbox">complex bounding boxes</a> and possible text decodes.</p>

<p><strong>Exceptions:</strong></p>

<ul>
<li><strong>InvalidInputException -</strong> Thrown if the Bitmap is null.</li>

<li><strong>IllegalStateException -</strong> Thrown if the OCR engine is in an invalid state for performing word detection.</li>
</ul>

<hr>

<h3 id="detectparagraphsbitmapsrcimgexecutorexecutor" class="anchor"><a class="heading-anchor" href="#detectparagraphsbitmapsrcimgexecutorexecutor"><span></span></a>detectParagraphs (Bitmap srcImg, Executor executor)</h3>

<pre class="prettyprint"><code>    CompletableFuture&lt;TextParagraph[]&gt; detectParagraphs(Bitmap srcImg, Executor executor) throws InvalidInputException, IllegalStateException
</code></pre>

<p><strong>Description:</strong> Detects paragraphs in the provided Bitmap image using the specified executor for asynchronous execution.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><strong>srcImg (Bitmap srcImg) -</strong> The image to analyze for paragraph detection.</li>

<li><strong>executor -</strong> Manages asynchronous task execution.</li>
</ul>

<p><strong>Return Value:</strong> A <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html">CompletableFuture</a> that resolves to an array of TextParagraph objects, representing detected paragraphs.</p>

<p><strong>Exceptions:</strong></p>

<ul>
<li><strong>InvalidInputException -</strong> Thrown if the Bitmap is null.</li>

<li><strong>IllegalStateException -</strong> Thrown if the OCR engine is in an invalid state for performing paragraph detection.</li>
</ul>

<hr>

<h3 id="gettextocrsettingssettingsexecutorexecutor" class="anchor"><a class="heading-anchor" href="#gettextocrsettingssettingsexecutorexecutor"><span></span></a>getTextOCR (Settings settings, Executor executor)</h3>

<pre class="prettyprint"><code>    CompletableFuture&lt;TextOCR&gt; getTextOCR(Settings settings, Executor executor) throws InvalidInputException, RuntimeException
</code></pre>

<p><strong>Description:</strong> Asynchronously initializes and retrieves a TextOCR instance using the specified settings and executor.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><strong>Settings -</strong> An instance of <code>TextOCR.Settings</code> containing configuration options for the OCR engine.</li>

<li><strong>executor -</strong> Manages asynchronous task execution.</li>
</ul>

<p><strong>Return Value:</strong> A <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html">CompletableFuture</a> that resolves to an initialized TextOCR instance.</p>

<p><strong>Exceptions:</strong></p>

<ul>
<li><strong>InvalidInputException -</strong> Thrown if the settings are invalid or null.</li>

<li><strong>RuntimeException -</strong> Thrown if an unexpected error occurs during initialization.</li>
</ul>

<hr>

<h3 id="dispose" class="anchor"><a class="heading-anchor" href="#dispose"><span></span></a>Dispose()</h3>

<pre class="prettyprint"><code>    void dispose()
</code></pre>

<p><strong>Description:</strong> Releases all internal resources used by the TextOCR object. This function must be called manually to free up resources.</p>

<hr>

<h2 id="textocrsettings" class="anchor"><a class="heading-anchor" href="#textocrsettings"><span></span></a>TextOCR.Settings</h2>

<p>The <code>Settings</code> class is a nested class within the <code>TextOCR</code> class, designed to configure various parameters required for performing Optical Character Recognition (OCR). It allows for fine-tuning of the OCR process through settings related to detection, recognition, and decoding.</p>

<hr>

<h3 id="constructors" class="anchor"><a class="heading-anchor" href="#constructors"><span></span></a>Constructors</h3>

<h4 id="settings" class="anchor"><a class="heading-anchor" href="#settings"><span></span></a>Settings()</h4>

<pre class="prettyprint"><code>    TextOCR.Settings settings = new TextOCR.Settings();
</code></pre>

<p><strong>Description:</strong> Constructs a new <code>Settings</code> object with default values for all parameters.</p>

<hr>

<h3 id="groupersettings" class="anchor"><a class="heading-anchor" href="#groupersettings"><span></span></a>Grouper Settings</h3>

<p>The <code>GrouperSettings</code> class provides parameters for customizing the behavior of the OCR text grouping algorithm. It offers control over how text elements are spatially organized based on their geometric properties. By adjusting these settings, developers can fine-tune how text boxes are grouped into lines, paragraphs, or other structures based on their spatial relationships.</p>

<p>Grouping occurs in two stages. <a href="../types/#word">Words</a> detected by OCR are grouped into <a href="../types/#textline">Lines</a> that are further grouped into <a href="../types/#textparagraph">Paragraphs</a>. In the graphic representation below, Words, Lines and Paragraphs are represented by blue, green and fuchsia borders, respectively.</p>

<p><img alt="image" style="height:325px" src="./schema.png"></p>

<hr>

<h4 id="widthdistanceratio" class="anchor"><a class="heading-anchor" href="#widthdistanceratio"><span></span></a>widthDistanceRatio</h4>

<pre class="prettyprint"><code>    float TextOCR.Settings.GrouperSettings.widthDistanceRatio
</code></pre>

<p><strong>Description:</strong> Determines the threshold for joining Words into Lines. Adjusting this parameter allows control over acceptable spacing between Words in a Line. Words spaced beyond this threshold are treated as separate Lines. The default value of 1.5f indicates that the acceptable space between Words should not exceed 50% of their average width. Increasing this value to 2.0f allows for a maximum acceptable space of 100% of the average Word width.</p>

<p>For example, if the average Word width is 90 pixels, widthDistanceRatio of 2.0 allows words with centers up to 180 pixels apart to be grouped into the same Line.</p>

<p><strong>Tuning effect:</strong> Increasing this parameter causes horizontally spaced Words to join into a Line. Set this value higher if Words are spaced further apart and should be joined into a Line, such as in artistic layouts.</p>

<p><strong>Default:</strong> 1.5f</p>

<p><strong>Valid range:</strong> [0.0f, inf]</p>

<p><img alt="image" style="height:100px" src="./widthDistanceRatio.png"></p>

<hr>

<h4 id="heightdistanceratio" class="anchor"><a class="heading-anchor" href="#heightdistanceratio"><span></span></a>heightDistanceRatio</h4>

<pre class="prettyprint"><code>    float TextOCR.Settings.GrouperSettings.heightDistanceRatio
</code></pre>

<p><strong>Description:</strong> Affects the grouping of Words into Lines, particularly in scenarios where text undergoes a sudden change in font size but should still be grouped together. Although the algorithm has no knowledge of the actual font size, it uses the height of the complex bounding box to approximate it. The default value of 2.0f indicates that Words will be grouped together even if their font size differs by up to twice the height.</p>

<p>For example, setting this parameter to 4.0 allows words with height differences up to 4 times to be grouped into the same Line.</p>

<p><strong>Tuning effect:</strong> Increasing this parameter allows words of varying heights to join into a single Line. Raise this value higher when there is significant variation in text sizes within the same line, such as in documents with mixed fonts.</p>

<p><strong>Default</strong>: 2.0f</p>

<p><strong>Valid range:</strong> [1.0f, inf]</p>

<p><img alt="image" style="height:100px" src="./heightDistanceRatio.jpg"></p>

<hr>

<h4 id="centerdistanceratio" class="anchor"><a class="heading-anchor" href="#centerdistanceratio"><span></span></a>centerDistanceRatio</h4>

<pre class="prettyprint"><code>float TextOCR.Settings.GrouperSettings.centerDistanceRatio
</code></pre>

<p><strong>Description:</strong> Affects the joining of Words into Lines, particularly in scenarios where lines of text are not perfectly straight, such as in curved lines of text. The threshold value should be adjusted empirically, as it mathematically represents the relationship between the positions of two consecutive Words.</p>

<p>For example, if the average Word height is 20 pixels, setting centerDistanceRatio to 1.0 allows Words with centers up to 20 pixels apart vertically to be grouped into the same Line.</p>

<p><strong>Tuning effect:</strong> Increasing this parameter allows Words that are not vertically aligned to be joined into the same Line.</p>

<p><strong>Default:</strong> 0.6f</p>

<p><img alt="image" style="height:100px" src="./centerDistanceRatio.png"></p>

<hr>

<h4 id="paragraphheightdistance" class="anchor"><a class="heading-anchor" href="#paragraphheightdistance"><span></span></a>paragraphHeightDistance</h4>

<pre class="prettyprint"><code>    float TextOCR.Settings.GrouperSettings.paragraphHeightDistance
</code></pre>

<p><strong>Description:</strong> Determines the difference in vertical spacing between the center of two Lines to determine if they should be grouped into a Paragraph. It is particularly useful when the Lines of text have unusually large "leading", which refers to the distance between consecutive Lines in a Paragraph. The default value of 1.0f indicates that the Lines can be grouped into a paragraph if their centers are spaced apart by 100% of their average height.</p>

<p>For example, if the average Line height is 30 pixels, setting this parameter to 2 allows Lines with centers up to 60 pixels apart to be grouped into a Paragraph.</p>

<p><strong>Tuning effect:</strong> Increasing this parameter allows Lines that are spaced farther apart vertically to be joined into a Paragraph. Consider raising this value higher for documents with widely spaced Lines.</p>

<p><strong>Default:</strong> 1.0f</p>

<p><strong>Valid range:</strong> [0.0f, inf]</p>

<p><img alt="image" style="height:150px" src="./paragraphHeightDistance.png"></p>

<hr>

<h4 id="paragraphheightratiothreshold" class="anchor"><a class="heading-anchor" href="#paragraphheightratiothreshold"><span></span></a>paragraphHeightRatioThreshold</h4>

<pre class="prettyprint"><code>    float TextOCR.Settings.GrouperSettings.paragraphHeightRatioThreshold
</code></pre>

<p><strong>Description:</strong> Determines if there is a significant height difference between two rows, expressed as a ratio of the heights of two adjacent Lines, to decide whether they should be joined into a Paragraph. This can be useful in scenarios when Lines of varying font sizes should be joined into a single Paragraph. Although the algorithm has no knowledge of actual font sizes, it uses the height of the complex bounding box as an approximation. The default value of 1.0/3.0f (approximately 0.33) indicates that if consecutive Lines differ in height by a facotr of up to 3, they will still be grouped together into a single Paragraph.</p>

<p>For example, if the average Line height is 50 pixels, setting this parameter to 0.2 allows Lines with heights ranging from approximately 10 pixels to 250 pixels to be grouped into the same Paragraph.</p>

<p><strong>Tuning effect:</strong> Decreasing this parameter allows Lines with larger height differences to be joined into a Paragraph, which can be useful for documents with diverse fonts.</p>

<p><strong>Default:</strong> 0.33f</p>

<p><strong>Valid range:</strong> [0.0f, 1.0f]</p>

<p><img alt="image" style="height:150px" src="./paragraphHeightRatioThreshold.png"></p>

<hr>

<h4 id="samplecode-1" class="anchor"><a class="heading-anchor" href="#samplecode-1"><span></span></a>Sample Code</h4>

<p>To utilize the OCR capabilities of the <code>TextOCR</code> library, follow these steps to configure settings, prepare your image, and perform text detection:</p>

<ol>
<li><p><strong>Configure Settings:</strong> Initialize a <code>TextOCR.Settings</code> object and customize the <code>GrouperSettings</code> parameters for text grouping.</p></li>

<li><p><strong>Asynchronous Initialization:</strong> Use an <code>Executor</code> to initialize the <code>TextOCR</code> instance asynchronously, allowing for efficient resource management and responsiveness.</p></li>

<li><p><strong>Load Bitmap Image:</strong> Prepare the image for OCR by converting it to a Bitmap object.</p></li>

<li><p><strong>Perform OCR:</strong> Use the <code>detect</code> method to analyze the image, retrieving an array of <a href="../types/#ocrresult">OCRResult</a> objects with complex bounding boxes and recognized text.</p></li>

<li><p><strong>Process OCR Results:</strong> Handle the results by iterating over the <code>OCRResult</code> array, outputting the recognized text or using it for further processing.</p></li>

<li><p><strong>Dispose Resources:</strong> After completing OCR operations, call <code>dispose()</code> to release resources and prevent memory leaks.</p>

<pre class="prettyprint"><code>import com.zebra.ai.vision.TextOCR;

// Initialize TextOCR settings
TextOCR.Settings.GrouperSettings grouperSettings = new TextOCR.Settings.GrouperSettings();

// Access the GrouperSettings and set custom values for grouping parameters
textOCRSettings.grouping.widthDistanceRatio = 1.5f;
textOCRSettings.grouping.heightDistanceRatio = 2.0f;
textOCRSettings.grouping.centerDistanceRatio = 0.6f;
textOCRSettings.grouping.paragraphHeightDistance = 1.0f;
textOCRSettings.grouping.paragraphHeightRatioThreshold = 0.33f;

// Initialize executor
Executor executor = Executors.newFixedThreadPool(1);

// Input params include the bitmap image (to perform detection on) and an executor thread object (in which the detection happens)
CompletableFuture&lt;OCRResult[]&gt; futureResult = textocr.detect(bitmap,executor);

futureResult.thenAccept (ocrResults -&gt; {
    // Process the returned output that contains complex bounding boxes and text within it
});

// Dispose resources
// Once done using the textOCR object, dispose it to release resources and memory used for detection.
textOCR.dispose()
</code></pre></li>
</ol>

<hr>

<h3 id="tilersettings" class="anchor"><a class="heading-anchor" href="#tilersettings"><span></span></a>Tiler Settings</h3>

<p>The <code>TilerSettings</code> class provides a comprehensive set of parameters for controlling the tiling behavior of the <code>TextOCR</code> system. These settings are important for optimizing the detection and recognition of text in images, allowing for adjustments based on specific application needs and dataset characteristics. By fine-tuning these parameters, developers can significantly impact the performance and reliability of OCR processes.</p>

<p>Configure <code>TilerSettings</code> in the following scenarios:</p>

<ul>
<li><strong>Large Document Processing:</strong> Enable tiling to process large documents efficiently, especially when sections require individual handling due to size limitations.</li>

<li><strong>Complex Layout Handling:</strong> Adjust tiling settings for documents with complex layouts to improve the accuracy of text recognition.</li>

<li><strong>Performance Tuning:</strong> Fine-tune parameters to achieve an optimal balance between processing speed and accuracy, based on specific application requirements.</li>
</ul>

<hr>

<h4 id="tiling-1" class="anchor"><a class="heading-anchor" href="#tiling-1"><span></span></a>Tiling</h4>

<pre class="prettyprint"><code>    TilerSettings TextOCR.Settings.tiling
</code></pre>

<p><strong>Description:</strong> Tiling involves dividing a large image into smaller, manageable sections called "tiles" to analyze text more accurately. This structure contains parameters for handling very long text boxes.</p>

<hr>

<h4 id="enable" class="anchor"><a class="heading-anchor" href="#enable"><span></span></a>enable</h4>

<pre class="prettyprint"><code>    boolean TextOCR.Settings.TilerSettings.enable
</code></pre>

<p><strong>Description:</strong> Enables or disables the tiling feature. When true, <code>TextOCR</code> performs tiling operations on detected text regions, splitting boxes that meet aspect ratio criteria into multiple tiles, recognizing text, and merging results using a correlation method.</p>

<p><strong>Default:</strong> false</p>

<hr>

<h4 id="topcorrelationthr" class="anchor"><a class="heading-anchor" href="#topcorrelationthr"><span></span></a>topCorrelationThr</h4>

<pre class="prettyprint"><code>    float TextOCR.Settings.TilerSettings.topCorrelationThr
</code></pre>

<p><strong>Description:</strong> Limits the number of potential merging points used internally based on their correlation score.</p>

<p><strong>Tuning effect:</strong> Increasing this value restricts the merging mechanism to points with a correlation score higher than this value. Setting it to 0 removes the limit. If incorrect tiling occurs, increasing this parameter may help.</p>

<p><strong>Default:</strong> 0.0f</p>

<p><strong>Valid range:</strong> <code>[0.0f, 1.0f]</code></p>

<hr>

<h4 id="mergepointscutoff" class="anchor"><a class="heading-anchor" href="#mergepointscutoff"><span></span></a>mergePointsCutoff</h4>

<pre class="prettyprint"><code>    int TextOCR.Settings.TilerSettings.mergePointsCutoff
</code></pre>

<p><strong>Description:</strong> Limits the number of possible combinations used for tile merging.</p>

<p><strong>Tuning effect:</strong> Increasing this value results in more combinations being used, increasing processing time but potentially generating more accurate results.</p>

<p><strong>Default:</strong> 5</p>

<p><strong>Valid range:</strong> [1, max(int)]</p>

<hr>

<h4 id="splitmarginfactor" class="anchor"><a class="heading-anchor" href="#splitmarginfactor"><span></span></a>splitMarginFactor</h4>

<pre class="prettyprint"><code>    float TextOCR.Settings.TilerSettings.splitMarginFactor
</code></pre>

<p><strong>Description:</strong> Scales the confidence values for characters at the borders of consecutive tiles, assuming character deformation due to tiling. This value should not be modified.</p>

<p><strong>Default</strong>: 0.1f</p>

<p><strong>Valid range</strong>: <code>[0.0f, 1.0f]</code></p>

<hr>

<h4 id="aspectratiolowerthr" class="anchor"><a class="heading-anchor" href="#aspectratiolowerthr"><span></span></a>aspectRatioLowerThr</h4>

<pre class="prettyprint"><code>    float TextOCR.Settings.TilerSettings.aspectRatioLowerThr
</code></pre>

<p><strong>Description:</strong> Controls which text boxes will be tiled. Generally, only elongated boxes (high width/height aspect ratio) are tiled, since they likely contain long text strings. Only boxes with an aspect ratio higher than this threshold will be tiled. Tune this parameter together with <code>aspectRatioUpperThr</code>.</p>

<p><strong>Tuning effect:</strong> Decreasing this threshold results in more rectangular-shaped (low-aspect ratio) boxes being tiled. If the desired text box is not tiled, decreasing this parameter may help.</p>

<p><strong>Default:</strong> 10.0f</p>

<p><strong>Valid range:</strong> [1.0f, inf]</p>

<hr>

<h4 id="aspectratioupperthr" class="anchor"><a class="heading-anchor" href="#aspectratioupperthr"><span></span></a>aspectRatioUpperThr</h4>

<pre class="prettyprint"><code>    float TextOCR.Settings.TilerSettings.aspectRatioUpperThr
</code></pre>

<p><strong>Description:</strong> Filters boxes with very high aspect ratios, may rarely occur and be false positives from the text detector model. Tune this parameter together with <code>aspectRatioLowerThr</code>. A similar effect can be achieved with the <code>minBoxSize</code> parameter.</p>

<p><strong>Tuning effect:</strong> Increasing this parameter allows tiling of more long and narrow boxes.</p>

<p><strong>Default:</strong> 40.0f</p>

<p><strong>Valid range:</strong> [1.0f, inf]</p>

<hr>

<h4 id="topkmergedpredictions" class="anchor"><a class="heading-anchor" href="#topkmergedpredictions"><span></span></a>topkMergedPredictions</h4>

<pre class="prettyprint"><code>int TextOCR.Settings.TilerSettings.topkMergedPredictions
</code></pre>

<p><strong>Description:</strong> Limits the number of decodes returned based on confidence scores.</p>

<p><strong>Default:</strong> 5</p>

<p><strong>Valid range:</strong> [1, max(int)]</p>

<hr>

<h4 id="samplecode-2" class="anchor"><a class="heading-anchor" href="#samplecode-2"><span></span></a>Sample Code</h4>

<p>The <code>TilerSettings</code> object is part of the <code>TextOCR.Settings</code> configuration. Access and modify <code>TilerSettings</code> through the <code>TextOCR.Settings</code> object.</p>

<p>This sample code demonstrates how to configure <code>TilerSettings</code> and process the image for text detection and recognition:</p>

<ol>
<li><p><strong>Initialize Settings:</strong> Begin by creating a <code>TextOCR.Settings</code> instance.</p></li>

<li><p><strong>Configure TilerSettings:</strong> Access the <code>TilerSettings</code> within the <code>TextOCR.Settings</code> instance and set custom values for tiling parameters to control how the image is divided and processed.</p></li>

<li><p><strong>Instantiate TextOCR:</strong> Use the configured settings to create a <code>TextOCR</code> instance. This object will handle the text detection and recognition processes.</p></li>

<li><p><strong>Load Bitmap Image:</strong> Prepare the image for OCR by converting it to a <code>Bitmap</code> object.</p></li>

<li><p><strong>Perform Detection:</strong> Use the detect method to analyze the image and retrieve an array of <a href="../types/#ocrresult">OCRResult</a> objects containing the detected text.</p></li>

<li><p><strong>Print Results:</strong> Iterate over the <code>OCRResult</code> array to output the recognized text to the console.</p></li>

<li><p><strong>Dispose Resources:</strong> Free up system resources by calling the dispose method on the TextOCR object after usage.</p>

<pre class="prettyprint"><code>import com.zebra.aivision.TextOCR;
import com.zebra.aivision.TextOCR.Settings;
import com.zebra.aivision.TextOCR.Settings.TilerSettings;
import android.graphics.Bitmap;

// Initialize settings with custom tiling options
TextOCR.Settings.TilerSettings tilerSettings = new TextOCR.Settings.TilerSettings();
tilerSettings.tiling.enable = true;
tilerSettings.tiling.aspectRatioLowerThr = 8.0f;
tilerSettings.tiling.aspectRatioUpperThr = 35.0f;
tilerSettings.tiling.mergePointsCutoff = 10;

// Initialize executor
Executor executor = Executors.newFixedThreadPool(1);

// Input params: bitmap image (to perform detection) and an executor thread object (in which the detection happens and the results are returned)
CompletableFuture&lt;OCRResult[]&gt; futureResult = textocr.detect(bitmap,executor);

futureResult.thenAccept (ocrResults -&gt; {
    //Process the returned output that contains complex bounding boxes and text in it.
});

// Dispose resources
// Once done using the textOCR object, dispose it to release resources and memory used for detection.
textOCR.dispose()
</code></pre></li>
</ol>

<hr>

<h3 id="detectionparameters" class="anchor"><a class="heading-anchor" href="#detectionparameters"><span></span></a>Detection Parameters</h3>

<p>The Detection phase processes the input image to create <a href="../types/#complexbbox">complex bounding boxes</a>, or text boxes. Each text box is represented by a list of points forming a rotated rectangle, which may not be perfectly aligned with the screen’s edges. There may be more than four points if the rectangle is clipped at the edges of the screen. To refine detection accuracy, adjust the <strong>Detection Parameters</strong> accordingly.</p>

<p>Typical scenarios for adjusting Detection Parameters:</p>

<ul>
<li><strong>Document Scanning:</strong> Digitize documents by extracting text for storage and retrieval.</li>

<li><strong>Real-Time Text Recognition:</strong> Integrate into applications requiring immediate text recognition from images or video streams.</li>

<li><strong>Automated Data Entry:</strong> Streamline data entry by automatically extracting text from forms or invoices.</li>
</ul>

<!--
#### detectionModelName

        TextOCR.Settings.detectionModelName

**Description:** Name of the detector model within the OCR resource archive.
-->

<hr>

<h4 id="flip-1" class="anchor"><a class="heading-anchor" href="#flip-1"><span></span></a>flip</h4>

<pre class="prettyprint"><code>    boolean TextOCR.Settings.flip
</code></pre>

<p><strong>Description:</strong> If set to true, performs recognition twice - once in the regular orientation and once rotated by 180 degrees.</p>

<!--

#### recognitionModelName

        TextOCR.Settings.recognitionModelName

**Description:** Name of the recognition model within the OCR resource archive.

---

#### resourceName

        TextOCR.Settings.resourceName

**Description:** File path to the OCR resources, including models.

---

-->

<h4 id="detectioninferenceroptions" class="anchor"><a class="heading-anchor" href="#detectioninferenceroptions"><span></span></a>detectionInferencerOptions</h4>

<pre class="prettyprint"><code>    InferencerOptions TextOCR.Settings.detectionInferencerOptions = new InferencerOptions()
</code></pre>

<p><strong>Description:</strong> Allows developers to specify a different input shape for the detection stage inferencer.</p>

<hr>

<h4 id="recognitioninferenceroptions" class="anchor"><a class="heading-anchor" href="#recognitioninferenceroptions"><span></span></a>recognitionInferencerOptions</h4>

<pre class="prettyprint"><code>    InferencerOptions TextOCR.Settings.recognitionInferencerOptions = new InferencerOptions()
</code></pre>

<p><strong>Description:</strong> Typically remains unchanged as the input size is fixed for the recognition model. If needed, Recognition results can be adjusted using parameters in the <a href="#recognitionparameters">Recognition Parameters</a> section.
<strong>Note:</strong> These options should not be changed by the developer.</p>

<hr>

<h4 id="heatmapthreshold" class="anchor"><a class="heading-anchor" href="#heatmapthreshold"><span></span></a>heatmapThreshold</h4>

<pre class="prettyprint"><code>    float TextOCR.Settings.heatmapThreshold
</code></pre>

<p><strong>Description:</strong> Sets a cutoff to identify potential areas likely to contain text, converting them into text boxes. (Internally, the detector model creates a grayscale image, or heatmap, that represents text confidence.)</p>

<p><strong>Tuning effect:</strong></p>

<ul>
<li><strong>Increase Threshold -</strong> Reduces areas identified as text, useful for high-contrast images like scanned documents.</li>

<li><strong>Decrease Threshold -</strong> Expands areas identified as text, useful for low-contrast or barely visible text.</li>
</ul>

<p><strong>Default:</strong> 0.5f</p>

<p><strong>Valid range:</strong> [0.0f, 1.0f]</p>

<hr>

<h4 id="minboxarea" class="anchor"><a class="heading-anchor" href="#minboxarea"><span></span></a>minBoxArea</h4>

<pre class="prettyprint"><code>    int TextOCR.Settings.minBoxArea
</code></pre>

<p><strong>Description:</strong> Filters out small, unimportant boxes from the OCR output.</p>

<p><strong>Tuning effect:</strong> Increasing this parameter filters out boxes with small areas.</p>

<p><strong>Default:</strong> 10
<strong>Valid range:</strong> [0, max(int)]</p>

<hr>

<h4 id="boxthreshold" class="anchor"><a class="heading-anchor" href="#boxthreshold"><span></span></a>boxThreshold</h4>

<pre class="prettyprint"><code>    float TextOCR.Settings.boxThreshold
</code></pre>

<p><strong>Description:</strong> Sets the minimum confidence score required for a text box to be included in the OCR output. Boxes with confidence scores below this threshold are excluded, helping to filter out less certain text detections.</p>

<p><strong>Tuning effect:</strong></p>

<ul>
<li><strong>Increase Threshold:</strong> Excludes less-confident text boxes, useful when too many boxes are detected.</li>

<li><strong>Decrease Threshold:</strong> Includes more text boxes, which might be necessary when important text is being missed.</li>
</ul>

<p><strong>Default:</strong> 0.85f</p>

<p><strong>Valid range:</strong> [0, 1.0]</p>

<hr>

<h4 id="minboxsize" class="anchor"><a class="heading-anchor" href="#minboxsize"><span></span></a>minBoxSize</h4>

<pre class="prettyprint"><code>    int TextOCR.Settings.minBoxSize
</code></pre>

<p><strong>Description:</strong> Filters out very narrow boxes (low height or width) that likely do not contain real text.</p>

<p><strong>Tuning effect:</strong> Increasing this parameter filters out very narrow boxes.</p>

<p><strong>Default:</strong> 1</p>

<p><strong>Valid range:</strong> [0, max(int)]</p>

<hr>

<h4 id="minratioforrotation" class="anchor"><a class="heading-anchor" href="#minratioforrotation"><span></span></a>minRatioForRotation</h4>

<pre class="prettyprint"><code>    float TextOCR.Settings.minRatioForRotation
</code></pre>

<p><strong>Description:</strong> Rotates vertically oriented text boxes to horizontal to improve recognition. Adjust this value for images with significant rotated text. <strong>Note:</strong> Words are generally wider than they are tall, so their ratio should exceed the default value. Therefore, avoid changing this parameter for words, since word complex bounding boxes should be horizontally oriented before recognition.</p>

<p><strong>Tuning effect:</strong> Setting this parameter to 0 disables rotation. Otherwise, rotate boxes with a height-to-width ratio exceeding this value 90 degrees counterclockwise before recognition.</p>

<p><strong>Default:</strong> 1.5f</p>

<p><strong>Valid range:</strong> [0.0f, inf] (where ‘inf’ denotes infinity)</p>

<hr>

<h4 id="unclipratio" class="anchor"><a class="heading-anchor" href="#unclipratio"><span></span></a>unclipRatio</h4>

<pre class="prettyprint"><code>    float TextOCR.Settings.unclipRatio
</code></pre>

<p><strong>Description:</strong> Slightly stretches text boxes before recognition to improve results. Tight-fitting boxes might benefit from some extra background for better decoding.</p>

<p><strong>Tuning effect:</strong> Increasing this parameter enlarges text boxes, potentially improving recognition. An <code>unclipRatio</code> of 1 keeps boxes unchanged, while 1.5 enlarges them by 50%.</p>

<p><strong>Default:</strong> 1.5f</p>

<p><strong>Valid range:</strong> [1.0f, inf]</p>

<hr>

<h4 id="samplecode-3" class="anchor"><a class="heading-anchor" href="#samplecode-3"><span></span></a>Sample Code</h4>

<p>This sample code demonstrates how to adjust detection parameter settings:</p>

<ol>
<li><p><strong>Configure Settings:</strong> Initialize a <code>TextOCR.Settings</code> object and customize parameters such as <code>heatmapThreshold</code> and <code>boxThreshold</code> to improve detection accuracy based on your specific needs.</p></li>

<li><p><strong>Asynchronous Initialization:</strong> Use an <code>Executor</code> to initialize the <code>TextOCR</code> instance asynchronously, allowing for efficient resource management and responsiveness.</p></li>

<li><p><strong>Load Bitmap Image:</strong> Prepare the image for OCR by converting it to a Bitmap object.</p></li>

<li><p><strong>Perform OCR:</strong> Use the <code>detect</code> method to analyze the image and retrieve an array of <a href="../types/#ocrresult">OCRResult</a> objects with complex bounding boxes and recognized text.</p></li>

<li><p><strong>Process OCR Results:</strong> Handle the results by iterating over the <code>OCRResult</code> array, outputting the recognized text or using it for further processing.</p></li>

<li><p><strong>Dispose Resources:</strong> After completing OCR operations, call <code>dispose()</code> to release resources and prevent memory leaks.</p>

<pre class="prettyprint"><code>import com.zebra.ai.vision.TextOCR;
import com.zebra.ai.vision.TextOCR.Settings;
import android.graphics.Bitmap;

// Initialize settings with a custom heatmap threshold
TextOCR.Settings textOCRSettings = new TextOCR.Settings ();
settings.heatmapThreshold = 0.3f; // Lower threshold for low-contrast text
settings.boxThreshold = 0.9f; // Higher threshold for more confident text boxes
settings.minBoxSize = 10; // Set minimum box size to 10 pixels
settings.minBoxArea = 50; // Set minimum box area to 50 pixels
settings.unclipRatio = 2.0f; // Enlarge text boxes by 100%
settings.minRatioForRotation = 2.0f; // Rotate boxes with height-to-width ratio exceeding 2.0

// Initialize executor
Executor executor = Executors.newFixedThreadPool(1);

CompletableFuture&lt;TextOCR&gt; futureObject = getTextOCR(textOCRSettings, executor);

// Use the futureObject to implement thenAccept() callback of CompletableFuture
futureObject.thenAccept (OCRInstance -&gt; {
    // Use the Textocr object returned here for the detection of barcodes/shelves/products
      textocr = OCRInstance;
});

// Load your Bitmap image
Bitmap image = ...; // Your input image

// Perform OCR
CompletableFuture&lt;OCRResult[]&gt; futureResult = textocr.detect(bitmap,executor);
futureResult.thenAccept (ocrResults -&gt; {
      // Process the returned output that contains complex bounding boxes and text in it
});

// Dispose resources
// Once use of the textOCR object is done, dispose of it to release the resources and memory used for detection
textOCR.dispose();
</code></pre></li>
</ol>

<hr>

<h3 id="recognitionparameters" class="anchor"><a class="heading-anchor" href="#recognitionparameters"><span></span></a>Recognition Parameters</h3>

<p>The Recognition stage analyzes the text within each <a href="../types/#complexbbox">complex bounding box</a>, or text box, produced during the Detection Stage to identify the text content. Each text box results in a list of potential text decodes. Adjusting the <strong>Recognition Parameters</strong> can help refine the recognition process.</p>

<h4 id="decodingmaxwordcombinations" class="anchor"><a class="heading-anchor" href="#decodingmaxwordcombinations"><span></span></a>decodingMaxWordCombinations</h4>

<pre class="prettyprint"><code>    int TextOCR.Settings.decodingMaxWordCombinations
</code></pre>

<p><strong>Description:</strong> Specifies the maximum number of possible text decodes returned in the output. This parameter helps balance the quantity and confidence of text outputs. It is applicable for the following scenarios:</p>

<ul>
<li><strong>Detailed Text Analysis -</strong> Increase this parameter for applications that require a thorough analysis of text.</li>

<li><strong>Data Extraction -</strong> Adjust this parameter to optimize the extraction of comprehensive data from documents with complex or ambiguous text.</li>
</ul>

<p><strong>Tuning effect:</strong> Increasing this number returns more decodes, but potentially with lower confidence.</p>

<p><strong>Default:</strong> 10</p>

<p><strong>Valid range:</strong> [1, max(int)]</p>

<hr>

<h4 id="decodingtotalprobthreshold" class="anchor"><a class="heading-anchor" href="#decodingtotalprobthreshold"><span></span></a>decodingTotalProbThreshold</h4>

<pre class="prettyprint"><code>    float TextOCR.Settings.decodingTotalProbThreshold
</code></pre>

<p><strong>Description:</strong> Sets the minimum cumulative confidence score that character decodes must achieve to be considered valid. This setting is crucial in the total decoding strategy of the OCR recognition process, as it balances accuracy and coverage in text recognition. If the threshold is not reached, no high-confidence decode exists, resulting in a placeholder character (�) appearing in the output.</p>

<p>Relevant scenarios:</p>

<ul>
<li><strong>Improving Decode Coverage -</strong> Lower the threshold when critical text characters are missing, to capture a wider range of more potential decodes.</li>

<li><strong>Analyzing Complex Documents -</strong> Apply this setting for documents with ambiguous or low-quality text to ensure more comprehensive character recognition.</li>

<li><strong>Adaptive Recognition -</strong> Adjust dynamically based on the quality and complexity of input documents to optimize OCR performance for specific needs.</li>
</ul>

<p><strong>Tuning effect:</strong> If many characters are not decoded, evidenced by multiple � characters, decreasing this value may improve results.</p>

<p><strong>Default:</strong> 0.9f</p>

<p><strong>Valid range:</strong> [0.0f, 1.0f]</p>

<hr>

<h4 id="decodingtopkignorecutoff" class="anchor"><a class="heading-anchor" href="#decodingtopkignorecutoff"><span></span></a>decodingTopkIgnoreCutoff</h4>

<pre class="prettyprint"><code>    int TextOCR.Settings.decodingTopkIgnoreCutoff
</code></pre>

<p><strong>Description:</strong> Sets the maximum number of decodes considered for each character before calculating the cumulative probability, impacting the accuracy and completeness of text recognition. It is used specifically within the Total decoding strategy of the OCR recognition process. This parameter is applicable for the following scenarios:</p>

<ul>
<li><strong>Complex Text Recognition -</strong> Increase this parameter for documents with complex or ambiguous text where capturing all character variations is crucial.</li>

<li><strong>Improving Character Accuracy -</strong> Use this setting in scenarios where critical text components are consistently missing, ensuring thorough character analysis.</li>

<li><strong>Adaptive Text Processing -</strong> Adjust dynamically based on the complexity and quality of input text to optimize OCR performance.</li>
</ul>

<p><strong>Tuning effect:</strong> Generally, keep this at the default value. If the expected character does not appear in the OCR output, increasing this value allows for more less confident decodes.</p>

<p><strong>Default:</strong> 4</p>

<p><strong>Valid range:</strong> [1, max(int)]</p>

<hr>

<h4 id="samplecode-4" class="anchor"><a class="heading-anchor" href="#samplecode-4"><span></span></a>Sample Code</h4>

<p>Sample code demonstrating use of recognition parameters:</p>

<ol>
<li><p><strong>Initialize Settings:</strong> Configure the OCR settings, including additional parameters such as <code>heatmapThreshold</code> and <code>tiling</code>.</p></li>

<li><p><strong>Create TextOCR Instance:</strong> Use an executor to initialize the <code>TextOCR</code> instance asynchronously with the configured settings.</p></li>

<li><p><strong>Load Bitmap Image:</strong> Prepare the bitmap image that you want to analyze using OCR.</p></li>

<li><p><strong>Perform OCR:</strong> Invoke the <code>detect</code> method on the <code>TextOCR</code> instance to analyze the bitmap image, managing the asynchronous processing with the executor.</p></li>

<li><p><strong>Process OCR Results:</strong> Handle the results, which include complex bounding boxes and recognized text.</p></li>

<li><p><strong>Dispose Resources:</strong> After completing OCR operations, call the <code>dispose</code> method on the <code>TextOCR</code> instance to release resources and prevent memory leaks.</p>

<pre class="prettyprint"><code>import com.zebra.ai.vision.TextOCR;
import com.zebra.ai.vision.TextOCR.Settings;
import android.graphics.Bitmap;

// Initialize settings
TextOCR.Settings textOCRSettings = new TextOCR.Settings ();
textOCRSettings.heatmapThreshold = 0.5f;
textOCRSettings.decodingTotalProbThreshold = 0.9f;
textOCRSettings.tiling.enable = true;

// Instantiate TextOCR with the configured settings
// settings = TextOCR.Settings object created above
// Executor = An executor thread for processing API calls and returning results

// Initialize executor
Executor executor = Executors.newFixedThreadPool(1);

CompletableFuture&lt;TextOCR&gt; futureObject = getTextOCR(textOCRSettings, executor);

// Use the futureObject to implement thenAccept() callback of CompletableFuture.
futureObject.thenAccept (OCRInstance -&gt; {
    // Use the textocr object returned here detecting barcodes, shelves, or products
    textocr = OCRInstance;
});

// Load your Bitmap image
Bitmap image = ...;

// Perform OCR
CompletableFuture&lt;OCRResult[]&gt; futureResult = textocr.detect(bitmap,executor);
futureResult.thenAccept (ocrResults -&gt; {
    // Process the returned output that contains complex bounding boxes and recognized text
});

// Dispose resources
// Once done using the textOCR object, dispose it to release resources and memory used for detection.
textOCR.dispose()
</code></pre></li>
</ol>

<hr>

<h2 id="sampleapp" class="anchor"><a class="heading-anchor" href="#sampleapp"><span></span></a>Sample App</h2>

<p>Consult the <a href="https://github.com/zebratechnologies/Zebra_AISuite_SDK_Sample_Apps/tree/main/TextOCR_Sample_app">TextOCR Sample App</a>, which demonstrates how to detect and display text from images, offering options for text overlay, text grouping, region of interest adjustments, and other configurable settings.</p>

<hr>

<p>Related Guides:</p>

<ul>
<li><a href="../about/">About</a></li>

<li><a href="../setup/">Setup</a></li>

<li><a href="../localizer/">Localizer</a></li>

<li><a href="../productrecognition/">Product Recognition</a>


<ul>
<li><a href="../productrecognition/#featureextractor">Feature Extractor</a></li>

<li><a href="../productrecognition/#featurestorage">Feature Storage</a></li>

<li><a href="../productrecognition/#recognizer">Recognizer</a></li></ul>
</li>

<li><a href="../barcodedecoder/">Barcode Decoder</a></li>

<li><a href="../types/">Data Types</a></li>

<li><a href="../entity/">Entity</a></li>
</ul><p></p>
                                        


                                    </div>
                                </div>

                            </div>
                        </div>
                    </div>
                </div><!--/.col-sm-6-->
            </div>
            </section>
        </div>
    </section>    

<div class="modal fade" id="basicModal" tabindex="-1" role="dialog" aria-labelledby="basicModal" aria-hidden="true" data-backdrop="true">
			<div class="modal-dialog">
				<div class="modal-content">
					<div class="modal-header">
						<button type="button" class="close" data-dismiss="modal" aria-hidden="true">X</button>
					</div>
					<div class="modal-body">
						<div id="modalImg">
						
						</div>
					</div>
			</div>
		  </div>
		</div> </div>
         <footer id="footer">
            <div class="container-fluid">
                <div class="row">
                    <div class="col-sm-10">
                        ZEBRA and the stylized Zebra head are trademarks of Zebra Technologies Corp., registered in many jurisdictions worldwide. All other trademarks are the property of their respective owners. ©2025 Zebra Technologies Corp. and/or its affiliates.<br> <a href="https://www.zebra.com/us/en/about-zebra/company-information/legal.html">Legal</a> | <a href="https://www.zebra.com/us/en/about-zebra/company-information/compliance/information-privacy/terms-of-use.html">Terms of Use</a> | <a href="https://www.zebra.com/us/en/about-zebra/company-information/legal/privacy-statement.html">Privacy Policy</a> 
                    </div>
                     <!--
                     <div class="col-sm-2">
                        <ul class="social-icons">
                            <li><a href="http://www.facebook.com/pages/Zebra-Technologies/107703715989073"><i class="fa fa-facebook"></i></a></li>
                            <li><a href="https://twitter.com/ZebraDevs"><i class="fa fa-twitter"></i></a></li>
                            <li><a href="http://www.youtube.com/zebratechnologies/"><i class="fa fa-youtube"></i></a></li>
                            <li><a href="https://www.linkedin.com/groups?home=&gid=3220074&trk=anet_ug_hm&goback=%2Egmr_3220074"><i class="fa fa-linkedin"></i></a></li>
                            <li><a href="https://github.com/developer-zebra"><i class="fa fa-github"></i></a></li>
                        </ul>
                    </div> -->
                 </div>
            </div>
        </footer>
    
    <!--/#footer 
        10/25/18 removed <footer id="footer" class="navbar-fixed-bottom">
    -->
    <script src="/js/bootstrap.min.js"></script>
    <script src="/js/owl.carousel.min.js"></script>
    <script src="/js/mousescroll.js"></script>
    <script src="/js/smoothscroll.js"></script>
    <script src="/js/jquery.prettyPhoto.js"></script>
    <script src="/js/jquery.isotope.min.js"></script>
    <script src="/js/jquery.inview.min.js"></script>
    <script src="/js/wow.min.js"></script>
    <script src="/js/bootstrap-treenav.min.js"></script>
    <script src="/js/prettify.js"></script>
    <script src="/js/zepto.js"></script>
    <script src="/js/jquery.waterfall.js"></script>   
    <script src="/js/main.js"></script>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','zRzEsAUhWTTkrdEN2YfA','2.0.0');
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-72584442-1', 'auto');
  ga('send', 'pageview');

</script> 

<script>
    ChatraID = 'QDvZ76min4DhLW5vJ';
    (function(d, w, c) {
        var n = d.getElementsByTagName('script')[0],
            s = d.createElement('script');
        w[c] = w[c] || function() {
            (w[c].q = w[c].q || []).push(arguments);
        };
        s.async = true;
        s.src = (d.location.protocol === 'https:' ? 'https:': 'http:')
            + '//call.chatra.io/chatra.js';
        n.parentNode.insertBefore(s, n);
    })(document, window, 'Chatra');
</script>         


</body></html>